// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(cryptoFFI)
    import cryptoFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_concordium_wallet_crypto_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_concordium_wallet_crypto_uniffi_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

/**
 * An account credential containing proofs without signatures.
 * To deploy a credential, an object of this type is
 * hashed using `account_credential_deployment_hash_hex`
 * which is signed using the key derived for the credential.
 * The results are collected into a `SignedAccountCredential`
 * and serialized using `account_credential_deployment_signed_payload_hex`.
 * The result of this call can be submitted to the chain.
 */
public struct AccountCredential {
    /**
     * List of anonymity revokers which can revoke the identity.
     * The order is important since it is the same order as that signed by the identity provider,
     * and permuting the list will invalidate the signature from the identity provider.
     */
    public var arData: [UInt32: ChainArData]
    /**
     * Credential registration ID of the credential.
     */
    public var credIdHex: String
    /**
     * Credential keys (i.e. account holder keys).
     */
    public var credentialPublicKeys: CredentialPublicKeys
    /**
     * Identity of the identity provider who signed the identity object
     * from which this credential is derived.
     */
    public var ipIdentity: UInt32
    /**
     * Policy of this credential object.
     */
    public var policy: Policy
    public var proofs: Proofs
    /**
     * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
     */
    public var revocationThreshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * List of anonymity revokers which can revoke the identity.
         * The order is important since it is the same order as that signed by the identity provider,
         * and permuting the list will invalidate the signature from the identity provider.
         */
        arData: [UInt32: ChainArData],
        /**
            * Credential registration ID of the credential.
            */
        credIdHex: String,
        /**
            * Credential keys (i.e. account holder keys).
            */
        credentialPublicKeys: CredentialPublicKeys,
        /**
            * Identity of the identity provider who signed the identity object
            * from which this credential is derived.
            */
        ipIdentity: UInt32,
        /**
            * Policy of this credential object.
            */
        policy: Policy,
        proofs: Proofs,
        /**
            * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
            */
        revocationThreshold: UInt8
    ) {
        self.arData = arData
        self.credIdHex = credIdHex
        self.credentialPublicKeys = credentialPublicKeys
        self.ipIdentity = ipIdentity
        self.policy = policy
        self.proofs = proofs
        self.revocationThreshold = revocationThreshold
    }
}

extension AccountCredential: Equatable, Hashable {
    public static func == (lhs: AccountCredential, rhs: AccountCredential) -> Bool {
        if lhs.arData != rhs.arData {
            return false
        }
        if lhs.credIdHex != rhs.credIdHex {
            return false
        }
        if lhs.credentialPublicKeys != rhs.credentialPublicKeys {
            return false
        }
        if lhs.ipIdentity != rhs.ipIdentity {
            return false
        }
        if lhs.policy != rhs.policy {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        if lhs.revocationThreshold != rhs.revocationThreshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(arData)
        hasher.combine(credIdHex)
        hasher.combine(credentialPublicKeys)
        hasher.combine(ipIdentity)
        hasher.combine(policy)
        hasher.combine(proofs)
        hasher.combine(revocationThreshold)
    }
}

public struct FfiConverterTypeAccountCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredential {
        return
            try AccountCredential(
                arData: FfiConverterDictionaryUInt32TypeChainArData.read(from: &buf),
                credIdHex: FfiConverterString.read(from: &buf),
                credentialPublicKeys: FfiConverterTypeCredentialPublicKeys.read(from: &buf),
                ipIdentity: FfiConverterUInt32.read(from: &buf),
                policy: FfiConverterTypePolicy.read(from: &buf),
                proofs: FfiConverterTypeProofs.read(from: &buf),
                revocationThreshold: FfiConverterUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: AccountCredential, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt32TypeChainArData.write(value.arData, into: &buf)
        FfiConverterString.write(value.credIdHex, into: &buf)
        FfiConverterTypeCredentialPublicKeys.write(value.credentialPublicKeys, into: &buf)
        FfiConverterUInt32.write(value.ipIdentity, into: &buf)
        FfiConverterTypePolicy.write(value.policy, into: &buf)
        FfiConverterTypeProofs.write(value.proofs, into: &buf)
        FfiConverterUInt8.write(value.revocationThreshold, into: &buf)
    }
}

public func FfiConverterTypeAccountCredential_lift(_ buf: RustBuffer) throws -> AccountCredential {
    return try FfiConverterTypeAccountCredential.lift(buf)
}

public func FfiConverterTypeAccountCredential_lower(_ value: AccountCredential) -> RustBuffer {
    return FfiConverterTypeAccountCredential.lower(value)
}

/**
 * Parameter object for `account_credential`.
 */
public struct AccountCredentialParameters {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var arsInfos: [UInt32: AnonymityRevokerInfo]
    public var idObject: IdentityObject
    public var revealedAttributes: [UInt8]
    public var credNumber: UInt8
    public var idCredSecHex: String
    public var prfKeyHex: String
    public var blindingRandomnessHex: String
    public var attributeRandomnessHex: [String: String]
    public var credentialPublicKeys: CredentialPublicKeys

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        ipInfo: IdentityProviderInfo,
        globalContext: GlobalContext,
        arsInfos: [UInt32: AnonymityRevokerInfo],
        idObject: IdentityObject,
        revealedAttributes: [UInt8],
        credNumber: UInt8,
        idCredSecHex: String,
        prfKeyHex: String,
        blindingRandomnessHex: String,
        attributeRandomnessHex: [String: String],
        credentialPublicKeys: CredentialPublicKeys
    ) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.arsInfos = arsInfos
        self.idObject = idObject
        self.revealedAttributes = revealedAttributes
        self.credNumber = credNumber
        self.idCredSecHex = idCredSecHex
        self.prfKeyHex = prfKeyHex
        self.blindingRandomnessHex = blindingRandomnessHex
        self.attributeRandomnessHex = attributeRandomnessHex
        self.credentialPublicKeys = credentialPublicKeys
    }
}

extension AccountCredentialParameters: Equatable, Hashable {
    public static func == (lhs: AccountCredentialParameters, rhs: AccountCredentialParameters) -> Bool {
        if lhs.ipInfo != rhs.ipInfo {
            return false
        }
        if lhs.globalContext != rhs.globalContext {
            return false
        }
        if lhs.arsInfos != rhs.arsInfos {
            return false
        }
        if lhs.idObject != rhs.idObject {
            return false
        }
        if lhs.revealedAttributes != rhs.revealedAttributes {
            return false
        }
        if lhs.credNumber != rhs.credNumber {
            return false
        }
        if lhs.idCredSecHex != rhs.idCredSecHex {
            return false
        }
        if lhs.prfKeyHex != rhs.prfKeyHex {
            return false
        }
        if lhs.blindingRandomnessHex != rhs.blindingRandomnessHex {
            return false
        }
        if lhs.attributeRandomnessHex != rhs.attributeRandomnessHex {
            return false
        }
        if lhs.credentialPublicKeys != rhs.credentialPublicKeys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ipInfo)
        hasher.combine(globalContext)
        hasher.combine(arsInfos)
        hasher.combine(idObject)
        hasher.combine(revealedAttributes)
        hasher.combine(credNumber)
        hasher.combine(idCredSecHex)
        hasher.combine(prfKeyHex)
        hasher.combine(blindingRandomnessHex)
        hasher.combine(attributeRandomnessHex)
        hasher.combine(credentialPublicKeys)
    }
}

public struct FfiConverterTypeAccountCredentialParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredentialParameters {
        return
            try AccountCredentialParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf),
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf),
                arsInfos: FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.read(from: &buf),
                idObject: FfiConverterTypeIdentityObject.read(from: &buf),
                revealedAttributes: FfiConverterSequenceUInt8.read(from: &buf),
                credNumber: FfiConverterUInt8.read(from: &buf),
                idCredSecHex: FfiConverterString.read(from: &buf),
                prfKeyHex: FfiConverterString.read(from: &buf),
                blindingRandomnessHex: FfiConverterString.read(from: &buf),
                attributeRandomnessHex: FfiConverterDictionaryStringString.read(from: &buf),
                credentialPublicKeys: FfiConverterTypeCredentialPublicKeys.read(from: &buf)
            )
    }

    public static func write(_ value: AccountCredentialParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.write(value.arsInfos, into: &buf)
        FfiConverterTypeIdentityObject.write(value.idObject, into: &buf)
        FfiConverterSequenceUInt8.write(value.revealedAttributes, into: &buf)
        FfiConverterUInt8.write(value.credNumber, into: &buf)
        FfiConverterString.write(value.idCredSecHex, into: &buf)
        FfiConverterString.write(value.prfKeyHex, into: &buf)
        FfiConverterString.write(value.blindingRandomnessHex, into: &buf)
        FfiConverterDictionaryStringString.write(value.attributeRandomnessHex, into: &buf)
        FfiConverterTypeCredentialPublicKeys.write(value.credentialPublicKeys, into: &buf)
    }
}

public func FfiConverterTypeAccountCredentialParameters_lift(_ buf: RustBuffer) throws -> AccountCredentialParameters {
    return try FfiConverterTypeAccountCredentialParameters.lift(buf)
}

public func FfiConverterTypeAccountCredentialParameters_lower(_ value: AccountCredentialParameters) -> RustBuffer {
    return FfiConverterTypeAccountCredentialParameters.lower(value)
}

/**
 * The result of a new credential being created using the function `account_credential`.
 */
public struct AccountCredentialResult {
    public var credential: AccountCredential
    public var randomness: Randomness

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        credential: AccountCredential,
        randomness: Randomness
    ) {
        self.credential = credential
        self.randomness = randomness
    }
}

extension AccountCredentialResult: Equatable, Hashable {
    public static func == (lhs: AccountCredentialResult, rhs: AccountCredentialResult) -> Bool {
        if lhs.credential != rhs.credential {
            return false
        }
        if lhs.randomness != rhs.randomness {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(credential)
        hasher.combine(randomness)
    }
}

public struct FfiConverterTypeAccountCredentialResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredentialResult {
        return
            try AccountCredentialResult(
                credential: FfiConverterTypeAccountCredential.read(from: &buf),
                randomness: FfiConverterTypeRandomness.read(from: &buf)
            )
    }

    public static func write(_ value: AccountCredentialResult, into buf: inout [UInt8]) {
        FfiConverterTypeAccountCredential.write(value.credential, into: &buf)
        FfiConverterTypeRandomness.write(value.randomness, into: &buf)
    }
}

public func FfiConverterTypeAccountCredentialResult_lift(_ buf: RustBuffer) throws -> AccountCredentialResult {
    return try FfiConverterTypeAccountCredentialResult.lift(buf)
}

public func FfiConverterTypeAccountCredentialResult_lower(_ value: AccountCredentialResult) -> RustBuffer {
    return FfiConverterTypeAccountCredentialResult.lower(value)
}

/**
 * Information on an anonymity revoker held by the identity provider.
 */
public struct AnonymityRevokerInfo {
    /**
     * Unique identifier of the anonymity revoker.
     */
    public var identity: UInt32
    /**
     * Description of the anonymity revoker (e.g. name, contact number).
     */
    public var description: Description
    /**
     * Elgamal encryption key of the anonymity revoker.
     */
    public var publicKeyHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier of the anonymity revoker.
         */
        identity: UInt32,
        /**
            * Description of the anonymity revoker (e.g. name, contact number).
            */
        description: Description,
        /**
            * Elgamal encryption key of the anonymity revoker.
            */
        publicKeyHex: String
    ) {
        self.identity = identity
        self.description = description
        self.publicKeyHex = publicKeyHex
    }
}

extension AnonymityRevokerInfo: Equatable, Hashable {
    public static func == (lhs: AnonymityRevokerInfo, rhs: AnonymityRevokerInfo) -> Bool {
        if lhs.identity != rhs.identity {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.publicKeyHex != rhs.publicKeyHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identity)
        hasher.combine(description)
        hasher.combine(publicKeyHex)
    }
}

public struct FfiConverterTypeAnonymityRevokerInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnonymityRevokerInfo {
        return
            try AnonymityRevokerInfo(
                identity: FfiConverterUInt32.read(from: &buf),
                description: FfiConverterTypeDescription.read(from: &buf),
                publicKeyHex: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: AnonymityRevokerInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.identity, into: &buf)
        FfiConverterTypeDescription.write(value.description, into: &buf)
        FfiConverterString.write(value.publicKeyHex, into: &buf)
    }
}

public func FfiConverterTypeAnonymityRevokerInfo_lift(_ buf: RustBuffer) throws -> AnonymityRevokerInfo {
    return try FfiConverterTypeAnonymityRevokerInfo.lift(buf)
}

public func FfiConverterTypeAnonymityRevokerInfo_lower(_ value: AnonymityRevokerInfo) -> RustBuffer {
    return FfiConverterTypeAnonymityRevokerInfo.lower(value)
}

/**
 * The data relating to a single anonymity revoker
 * sent by the account holder to the identity provider.
 * Typically the account holder will send a vector of these.
 */
public struct ArData {
    /**
     * Encryption in chunks (in little endian) of the PRF key share.
     */
    public var encPrfKeyShareHex: String
    /**
     * Response in the proof that the computed commitment to the share
     * contains the same value as the encryption.
     * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
     */
    public var proofComEncEqHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Encryption in chunks (in little endian) of the PRF key share.
         */
        encPrfKeyShareHex: String,
        /**
            * Response in the proof that the computed commitment to the share
            * contains the same value as the encryption.
            * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
            */
        proofComEncEqHex: String
    ) {
        self.encPrfKeyShareHex = encPrfKeyShareHex
        self.proofComEncEqHex = proofComEncEqHex
    }
}

extension ArData: Equatable, Hashable {
    public static func == (lhs: ArData, rhs: ArData) -> Bool {
        if lhs.encPrfKeyShareHex != rhs.encPrfKeyShareHex {
            return false
        }
        if lhs.proofComEncEqHex != rhs.proofComEncEqHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encPrfKeyShareHex)
        hasher.combine(proofComEncEqHex)
    }
}

public struct FfiConverterTypeArData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArData {
        return
            try ArData(
                encPrfKeyShareHex: FfiConverterString.read(from: &buf),
                proofComEncEqHex: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: ArData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.encPrfKeyShareHex, into: &buf)
        FfiConverterString.write(value.proofComEncEqHex, into: &buf)
    }
}

public func FfiConverterTypeArData_lift(_ buf: RustBuffer) throws -> ArData {
    return try FfiConverterTypeArData.lift(buf)
}

public func FfiConverterTypeArData_lower(_ value: ArData) -> RustBuffer {
    return FfiConverterTypeArData.lower(value)
}

/**
 * An attribute list that is part of a normal credential.
 * It consists of some mandatory attributes and some user selected attributes.
 */
public struct AttributeList {
    /**
     * The latest month and year where the credential is still valid.
     */
    public var validToYearMonth: String
    /**
     * The year and month when the identity object from which the credential is derived was created.
     * This deliberately has low granularity since if it was, e.g., a unix timestamp in seconds,
     * then the identity provider could link accounts on the chain to identities they have issued.
     */
    public var createdAtYearMonth: String
    /**
     * Maximum number of accounts that can be created from the owning identity object.
     */
    public var maxAccounts: UInt8
    /**
     * The attributes map.
     */
    public var chosenAttributes: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The latest month and year where the credential is still valid.
         */
        validToYearMonth: String,
        /**
            * The year and month when the identity object from which the credential is derived was created.
            * This deliberately has low granularity since if it was, e.g., a unix timestamp in seconds,
            * then the identity provider could link accounts on the chain to identities they have issued.
            */
        createdAtYearMonth: String,
        /**
            * Maximum number of accounts that can be created from the owning identity object.
            */
        maxAccounts: UInt8,
        /**
            * The attributes map.
            */
        chosenAttributes: [String: String]
    ) {
        self.validToYearMonth = validToYearMonth
        self.createdAtYearMonth = createdAtYearMonth
        self.maxAccounts = maxAccounts
        self.chosenAttributes = chosenAttributes
    }
}

extension AttributeList: Equatable, Hashable {
    public static func == (lhs: AttributeList, rhs: AttributeList) -> Bool {
        if lhs.validToYearMonth != rhs.validToYearMonth {
            return false
        }
        if lhs.createdAtYearMonth != rhs.createdAtYearMonth {
            return false
        }
        if lhs.maxAccounts != rhs.maxAccounts {
            return false
        }
        if lhs.chosenAttributes != rhs.chosenAttributes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validToYearMonth)
        hasher.combine(createdAtYearMonth)
        hasher.combine(maxAccounts)
        hasher.combine(chosenAttributes)
    }
}

public struct FfiConverterTypeAttributeList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeList {
        return
            try AttributeList(
                validToYearMonth: FfiConverterString.read(from: &buf),
                createdAtYearMonth: FfiConverterString.read(from: &buf),
                maxAccounts: FfiConverterUInt8.read(from: &buf),
                chosenAttributes: FfiConverterDictionaryStringString.read(from: &buf)
            )
    }

    public static func write(_ value: AttributeList, into buf: inout [UInt8]) {
        FfiConverterString.write(value.validToYearMonth, into: &buf)
        FfiConverterString.write(value.createdAtYearMonth, into: &buf)
        FfiConverterUInt8.write(value.maxAccounts, into: &buf)
        FfiConverterDictionaryStringString.write(value.chosenAttributes, into: &buf)
    }
}

public func FfiConverterTypeAttributeList_lift(_ buf: RustBuffer) throws -> AttributeList {
    return try FfiConverterTypeAttributeList.lift(buf)
}

public func FfiConverterTypeAttributeList_lower(_ value: AttributeList) -> RustBuffer {
    return FfiConverterTypeAttributeList.lower(value)
}

/**
 * Data relating to a single anonymity revoker constructed by the account holder.
 * Typically a vector of these will be sent to the chain.
 */
public struct ChainArData {
    public var endIdCredPubShareHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        endIdCredPubShareHex: String)
    {
        self.endIdCredPubShareHex = endIdCredPubShareHex
    }
}

extension ChainArData: Equatable, Hashable {
    public static func == (lhs: ChainArData, rhs: ChainArData) -> Bool {
        if lhs.endIdCredPubShareHex != rhs.endIdCredPubShareHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(endIdCredPubShareHex)
    }
}

public struct FfiConverterTypeChainArData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainArData {
        return
            try ChainArData(
                endIdCredPubShareHex: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: ChainArData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.endIdCredPubShareHex, into: &buf)
    }
}

public func FfiConverterTypeChainArData_lift(_ buf: RustBuffer) throws -> ChainArData {
    return try FfiConverterTypeChainArData.lift(buf)
}

public func FfiConverterTypeChainArData_lower(_ value: ChainArData) -> RustBuffer {
    return FfiConverterTypeChainArData.lower(value)
}

/**
 * Choice of anonymity revocation parameters.
 */
public struct ChoiceArParameters {
    public var arIdentities: [UInt32]
    public var threshold: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        arIdentities: [UInt32],
        threshold: UInt32
    ) {
        self.arIdentities = arIdentities
        self.threshold = threshold
    }
}

extension ChoiceArParameters: Equatable, Hashable {
    public static func == (lhs: ChoiceArParameters, rhs: ChoiceArParameters) -> Bool {
        if lhs.arIdentities != rhs.arIdentities {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(arIdentities)
        hasher.combine(threshold)
    }
}

public struct FfiConverterTypeChoiceArParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChoiceArParameters {
        return
            try ChoiceArParameters(
                arIdentities: FfiConverterSequenceUInt32.read(from: &buf),
                threshold: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: ChoiceArParameters, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt32.write(value.arIdentities, into: &buf)
        FfiConverterUInt32.write(value.threshold, into: &buf)
    }
}

public func FfiConverterTypeChoiceArParameters_lift(_ buf: RustBuffer) throws -> ChoiceArParameters {
    return try FfiConverterTypeChoiceArParameters.lift(buf)
}

public func FfiConverterTypeChoiceArParameters_lower(_ value: ChoiceArParameters) -> RustBuffer {
    return FfiConverterTypeChoiceArParameters.lower(value)
}

/**
 * Public credential keys currently on the account.
 * The threshold determines the number of required signatures on a transaction for it to be valid.
 */
public struct CredentialPublicKeys {
    public var keys: [UInt8: VerifyKey]
    public var threshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        keys: [UInt8: VerifyKey],
        threshold: UInt8
    ) {
        self.keys = keys
        self.threshold = threshold
    }
}

extension CredentialPublicKeys: Equatable, Hashable {
    public static func == (lhs: CredentialPublicKeys, rhs: CredentialPublicKeys) -> Bool {
        if lhs.keys != rhs.keys {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keys)
        hasher.combine(threshold)
    }
}

public struct FfiConverterTypeCredentialPublicKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialPublicKeys {
        return
            try CredentialPublicKeys(
                keys: FfiConverterDictionaryUInt8TypeVerifyKey.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: CredentialPublicKeys, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt8TypeVerifyKey.write(value.keys, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
    }
}

public func FfiConverterTypeCredentialPublicKeys_lift(_ buf: RustBuffer) throws -> CredentialPublicKeys {
    return try FfiConverterTypeCredentialPublicKeys.lift(buf)
}

public func FfiConverterTypeCredentialPublicKeys_lower(_ value: CredentialPublicKeys) -> RustBuffer {
    return FfiConverterTypeCredentialPublicKeys.lower(value)
}

/**
 * Metadata of an identity provider or anonymity revoker
 * to be visible on the chain.
 */
public struct Description {
    public var name: String
    public var url: String
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        name: String,
        url: String,
        description: String
    ) {
        self.name = name
        self.url = url
        self.description = description
    }
}

extension Description: Equatable, Hashable {
    public static func == (lhs: Description, rhs: Description) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(url)
        hasher.combine(description)
    }
}

public struct FfiConverterTypeDescription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Description {
        return
            try Description(
                name: FfiConverterString.read(from: &buf),
                url: FfiConverterString.read(from: &buf),
                description: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: Description, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}

public func FfiConverterTypeDescription_lift(_ buf: RustBuffer) throws -> Description {
    return try FfiConverterTypeDescription.lift(buf)
}

public func FfiConverterTypeDescription_lower(_ value: Description) -> RustBuffer {
    return FfiConverterTypeDescription.lower(value)
}

/**
 * A set of cryptographic parameters that are particular to the chain and
 * shared by everybody that interacts with the chain.
 */
public struct GlobalContext {
    /**
     * Shared commitment key known to the chain and the account holder (i.e. it's public).
     * The account holder uses this commitment key to generate commitments to values in the attribute list.
     */
    public var onChainCommitmentKeyHex: String
    /**
     * Generators for the bulletproofs.
     */
    public var bulletproofGeneratorsHex: String
    /**
     * Free-form string used to distinguish between different chains even if they share other parameters.
     */
    public var genesisString: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Shared commitment key known to the chain and the account holder (i.e. it's public).
         * The account holder uses this commitment key to generate commitments to values in the attribute list.
         */
        onChainCommitmentKeyHex: String,
        /**
            * Generators for the bulletproofs.
            */
        bulletproofGeneratorsHex: String,
        /**
            * Free-form string used to distinguish between different chains even if they share other parameters.
            */
        genesisString: String
    ) {
        self.onChainCommitmentKeyHex = onChainCommitmentKeyHex
        self.bulletproofGeneratorsHex = bulletproofGeneratorsHex
        self.genesisString = genesisString
    }
}

extension GlobalContext: Equatable, Hashable {
    public static func == (lhs: GlobalContext, rhs: GlobalContext) -> Bool {
        if lhs.onChainCommitmentKeyHex != rhs.onChainCommitmentKeyHex {
            return false
        }
        if lhs.bulletproofGeneratorsHex != rhs.bulletproofGeneratorsHex {
            return false
        }
        if lhs.genesisString != rhs.genesisString {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(onChainCommitmentKeyHex)
        hasher.combine(bulletproofGeneratorsHex)
        hasher.combine(genesisString)
    }
}

public struct FfiConverterTypeGlobalContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalContext {
        return
            try GlobalContext(
                onChainCommitmentKeyHex: FfiConverterString.read(from: &buf),
                bulletproofGeneratorsHex: FfiConverterString.read(from: &buf),
                genesisString: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: GlobalContext, into buf: inout [UInt8]) {
        FfiConverterString.write(value.onChainCommitmentKeyHex, into: &buf)
        FfiConverterString.write(value.bulletproofGeneratorsHex, into: &buf)
        FfiConverterString.write(value.genesisString, into: &buf)
    }
}

public func FfiConverterTypeGlobalContext_lift(_ buf: RustBuffer) throws -> GlobalContext {
    return try FfiConverterTypeGlobalContext.lift(buf)
}

public func FfiConverterTypeGlobalContext_lower(_ value: GlobalContext) -> RustBuffer {
    return FfiConverterTypeGlobalContext.lower(value)
}

/**
 * Parameter object for `identity_issuance_request_json`.
 */
public struct IdentityIssuanceRequestParameters {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var arsInfos: [UInt32: AnonymityRevokerInfo]
    public var arThreshold: UInt8
    public var prfKeyHex: String
    public var idCredSecHex: String
    public var blindingRandomnessHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        ipInfo: IdentityProviderInfo,
        globalContext: GlobalContext,
        arsInfos: [UInt32: AnonymityRevokerInfo],
        arThreshold: UInt8,
        prfKeyHex: String,
        idCredSecHex: String,
        blindingRandomnessHex: String
    ) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.arsInfos = arsInfos
        self.arThreshold = arThreshold
        self.prfKeyHex = prfKeyHex
        self.idCredSecHex = idCredSecHex
        self.blindingRandomnessHex = blindingRandomnessHex
    }
}

extension IdentityIssuanceRequestParameters: Equatable, Hashable {
    public static func == (lhs: IdentityIssuanceRequestParameters, rhs: IdentityIssuanceRequestParameters) -> Bool {
        if lhs.ipInfo != rhs.ipInfo {
            return false
        }
        if lhs.globalContext != rhs.globalContext {
            return false
        }
        if lhs.arsInfos != rhs.arsInfos {
            return false
        }
        if lhs.arThreshold != rhs.arThreshold {
            return false
        }
        if lhs.prfKeyHex != rhs.prfKeyHex {
            return false
        }
        if lhs.idCredSecHex != rhs.idCredSecHex {
            return false
        }
        if lhs.blindingRandomnessHex != rhs.blindingRandomnessHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ipInfo)
        hasher.combine(globalContext)
        hasher.combine(arsInfos)
        hasher.combine(arThreshold)
        hasher.combine(prfKeyHex)
        hasher.combine(idCredSecHex)
        hasher.combine(blindingRandomnessHex)
    }
}

public struct FfiConverterTypeIdentityIssuanceRequestParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityIssuanceRequestParameters {
        return
            try IdentityIssuanceRequestParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf),
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf),
                arsInfos: FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.read(from: &buf),
                arThreshold: FfiConverterUInt8.read(from: &buf),
                prfKeyHex: FfiConverterString.read(from: &buf),
                idCredSecHex: FfiConverterString.read(from: &buf),
                blindingRandomnessHex: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityIssuanceRequestParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.write(value.arsInfos, into: &buf)
        FfiConverterUInt8.write(value.arThreshold, into: &buf)
        FfiConverterString.write(value.prfKeyHex, into: &buf)
        FfiConverterString.write(value.idCredSecHex, into: &buf)
        FfiConverterString.write(value.blindingRandomnessHex, into: &buf)
    }
}

public func FfiConverterTypeIdentityIssuanceRequestParameters_lift(_ buf: RustBuffer) throws -> IdentityIssuanceRequestParameters {
    return try FfiConverterTypeIdentityIssuanceRequestParameters.lift(buf)
}

public func FfiConverterTypeIdentityIssuanceRequestParameters_lower(_ value: IdentityIssuanceRequestParameters) -> RustBuffer {
    return FfiConverterTypeIdentityIssuanceRequestParameters.lower(value)
}

/**
 * The data we get back from the identity provider in the version 1 flow.
 */
public struct IdentityObject {
    public var preIdentityObject: PreIdentityObject
    /**
     * Chosen attribute list.
     */
    public var attributeList: AttributeList
    public var signatureHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        preIdentityObject: PreIdentityObject,
        /**
            * Chosen attribute list.
            */
        attributeList: AttributeList,
        signatureHex: String
    ) {
        self.preIdentityObject = preIdentityObject
        self.attributeList = attributeList
        self.signatureHex = signatureHex
    }
}

extension IdentityObject: Equatable, Hashable {
    public static func == (lhs: IdentityObject, rhs: IdentityObject) -> Bool {
        if lhs.preIdentityObject != rhs.preIdentityObject {
            return false
        }
        if lhs.attributeList != rhs.attributeList {
            return false
        }
        if lhs.signatureHex != rhs.signatureHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preIdentityObject)
        hasher.combine(attributeList)
        hasher.combine(signatureHex)
    }
}

public struct FfiConverterTypeIdentityObject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityObject {
        return
            try IdentityObject(
                preIdentityObject: FfiConverterTypePreIdentityObject.read(from: &buf),
                attributeList: FfiConverterTypeAttributeList.read(from: &buf),
                signatureHex: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityObject, into buf: inout [UInt8]) {
        FfiConverterTypePreIdentityObject.write(value.preIdentityObject, into: &buf)
        FfiConverterTypeAttributeList.write(value.attributeList, into: &buf)
        FfiConverterString.write(value.signatureHex, into: &buf)
    }
}

public func FfiConverterTypeIdentityObject_lift(_ buf: RustBuffer) throws -> IdentityObject {
    return try FfiConverterTypeIdentityObject.lift(buf)
}

public func FfiConverterTypeIdentityObject_lower(_ value: IdentityObject) -> RustBuffer {
    return FfiConverterTypeIdentityObject.lower(value)
}

/**
 * Public information about an identity provider.
 */
public struct IdentityProviderInfo {
    /**
     * Unique identifier of the identity provider.
     */
    public var identity: UInt32
    /**
     * Free form description, e.g., how to contact them off-chain.
     */
    public var description: Description
    /**
     * PS public key of the identity provider.
     */
    public var verifyKeyHex: String
    /**
     * Ed public key of the identity provider.
     */
    public var cdiVerifyKeyHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier of the identity provider.
         */
        identity: UInt32,
        /**
            * Free form description, e.g., how to contact them off-chain.
            */
        description: Description,
        /**
            * PS public key of the identity provider.
            */
        verifyKeyHex: String,
        /**
            * Ed public key of the identity provider.
            */
        cdiVerifyKeyHex: String
    ) {
        self.identity = identity
        self.description = description
        self.verifyKeyHex = verifyKeyHex
        self.cdiVerifyKeyHex = cdiVerifyKeyHex
    }
}

extension IdentityProviderInfo: Equatable, Hashable {
    public static func == (lhs: IdentityProviderInfo, rhs: IdentityProviderInfo) -> Bool {
        if lhs.identity != rhs.identity {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.verifyKeyHex != rhs.verifyKeyHex {
            return false
        }
        if lhs.cdiVerifyKeyHex != rhs.cdiVerifyKeyHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identity)
        hasher.combine(description)
        hasher.combine(verifyKeyHex)
        hasher.combine(cdiVerifyKeyHex)
    }
}

public struct FfiConverterTypeIdentityProviderInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityProviderInfo {
        return
            try IdentityProviderInfo(
                identity: FfiConverterUInt32.read(from: &buf),
                description: FfiConverterTypeDescription.read(from: &buf),
                verifyKeyHex: FfiConverterString.read(from: &buf),
                cdiVerifyKeyHex: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityProviderInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.identity, into: &buf)
        FfiConverterTypeDescription.write(value.description, into: &buf)
        FfiConverterString.write(value.verifyKeyHex, into: &buf)
        FfiConverterString.write(value.cdiVerifyKeyHex, into: &buf)
    }
}

public func FfiConverterTypeIdentityProviderInfo_lift(_ buf: RustBuffer) throws -> IdentityProviderInfo {
    return try FfiConverterTypeIdentityProviderInfo.lift(buf)
}

public func FfiConverterTypeIdentityProviderInfo_lower(_ value: IdentityProviderInfo) -> RustBuffer {
    return FfiConverterTypeIdentityProviderInfo.lower(value)
}

/**
 * Parameter object for `identity_recovery_request_json`.
 */
public struct IdentityRecoveryRequestParameters {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var timestamp: UInt64
    public var idCredSecHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        ipInfo: IdentityProviderInfo,
        globalContext: GlobalContext,
        timestamp: UInt64,
        idCredSecHex: String
    ) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.timestamp = timestamp
        self.idCredSecHex = idCredSecHex
    }
}

extension IdentityRecoveryRequestParameters: Equatable, Hashable {
    public static func == (lhs: IdentityRecoveryRequestParameters, rhs: IdentityRecoveryRequestParameters) -> Bool {
        if lhs.ipInfo != rhs.ipInfo {
            return false
        }
        if lhs.globalContext != rhs.globalContext {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.idCredSecHex != rhs.idCredSecHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ipInfo)
        hasher.combine(globalContext)
        hasher.combine(timestamp)
        hasher.combine(idCredSecHex)
    }
}

public struct FfiConverterTypeIdentityRecoveryRequestParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityRecoveryRequestParameters {
        return
            try IdentityRecoveryRequestParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf),
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf),
                timestamp: FfiConverterUInt64.read(from: &buf),
                idCredSecHex: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityRecoveryRequestParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterString.write(value.idCredSecHex, into: &buf)
    }
}

public func FfiConverterTypeIdentityRecoveryRequestParameters_lift(_ buf: RustBuffer) throws -> IdentityRecoveryRequestParameters {
    return try FfiConverterTypeIdentityRecoveryRequestParameters.lift(buf)
}

public func FfiConverterTypeIdentityRecoveryRequestParameters_lower(_ value: IdentityRecoveryRequestParameters) -> RustBuffer {
    return FfiConverterTypeIdentityRecoveryRequestParameters.lower(value)
}

/**
 * A policy is (currently) revealed values of attributes that are part of the identity object.
 * Policies are part of credentials.
 */
public struct Policy {
    public var createdAtYearMonth: String
    public var validToYearMonth: String
    public var revealedAttributes: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        createdAtYearMonth: String,
        validToYearMonth: String,
        revealedAttributes: [String: String]
    ) {
        self.createdAtYearMonth = createdAtYearMonth
        self.validToYearMonth = validToYearMonth
        self.revealedAttributes = revealedAttributes
    }
}

extension Policy: Equatable, Hashable {
    public static func == (lhs: Policy, rhs: Policy) -> Bool {
        if lhs.createdAtYearMonth != rhs.createdAtYearMonth {
            return false
        }
        if lhs.validToYearMonth != rhs.validToYearMonth {
            return false
        }
        if lhs.revealedAttributes != rhs.revealedAttributes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdAtYearMonth)
        hasher.combine(validToYearMonth)
        hasher.combine(revealedAttributes)
    }
}

public struct FfiConverterTypePolicy: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Policy {
        return
            try Policy(
                createdAtYearMonth: FfiConverterString.read(from: &buf),
                validToYearMonth: FfiConverterString.read(from: &buf),
                revealedAttributes: FfiConverterDictionaryStringString.read(from: &buf)
            )
    }

    public static func write(_ value: Policy, into buf: inout [UInt8]) {
        FfiConverterString.write(value.createdAtYearMonth, into: &buf)
        FfiConverterString.write(value.validToYearMonth, into: &buf)
        FfiConverterDictionaryStringString.write(value.revealedAttributes, into: &buf)
    }
}

public func FfiConverterTypePolicy_lift(_ buf: RustBuffer) throws -> Policy {
    return try FfiConverterTypePolicy.lift(buf)
}

public func FfiConverterTypePolicy_lower(_ value: Policy) -> RustBuffer {
    return FfiConverterTypePolicy.lower(value)
}

/**
 * Information sent from the account holder to the identity provider.
 * This includes only the cryptographic parts; the attribute list is in a different object below.
 * This is for the flow where no initial account is involved.
 */
public struct PreIdentityObject {
    public var idCredPubHex: String
    /**
     * Anonymity revocation data for the chosen anonymity revokers.
     */
    public var ipArData: [UInt32: ArData]
    /**
     * Choice of anonyimity revocation parameters.
     * Identity provider checks that the values make sense in the context of the public keys they are allowed to use.
     */
    public var choiceArData: ChoiceArParameters
    /**
     * Commitment to ID cred sec using the commitment key of the identity provider derived from the PS public key.
     * This is used to compute the message that the identity provider signs.
     */
    public var idCredSecCommitmentHex: String
    /**
     * Commitment to the PRF key in group G1.
     */
    public var prfKeyCommitmentWithIpHex: String
    /**
     * Commitments to the coefficients of the polynomial used to share the PRF key.
     */
    public var prfKeySharingCoeffCommitmentsHex: [String]
    /**
     * Proof that the data sent to the identity provider is well-formed.
     */
    public var proofsOfKnowledgeHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        idCredPubHex: String,
        /**
            * Anonymity revocation data for the chosen anonymity revokers.
            */
        ipArData: [UInt32: ArData],
        /**
            * Choice of anonyimity revocation parameters.
            * Identity provider checks that the values make sense in the context of the public keys they are allowed to use.
            */
        choiceArData: ChoiceArParameters,
        /**
            * Commitment to ID cred sec using the commitment key of the identity provider derived from the PS public key.
            * This is used to compute the message that the identity provider signs.
            */
        idCredSecCommitmentHex: String,
        /**
            * Commitment to the PRF key in group G1.
            */
        prfKeyCommitmentWithIpHex: String,
        /**
            * Commitments to the coefficients of the polynomial used to share the PRF key.
            */
        prfKeySharingCoeffCommitmentsHex: [String],
        /**
            * Proof that the data sent to the identity provider is well-formed.
            */
        proofsOfKnowledgeHex: String
    ) {
        self.idCredPubHex = idCredPubHex
        self.ipArData = ipArData
        self.choiceArData = choiceArData
        self.idCredSecCommitmentHex = idCredSecCommitmentHex
        self.prfKeyCommitmentWithIpHex = prfKeyCommitmentWithIpHex
        self.prfKeySharingCoeffCommitmentsHex = prfKeySharingCoeffCommitmentsHex
        self.proofsOfKnowledgeHex = proofsOfKnowledgeHex
    }
}

extension PreIdentityObject: Equatable, Hashable {
    public static func == (lhs: PreIdentityObject, rhs: PreIdentityObject) -> Bool {
        if lhs.idCredPubHex != rhs.idCredPubHex {
            return false
        }
        if lhs.ipArData != rhs.ipArData {
            return false
        }
        if lhs.choiceArData != rhs.choiceArData {
            return false
        }
        if lhs.idCredSecCommitmentHex != rhs.idCredSecCommitmentHex {
            return false
        }
        if lhs.prfKeyCommitmentWithIpHex != rhs.prfKeyCommitmentWithIpHex {
            return false
        }
        if lhs.prfKeySharingCoeffCommitmentsHex != rhs.prfKeySharingCoeffCommitmentsHex {
            return false
        }
        if lhs.proofsOfKnowledgeHex != rhs.proofsOfKnowledgeHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(idCredPubHex)
        hasher.combine(ipArData)
        hasher.combine(choiceArData)
        hasher.combine(idCredSecCommitmentHex)
        hasher.combine(prfKeyCommitmentWithIpHex)
        hasher.combine(prfKeySharingCoeffCommitmentsHex)
        hasher.combine(proofsOfKnowledgeHex)
    }
}

public struct FfiConverterTypePreIdentityObject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreIdentityObject {
        return
            try PreIdentityObject(
                idCredPubHex: FfiConverterString.read(from: &buf),
                ipArData: FfiConverterDictionaryUInt32TypeArData.read(from: &buf),
                choiceArData: FfiConverterTypeChoiceArParameters.read(from: &buf),
                idCredSecCommitmentHex: FfiConverterString.read(from: &buf),
                prfKeyCommitmentWithIpHex: FfiConverterString.read(from: &buf),
                prfKeySharingCoeffCommitmentsHex: FfiConverterSequenceString.read(from: &buf),
                proofsOfKnowledgeHex: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PreIdentityObject, into buf: inout [UInt8]) {
        FfiConverterString.write(value.idCredPubHex, into: &buf)
        FfiConverterDictionaryUInt32TypeArData.write(value.ipArData, into: &buf)
        FfiConverterTypeChoiceArParameters.write(value.choiceArData, into: &buf)
        FfiConverterString.write(value.idCredSecCommitmentHex, into: &buf)
        FfiConverterString.write(value.prfKeyCommitmentWithIpHex, into: &buf)
        FfiConverterSequenceString.write(value.prfKeySharingCoeffCommitmentsHex, into: &buf)
        FfiConverterString.write(value.proofsOfKnowledgeHex, into: &buf)
    }
}

public func FfiConverterTypePreIdentityObject_lift(_ buf: RustBuffer) throws -> PreIdentityObject {
    return try FfiConverterTypePreIdentityObject.lift(buf)
}

public func FfiConverterTypePreIdentityObject_lower(_ value: PreIdentityObject) -> RustBuffer {
    return FfiConverterTypePreIdentityObject.lower(value)
}

/**
 * All proofs required to prove ownership of an identity in a credential deployment.
 */
public struct Proofs {
    /**
     * Challenge used for all of the proofs.
     */
    public var challengeHex: String
    /**
     * List of commitments to the attributes.
     */
    public var commitmentsHex: String
    /**
     * Proof that credential counter is at most equal to the maximum allowed number of account.
     */
    public var credCounterLessThanMaxAccountsHex: String
    /**
     * Responses in the proof that the computed commitment to the share
     * contains the same value as the encryption.
     * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
     */
    public var proofIdCredPubHex: [String: String]
    /**
     * Responses in the proof of knowledge of signature of the identity provider.
     */
    public var proofIpSigHex: String
    /**
     * Proof that registration ID is valid and computed from the PRF key signed by the identity provider.
     */
    public var proofRegIdHex: String
    /**
     * (Blinded) signature derived from the signature on the pre-identity object by the identity provider.
     */
    public var signatureHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Challenge used for all of the proofs.
         */
        challengeHex: String,
        /**
            * List of commitments to the attributes.
            */
        commitmentsHex: String,
        /**
            * Proof that credential counter is at most equal to the maximum allowed number of account.
            */
        credCounterLessThanMaxAccountsHex: String,
        /**
            * Responses in the proof that the computed commitment to the share
            * contains the same value as the encryption.
            * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
            */
        proofIdCredPubHex: [String: String],
        /**
            * Responses in the proof of knowledge of signature of the identity provider.
            */
        proofIpSigHex: String,
        /**
            * Proof that registration ID is valid and computed from the PRF key signed by the identity provider.
            */
        proofRegIdHex: String,
        /**
            * (Blinded) signature derived from the signature on the pre-identity object by the identity provider.
            */
        signatureHex: String
    ) {
        self.challengeHex = challengeHex
        self.commitmentsHex = commitmentsHex
        self.credCounterLessThanMaxAccountsHex = credCounterLessThanMaxAccountsHex
        self.proofIdCredPubHex = proofIdCredPubHex
        self.proofIpSigHex = proofIpSigHex
        self.proofRegIdHex = proofRegIdHex
        self.signatureHex = signatureHex
    }
}

extension Proofs: Equatable, Hashable {
    public static func == (lhs: Proofs, rhs: Proofs) -> Bool {
        if lhs.challengeHex != rhs.challengeHex {
            return false
        }
        if lhs.commitmentsHex != rhs.commitmentsHex {
            return false
        }
        if lhs.credCounterLessThanMaxAccountsHex != rhs.credCounterLessThanMaxAccountsHex {
            return false
        }
        if lhs.proofIdCredPubHex != rhs.proofIdCredPubHex {
            return false
        }
        if lhs.proofIpSigHex != rhs.proofIpSigHex {
            return false
        }
        if lhs.proofRegIdHex != rhs.proofRegIdHex {
            return false
        }
        if lhs.signatureHex != rhs.signatureHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challengeHex)
        hasher.combine(commitmentsHex)
        hasher.combine(credCounterLessThanMaxAccountsHex)
        hasher.combine(proofIdCredPubHex)
        hasher.combine(proofIpSigHex)
        hasher.combine(proofRegIdHex)
        hasher.combine(signatureHex)
    }
}

public struct FfiConverterTypeProofs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Proofs {
        return
            try Proofs(
                challengeHex: FfiConverterString.read(from: &buf),
                commitmentsHex: FfiConverterString.read(from: &buf),
                credCounterLessThanMaxAccountsHex: FfiConverterString.read(from: &buf),
                proofIdCredPubHex: FfiConverterDictionaryStringString.read(from: &buf),
                proofIpSigHex: FfiConverterString.read(from: &buf),
                proofRegIdHex: FfiConverterString.read(from: &buf),
                signatureHex: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: Proofs, into buf: inout [UInt8]) {
        FfiConverterString.write(value.challengeHex, into: &buf)
        FfiConverterString.write(value.commitmentsHex, into: &buf)
        FfiConverterString.write(value.credCounterLessThanMaxAccountsHex, into: &buf)
        FfiConverterDictionaryStringString.write(value.proofIdCredPubHex, into: &buf)
        FfiConverterString.write(value.proofIpSigHex, into: &buf)
        FfiConverterString.write(value.proofRegIdHex, into: &buf)
        FfiConverterString.write(value.signatureHex, into: &buf)
    }
}

public func FfiConverterTypeProofs_lift(_ buf: RustBuffer) throws -> Proofs {
    return try FfiConverterTypeProofs.lift(buf)
}

public func FfiConverterTypeProofs_lower(_ value: Proofs) -> RustBuffer {
    return FfiConverterTypeProofs.lower(value)
}

/**
 * Randomness that is generated to commit to attributes when creating a credential.
 * This randomness is needed to do something with those commitments later,
 * for example reveal the committed value or prove a property of the value.
 */
public struct Randomness {
    /**
     * Randomness used to commit to any user-chosen attributes, such as country of nationality.
     */
    public var attributesRandHex: [String: String]
    /**
     * Randomness of the commitment to the credential nonce.
     * This nonce is the number that is used to ensure that only a limited number of credentials
     * can be created from a given identity object.
     */
    public var credCounterRandHex: String
    /**
     * Randomness of the commitment to idCredSec.
     */
    public var idCredSecRandHex: String
    /**
     * Randomness of the commitment to the maximum number of accounts that may be created from the identity object.
     */
    public var maxAccountsRandHex: String
    /**
     * Randomness of the commitment to the PRF key.
     */
    public var prfRandHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Randomness used to commit to any user-chosen attributes, such as country of nationality.
         */
        attributesRandHex: [String: String],
        /**
            * Randomness of the commitment to the credential nonce.
            * This nonce is the number that is used to ensure that only a limited number of credentials
            * can be created from a given identity object.
            */
        credCounterRandHex: String,
        /**
            * Randomness of the commitment to idCredSec.
            */
        idCredSecRandHex: String,
        /**
            * Randomness of the commitment to the maximum number of accounts that may be created from the identity object.
            */
        maxAccountsRandHex: String,
        /**
            * Randomness of the commitment to the PRF key.
            */
        prfRandHex: String
    ) {
        self.attributesRandHex = attributesRandHex
        self.credCounterRandHex = credCounterRandHex
        self.idCredSecRandHex = idCredSecRandHex
        self.maxAccountsRandHex = maxAccountsRandHex
        self.prfRandHex = prfRandHex
    }
}

extension Randomness: Equatable, Hashable {
    public static func == (lhs: Randomness, rhs: Randomness) -> Bool {
        if lhs.attributesRandHex != rhs.attributesRandHex {
            return false
        }
        if lhs.credCounterRandHex != rhs.credCounterRandHex {
            return false
        }
        if lhs.idCredSecRandHex != rhs.idCredSecRandHex {
            return false
        }
        if lhs.maxAccountsRandHex != rhs.maxAccountsRandHex {
            return false
        }
        if lhs.prfRandHex != rhs.prfRandHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributesRandHex)
        hasher.combine(credCounterRandHex)
        hasher.combine(idCredSecRandHex)
        hasher.combine(maxAccountsRandHex)
        hasher.combine(prfRandHex)
    }
}

public struct FfiConverterTypeRandomness: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Randomness {
        return
            try Randomness(
                attributesRandHex: FfiConverterDictionaryStringString.read(from: &buf),
                credCounterRandHex: FfiConverterString.read(from: &buf),
                idCredSecRandHex: FfiConverterString.read(from: &buf),
                maxAccountsRandHex: FfiConverterString.read(from: &buf),
                prfRandHex: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: Randomness, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringString.write(value.attributesRandHex, into: &buf)
        FfiConverterString.write(value.credCounterRandHex, into: &buf)
        FfiConverterString.write(value.idCredSecRandHex, into: &buf)
        FfiConverterString.write(value.maxAccountsRandHex, into: &buf)
        FfiConverterString.write(value.prfRandHex, into: &buf)
    }
}

public func FfiConverterTypeRandomness_lift(_ buf: RustBuffer) throws -> Randomness {
    return try FfiConverterTypeRandomness.lift(buf)
}

public func FfiConverterTypeRandomness_lower(_ value: Randomness) -> RustBuffer {
    return FfiConverterTypeRandomness.lower(value)
}

/**
 * The credential deployment context required to serialize a credential deployment for submission to the chain.
 */
public struct SignedAccountCredential {
    public var credential: AccountCredential
    public var signaturesHex: [UInt8: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        credential: AccountCredential,
        signaturesHex: [UInt8: String]
    ) {
        self.credential = credential
        self.signaturesHex = signaturesHex
    }
}

extension SignedAccountCredential: Equatable, Hashable {
    public static func == (lhs: SignedAccountCredential, rhs: SignedAccountCredential) -> Bool {
        if lhs.credential != rhs.credential {
            return false
        }
        if lhs.signaturesHex != rhs.signaturesHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(credential)
        hasher.combine(signaturesHex)
    }
}

public struct FfiConverterTypeSignedAccountCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedAccountCredential {
        return
            try SignedAccountCredential(
                credential: FfiConverterTypeAccountCredential.read(from: &buf),
                signaturesHex: FfiConverterDictionaryUInt8String.read(from: &buf)
            )
    }

    public static func write(_ value: SignedAccountCredential, into buf: inout [UInt8]) {
        FfiConverterTypeAccountCredential.write(value.credential, into: &buf)
        FfiConverterDictionaryUInt8String.write(value.signaturesHex, into: &buf)
    }
}

public func FfiConverterTypeSignedAccountCredential_lift(_ buf: RustBuffer) throws -> SignedAccountCredential {
    return try FfiConverterTypeSignedAccountCredential.lift(buf)
}

public func FfiConverterTypeSignedAccountCredential_lower(_ value: SignedAccountCredential) -> RustBuffer {
    return FfiConverterTypeSignedAccountCredential.lower(value)
}

/**
 * Public AKA verification key for a given scheme.
 * Currently the only supported value of `scheme_id` is "Ed25519".
 */
public struct VerifyKey {
    public var schemeId: String
    public var keyHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        schemeId: String,
        keyHex: String
    ) {
        self.schemeId = schemeId
        self.keyHex = keyHex
    }
}

extension VerifyKey: Equatable, Hashable {
    public static func == (lhs: VerifyKey, rhs: VerifyKey) -> Bool {
        if lhs.schemeId != rhs.schemeId {
            return false
        }
        if lhs.keyHex != rhs.keyHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(schemeId)
        hasher.combine(keyHex)
    }
}

public struct FfiConverterTypeVerifyKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifyKey {
        return
            try VerifyKey(
                schemeId: FfiConverterString.read(from: &buf),
                keyHex: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: VerifyKey, into buf: inout [UInt8]) {
        FfiConverterString.write(value.schemeId, into: &buf)
        FfiConverterString.write(value.keyHex, into: &buf)
    }
}

public func FfiConverterTypeVerifyKey_lift(_ buf: RustBuffer) throws -> VerifyKey {
    return try FfiConverterTypeVerifyKey.lift(buf)
}

public func FfiConverterTypeVerifyKey_lower(_ value: VerifyKey) -> RustBuffer {
    return FfiConverterTypeVerifyKey.lower(value)
}

public enum ConcordiumWalletCryptoError {
    case CallFailed(message: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeConcordiumWalletCryptoError.lift(error)
    }
}

public struct FfiConverterTypeConcordiumWalletCryptoError: FfiConverterRustBuffer {
    typealias SwiftType = ConcordiumWalletCryptoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConcordiumWalletCryptoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .CallFailed(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConcordiumWalletCryptoError, into buf: inout [UInt8]) {
        switch value {
        case .CallFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        }
    }
}

extension ConcordiumWalletCryptoError: Equatable, Hashable {}

extension ConcordiumWalletCryptoError: Error {}

private struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryUInt8String: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryUInt8TypeVerifyKey: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: VerifyKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterTypeVerifyKey.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: VerifyKey] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: VerifyKey]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterTypeVerifyKey.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: AnonymityRevokerInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeAnonymityRevokerInfo.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: AnonymityRevokerInfo] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: AnonymityRevokerInfo]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeAnonymityRevokerInfo.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryUInt32TypeArData: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: ArData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeArData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: ArData] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: ArData]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeArData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryUInt32TypeChainArData: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: ChainArData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeChainArData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: ChainArData] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: ChainArData]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeChainArData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

/**
 * Construct an account credential from the information contained in the provided parameters.
 */
public func accountCredential(params: AccountCredentialParameters) throws -> AccountCredentialResult {
    return try FfiConverterTypeAccountCredentialResult.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential(
                FfiConverterTypeAccountCredentialParameters.lower(params), $0
            )
        }
    )
}

/**
 * Compute the attribute commitment randomness for the provided seed, identity indexes, credential counter, and attribute number.
 * Supported values for `network`: "Testnet", "Mainnet".
 * The result is hex encoded.
 */
public func accountCredentialAttributeCommitmentRandomnessHex(seedHex: String, network: String, identityProviderIndex: UInt32, identityIndex: UInt32, credentialCounter: UInt8, attribute: UInt8) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_attribute_commitment_randomness_hex(
                FfiConverterString.lower(seedHex),
                FfiConverterString.lower(network),
                FfiConverterUInt32.lower(identityProviderIndex),
                FfiConverterUInt32.lower(identityIndex),
                FfiConverterUInt8.lower(credentialCounter),
                FfiConverterUInt8.lower(attribute), $0
            )
        }
    )
}

/**
 * Compute the hash of a new credential deployment to be signed by the account key derived for the credential.
 * The result is hex encoded.
 */
public func accountCredentialDeploymentHashHex(credential: AccountCredential, expiryUnixSecs: UInt64) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_deployment_hash_hex(
                FfiConverterTypeAccountCredential.lower(credential),
                FfiConverterUInt64.lower(expiryUnixSecs), $0
            )
        }
    )
}

/**
 * Serializes the credential deployment payload for submission as a "raw" payload to a node.
 * The result is hex encoded.
 */
public func accountCredentialDeploymentSignedPayloadHex(credential: SignedAccountCredential) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_deployment_signed_payload_hex(
                FfiConverterTypeSignedAccountCredential.lower(credential), $0
            )
        }
    )
}

/**
 * Compute the credential ID for the provided seed, identity indexes, credential counter, and the chain's commitment key.
 * Supported values for `network`: "Testnet", "Mainnet".
 * The result is hex encoded.
 */
public func accountCredentialIdHex(seedHex: String, network: String, identityProviderIndex: UInt32, identityIndex: UInt32, credentialCounter: UInt8, commitmentKey: String) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_id_hex(
                FfiConverterString.lower(seedHex),
                FfiConverterString.lower(network),
                FfiConverterUInt32.lower(identityProviderIndex),
                FfiConverterUInt32.lower(identityIndex),
                FfiConverterUInt8.lower(credentialCounter),
                FfiConverterString.lower(commitmentKey), $0
            )
        }
    )
}

/**
 * Compute the account credential public key for the provided seed, identity indexes, and credential counter.
 * Supported values for `network`: "Testnet", "Mainnet".
 * The result is hex encoded.
 */
public func accountCredentialPublicKeyHex(seedHex: String, network: String, identityProviderIndex: UInt32, identityIndex: UInt32, credentialCounter: UInt8) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_public_key_hex(
                FfiConverterString.lower(seedHex),
                FfiConverterString.lower(network),
                FfiConverterUInt32.lower(identityProviderIndex),
                FfiConverterUInt32.lower(identityIndex),
                FfiConverterUInt8.lower(credentialCounter), $0
            )
        }
    )
}

/**
 * Compute the account credential signing key for the provided seed, identity indexes, and credential counter.
 * Supported values for `network`: "Testnet", "Mainnet".
 * The result is hex encoded.
 */
public func accountCredentialSigningKeyHex(seedHex: String, network: String, identityProviderIndex: UInt32, identityIndex: UInt32, credentialCounter: UInt8) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_signing_key_hex(
                FfiConverterString.lower(seedHex),
                FfiConverterString.lower(network),
                FfiConverterUInt32.lower(identityProviderIndex),
                FfiConverterUInt32.lower(identityIndex),
                FfiConverterUInt8.lower(credentialCounter), $0
            )
        }
    )
}

/**
 * Compute the signature blinding randomness for the provided seed and identity indexes.
 * Supported values for `network`: "Testnet", "Mainnet".
 * The result is hex encoded.
 */
public func identityAttributesSignatureBlindingRandomnessHex(seedHex: String, network: String, identityProviderIndex: UInt32, identityIndex: UInt32) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_attributes_signature_blinding_randomness_hex(
                FfiConverterString.lower(seedHex),
                FfiConverterString.lower(network),
                FfiConverterUInt32.lower(identityProviderIndex),
                FfiConverterUInt32.lower(identityIndex), $0
            )
        }
    )
}

/**
 * Compute the IdCredSec for the provided seed and identity indexes.
 * Supported values for `network`: "Testnet", "Mainnet".
 * The result is hex encoded.
 */
public func identityCredSecHex(seedHex: String, network: String, identityProviderIndex: UInt32, identityIndex: UInt32) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_cred_sec_hex(
                FfiConverterString.lower(seedHex),
                FfiConverterString.lower(network),
                FfiConverterUInt32.lower(identityProviderIndex),
                FfiConverterUInt32.lower(identityIndex), $0
            )
        }
    )
}

/**
 * Compute an identity issuance request for the identity contained in the provided parameters.
 * The result is a versioned `PreIdentityObject` encoded as JSON,
 * which is the format expected by the identity provider's issuance endpoint.
 */
public func identityIssuanceRequestJson(params: IdentityIssuanceRequestParameters) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_issuance_request_json(
                FfiConverterTypeIdentityIssuanceRequestParameters.lower(params), $0
            )
        }
    )
}

/**
 * Compute the PRF-key for the provided seed and identity indexes.
 * Supported values for `network`: "Testnet", "Mainnet".
 * The result is hex encoded.
 */
public func identityPrfKeyHex(seedHex: String, network: String, identityProviderIndex: UInt32, identityIndex: UInt32) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_prf_key_hex(
                FfiConverterString.lower(seedHex),
                FfiConverterString.lower(network),
                FfiConverterUInt32.lower(identityProviderIndex),
                FfiConverterUInt32.lower(identityIndex), $0
            )
        }
    )
}

/**
 * Construct an identity recovery request for the identity contained in the provided parameters.
 * The result encoded as JSON in the format expected by the identity provider's recovery endpoint.
 */
public func identityRecoveryRequestJson(params: IdentityRecoveryRequestParameters) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_recovery_request_json(
                FfiConverterTypeIdentityRecoveryRequestParameters.lower(params), $0
            )
        }
    )
}

/**
 * Compute the encoded verifiable credential backup encryption key for the provided seed.
 * Supported values for `network`: "Testnet", "Mainnet".
 * The result is hex encoded.
 */
public func verifiableCredentialBackupEncryptionKeyHex(seedHex: String, network: String) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_backup_encryption_key_hex(
                FfiConverterString.lower(seedHex),
                FfiConverterString.lower(network), $0
            )
        }
    )
}

/**
 * Compute the public key for the provided seed, issuer indexes, and verifiable credential index.
 * Supported values for `network`: "Testnet", "Mainnet".
 * The result is hex encoded.
 */
public func verifiableCredentialPublicKeyHex(seedHex: String, network: String, issuerIndex: UInt64, issuerSubindex: UInt64, verifiableCredentialIndex: UInt32) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_public_key_hex(
                FfiConverterString.lower(seedHex),
                FfiConverterString.lower(network),
                FfiConverterUInt64.lower(issuerIndex),
                FfiConverterUInt64.lower(issuerSubindex),
                FfiConverterUInt32.lower(verifiableCredentialIndex), $0
            )
        }
    )
}

/**
 * Compute the signing key for the provided seed, issuer indexes, and verifiable credential index.
 * Supported values for `network`: "Testnet", "Mainnet".
 * The result is hex encoded.
 */
public func verifiableCredentialSigningKeyHex(seedHex: String, network: String, issuerIndex: UInt64, issuerSubindex: UInt64, verifiableCredentialIndex: UInt32) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
            uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_signing_key_hex(
                FfiConverterString.lower(seedHex),
                FfiConverterString.lower(network),
                FfiConverterUInt64.lower(issuerIndex),
                FfiConverterUInt64.lower(issuerSubindex),
                FfiConverterUInt32.lower(verifiableCredentialIndex), $0
            )
        }
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_concordium_wallet_crypto_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential() != 28347 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_attribute_commitment_randomness_hex() != 273 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_deployment_hash_hex() != 5211 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_deployment_signed_payload_hex() != 12194 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_id_hex() != 40956 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_public_key_hex() != 54614 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_signing_key_hex() != 2501 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_attributes_signature_blinding_randomness_hex() != 16381 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_cred_sec_hex() != 33924 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_issuance_request_json() != 28061 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_prf_key_hex() != 7705 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_recovery_request_json() != 33579 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_backup_encryption_key_hex() != 33639 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_public_key_hex() != 45224 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_signing_key_hex() != 34189 {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
