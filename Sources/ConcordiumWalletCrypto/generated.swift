// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(cryptoFFI)
import cryptoFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_concordium_wallet_crypto_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_concordium_wallet_crypto_uniffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}


/**
 * An account credential containing proofs without signatures.
 * To deploy a credential, an object of this type is
 * hashed using `account_credential_deployment_hash`
 * which is signed using the key derived for the credential.
 * The results are collected into a `SignedAccountCredential`
 * and serialized using `account_credential_deployment_signed_payload`.
 * The result of this call can be submitted to the chain.
 */
public struct AccountCredential {
    /**
     * List of anonymity revokers which can revoke the identity.
     * The order is important since it is the same order as that signed by the identity provider,
     * and permuting the list will invalidate the signature from the identity provider.
     */
    public var arData: [UInt32: ChainArData]
    /**
     * Credential registration ID of the credential.
     */
    public var credId: Bytes
    /**
     * Credential keys (i.e. account holder keys).
     */
    public var credentialPublicKeys: CredentialPublicKeys
    /**
     * Identity of the identity provider who signed the identity object
     * from which this credential is derived.
     */
    public var ipIdentity: UInt32
    /**
     * Policy of this credential object.
     */
    public var policy: Policy
    public var proofs: Proofs
    /**
     * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
     */
    public var revocationThreshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * List of anonymity revokers which can revoke the identity.
         * The order is important since it is the same order as that signed by the identity provider,
         * and permuting the list will invalidate the signature from the identity provider.
         */
        arData: [UInt32: ChainArData], 
        /**
         * Credential registration ID of the credential.
         */
        credId: Bytes, 
        /**
         * Credential keys (i.e. account holder keys).
         */
        credentialPublicKeys: CredentialPublicKeys, 
        /**
         * Identity of the identity provider who signed the identity object
         * from which this credential is derived.
         */
        ipIdentity: UInt32, 
        /**
         * Policy of this credential object.
         */
        policy: Policy, 
        proofs: Proofs, 
        /**
         * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
         */
        revocationThreshold: UInt8) {
        self.arData = arData
        self.credId = credId
        self.credentialPublicKeys = credentialPublicKeys
        self.ipIdentity = ipIdentity
        self.policy = policy
        self.proofs = proofs
        self.revocationThreshold = revocationThreshold
    }
}


extension AccountCredential: Equatable, Hashable {
    public static func ==(lhs: AccountCredential, rhs: AccountCredential) -> Bool {
        if lhs.arData != rhs.arData {
            return false
        }
        if lhs.credId != rhs.credId {
            return false
        }
        if lhs.credentialPublicKeys != rhs.credentialPublicKeys {
            return false
        }
        if lhs.ipIdentity != rhs.ipIdentity {
            return false
        }
        if lhs.policy != rhs.policy {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        if lhs.revocationThreshold != rhs.revocationThreshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(arData)
        hasher.combine(credId)
        hasher.combine(credentialPublicKeys)
        hasher.combine(ipIdentity)
        hasher.combine(policy)
        hasher.combine(proofs)
        hasher.combine(revocationThreshold)
    }
}


public struct FfiConverterTypeAccountCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredential {
        return
            try AccountCredential(
                arData: FfiConverterDictionaryUInt32TypeChainArData.read(from: &buf), 
                credId: FfiConverterTypeBytes.read(from: &buf), 
                credentialPublicKeys: FfiConverterTypeCredentialPublicKeys.read(from: &buf), 
                ipIdentity: FfiConverterUInt32.read(from: &buf), 
                policy: FfiConverterTypePolicy.read(from: &buf), 
                proofs: FfiConverterTypeProofs.read(from: &buf), 
                revocationThreshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: AccountCredential, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt32TypeChainArData.write(value.arData, into: &buf)
        FfiConverterTypeBytes.write(value.credId, into: &buf)
        FfiConverterTypeCredentialPublicKeys.write(value.credentialPublicKeys, into: &buf)
        FfiConverterUInt32.write(value.ipIdentity, into: &buf)
        FfiConverterTypePolicy.write(value.policy, into: &buf)
        FfiConverterTypeProofs.write(value.proofs, into: &buf)
        FfiConverterUInt8.write(value.revocationThreshold, into: &buf)
    }
}


public func FfiConverterTypeAccountCredential_lift(_ buf: RustBuffer) throws -> AccountCredential {
    return try FfiConverterTypeAccountCredential.lift(buf)
}

public func FfiConverterTypeAccountCredential_lower(_ value: AccountCredential) -> RustBuffer {
    return FfiConverterTypeAccountCredential.lower(value)
}


/**
 * Parameter object for `account_credential`.
 */
public struct AccountCredentialParameters {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var arsInfos: [UInt32: AnonymityRevokerInfo]
    public var idObject: IdentityObject
    public var revealedAttributes: [UInt8]
    public var credNumber: UInt8
    public var idCredSec: Bytes
    public var prfKey: Bytes
    public var blindingRandomness: Bytes
    public var attributeRandomness: [String: Bytes]
    public var credentialPublicKeys: CredentialPublicKeys

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        ipInfo: IdentityProviderInfo, 
        globalContext: GlobalContext, 
        arsInfos: [UInt32: AnonymityRevokerInfo], 
        idObject: IdentityObject, 
        revealedAttributes: [UInt8], 
        credNumber: UInt8, 
        idCredSec: Bytes, 
        prfKey: Bytes, 
        blindingRandomness: Bytes, 
        attributeRandomness: [String: Bytes], 
        credentialPublicKeys: CredentialPublicKeys) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.arsInfos = arsInfos
        self.idObject = idObject
        self.revealedAttributes = revealedAttributes
        self.credNumber = credNumber
        self.idCredSec = idCredSec
        self.prfKey = prfKey
        self.blindingRandomness = blindingRandomness
        self.attributeRandomness = attributeRandomness
        self.credentialPublicKeys = credentialPublicKeys
    }
}


extension AccountCredentialParameters: Equatable, Hashable {
    public static func ==(lhs: AccountCredentialParameters, rhs: AccountCredentialParameters) -> Bool {
        if lhs.ipInfo != rhs.ipInfo {
            return false
        }
        if lhs.globalContext != rhs.globalContext {
            return false
        }
        if lhs.arsInfos != rhs.arsInfos {
            return false
        }
        if lhs.idObject != rhs.idObject {
            return false
        }
        if lhs.revealedAttributes != rhs.revealedAttributes {
            return false
        }
        if lhs.credNumber != rhs.credNumber {
            return false
        }
        if lhs.idCredSec != rhs.idCredSec {
            return false
        }
        if lhs.prfKey != rhs.prfKey {
            return false
        }
        if lhs.blindingRandomness != rhs.blindingRandomness {
            return false
        }
        if lhs.attributeRandomness != rhs.attributeRandomness {
            return false
        }
        if lhs.credentialPublicKeys != rhs.credentialPublicKeys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ipInfo)
        hasher.combine(globalContext)
        hasher.combine(arsInfos)
        hasher.combine(idObject)
        hasher.combine(revealedAttributes)
        hasher.combine(credNumber)
        hasher.combine(idCredSec)
        hasher.combine(prfKey)
        hasher.combine(blindingRandomness)
        hasher.combine(attributeRandomness)
        hasher.combine(credentialPublicKeys)
    }
}


public struct FfiConverterTypeAccountCredentialParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredentialParameters {
        return
            try AccountCredentialParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf), 
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf), 
                arsInfos: FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.read(from: &buf), 
                idObject: FfiConverterTypeIdentityObject.read(from: &buf), 
                revealedAttributes: FfiConverterSequenceUInt8.read(from: &buf), 
                credNumber: FfiConverterUInt8.read(from: &buf), 
                idCredSec: FfiConverterTypeBytes.read(from: &buf), 
                prfKey: FfiConverterTypeBytes.read(from: &buf), 
                blindingRandomness: FfiConverterTypeBytes.read(from: &buf), 
                attributeRandomness: FfiConverterDictionaryStringTypeBytes.read(from: &buf), 
                credentialPublicKeys: FfiConverterTypeCredentialPublicKeys.read(from: &buf)
        )
    }

    public static func write(_ value: AccountCredentialParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.write(value.arsInfos, into: &buf)
        FfiConverterTypeIdentityObject.write(value.idObject, into: &buf)
        FfiConverterSequenceUInt8.write(value.revealedAttributes, into: &buf)
        FfiConverterUInt8.write(value.credNumber, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSec, into: &buf)
        FfiConverterTypeBytes.write(value.prfKey, into: &buf)
        FfiConverterTypeBytes.write(value.blindingRandomness, into: &buf)
        FfiConverterDictionaryStringTypeBytes.write(value.attributeRandomness, into: &buf)
        FfiConverterTypeCredentialPublicKeys.write(value.credentialPublicKeys, into: &buf)
    }
}


public func FfiConverterTypeAccountCredentialParameters_lift(_ buf: RustBuffer) throws -> AccountCredentialParameters {
    return try FfiConverterTypeAccountCredentialParameters.lift(buf)
}

public func FfiConverterTypeAccountCredentialParameters_lower(_ value: AccountCredentialParameters) -> RustBuffer {
    return FfiConverterTypeAccountCredentialParameters.lower(value)
}


/**
 * The result of a new credential being created using the function `account_credential`.
 */
public struct AccountCredentialResult {
    public var credential: AccountCredential
    public var randomness: Randomness

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        credential: AccountCredential, 
        randomness: Randomness) {
        self.credential = credential
        self.randomness = randomness
    }
}


extension AccountCredentialResult: Equatable, Hashable {
    public static func ==(lhs: AccountCredentialResult, rhs: AccountCredentialResult) -> Bool {
        if lhs.credential != rhs.credential {
            return false
        }
        if lhs.randomness != rhs.randomness {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(credential)
        hasher.combine(randomness)
    }
}


public struct FfiConverterTypeAccountCredentialResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredentialResult {
        return
            try AccountCredentialResult(
                credential: FfiConverterTypeAccountCredential.read(from: &buf), 
                randomness: FfiConverterTypeRandomness.read(from: &buf)
        )
    }

    public static func write(_ value: AccountCredentialResult, into buf: inout [UInt8]) {
        FfiConverterTypeAccountCredential.write(value.credential, into: &buf)
        FfiConverterTypeRandomness.write(value.randomness, into: &buf)
    }
}


public func FfiConverterTypeAccountCredentialResult_lift(_ buf: RustBuffer) throws -> AccountCredentialResult {
    return try FfiConverterTypeAccountCredentialResult.lift(buf)
}

public func FfiConverterTypeAccountCredentialResult_lower(_ value: AccountCredentialResult) -> RustBuffer {
    return FfiConverterTypeAccountCredentialResult.lower(value)
}


/**
 * Information on an anonymity revoker held by the identity provider.
 */
public struct AnonymityRevokerInfo {
    /**
     * Unique identifier of the anonymity revoker.
     */
    public var identity: UInt32
    /**
     * Description of the anonymity revoker (e.g. name, contact number).
     */
    public var description: Description
    /**
     * Elgamal encryption key of the anonymity revoker.
     */
    public var publicKey: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier of the anonymity revoker.
         */
        identity: UInt32, 
        /**
         * Description of the anonymity revoker (e.g. name, contact number).
         */
        description: Description, 
        /**
         * Elgamal encryption key of the anonymity revoker.
         */
        publicKey: Bytes) {
        self.identity = identity
        self.description = description
        self.publicKey = publicKey
    }
}


extension AnonymityRevokerInfo: Equatable, Hashable {
    public static func ==(lhs: AnonymityRevokerInfo, rhs: AnonymityRevokerInfo) -> Bool {
        if lhs.identity != rhs.identity {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identity)
        hasher.combine(description)
        hasher.combine(publicKey)
    }
}


public struct FfiConverterTypeAnonymityRevokerInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnonymityRevokerInfo {
        return
            try AnonymityRevokerInfo(
                identity: FfiConverterUInt32.read(from: &buf), 
                description: FfiConverterTypeDescription.read(from: &buf), 
                publicKey: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: AnonymityRevokerInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.identity, into: &buf)
        FfiConverterTypeDescription.write(value.description, into: &buf)
        FfiConverterTypeBytes.write(value.publicKey, into: &buf)
    }
}


public func FfiConverterTypeAnonymityRevokerInfo_lift(_ buf: RustBuffer) throws -> AnonymityRevokerInfo {
    return try FfiConverterTypeAnonymityRevokerInfo.lift(buf)
}

public func FfiConverterTypeAnonymityRevokerInfo_lower(_ value: AnonymityRevokerInfo) -> RustBuffer {
    return FfiConverterTypeAnonymityRevokerInfo.lower(value)
}


/**
 * The data relating to a single anonymity revoker
 * sent by the account holder to the identity provider.
 * Typically the account holder will send a vector of these.
 */
public struct ArData {
    /**
     * Encryption in chunks (in little endian) of the PRF key share.
     */
    public var encPrfKeyShare: Bytes
    /**
     * Response in the proof that the computed commitment to the share
     * contains the same value as the encryption.
     * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
     */
    public var proofComEncEq: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Encryption in chunks (in little endian) of the PRF key share.
         */
        encPrfKeyShare: Bytes, 
        /**
         * Response in the proof that the computed commitment to the share
         * contains the same value as the encryption.
         * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
         */
        proofComEncEq: Bytes) {
        self.encPrfKeyShare = encPrfKeyShare
        self.proofComEncEq = proofComEncEq
    }
}


extension ArData: Equatable, Hashable {
    public static func ==(lhs: ArData, rhs: ArData) -> Bool {
        if lhs.encPrfKeyShare != rhs.encPrfKeyShare {
            return false
        }
        if lhs.proofComEncEq != rhs.proofComEncEq {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encPrfKeyShare)
        hasher.combine(proofComEncEq)
    }
}


public struct FfiConverterTypeArData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArData {
        return
            try ArData(
                encPrfKeyShare: FfiConverterTypeBytes.read(from: &buf), 
                proofComEncEq: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: ArData, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.encPrfKeyShare, into: &buf)
        FfiConverterTypeBytes.write(value.proofComEncEq, into: &buf)
    }
}


public func FfiConverterTypeArData_lift(_ buf: RustBuffer) throws -> ArData {
    return try FfiConverterTypeArData.lift(buf)
}

public func FfiConverterTypeArData_lower(_ value: ArData) -> RustBuffer {
    return FfiConverterTypeArData.lower(value)
}


/**
 * An attribute list that is part of a normal credential.
 * It consists of some mandatory attributes and some user selected attributes.
 */
public struct AttributeList {
    /**
     * The latest month and year where the credential is still valid.
     */
    public var validToYearMonth: String
    /**
     * The year and month when the identity object from which the credential is derived was created.
     * This deliberately has low granularity since if it was, e.g., a unix timestamp in seconds,
     * then the identity provider could link accounts on the chain to identities they have issued.
     */
    public var createdAtYearMonth: String
    /**
     * Maximum number of accounts that can be created from the owning identity object.
     */
    public var maxAccounts: UInt8
    /**
     * The attributes map.
     */
    public var chosenAttributes: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The latest month and year where the credential is still valid.
         */
        validToYearMonth: String, 
        /**
         * The year and month when the identity object from which the credential is derived was created.
         * This deliberately has low granularity since if it was, e.g., a unix timestamp in seconds,
         * then the identity provider could link accounts on the chain to identities they have issued.
         */
        createdAtYearMonth: String, 
        /**
         * Maximum number of accounts that can be created from the owning identity object.
         */
        maxAccounts: UInt8, 
        /**
         * The attributes map.
         */
        chosenAttributes: [String: String]) {
        self.validToYearMonth = validToYearMonth
        self.createdAtYearMonth = createdAtYearMonth
        self.maxAccounts = maxAccounts
        self.chosenAttributes = chosenAttributes
    }
}


extension AttributeList: Equatable, Hashable {
    public static func ==(lhs: AttributeList, rhs: AttributeList) -> Bool {
        if lhs.validToYearMonth != rhs.validToYearMonth {
            return false
        }
        if lhs.createdAtYearMonth != rhs.createdAtYearMonth {
            return false
        }
        if lhs.maxAccounts != rhs.maxAccounts {
            return false
        }
        if lhs.chosenAttributes != rhs.chosenAttributes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validToYearMonth)
        hasher.combine(createdAtYearMonth)
        hasher.combine(maxAccounts)
        hasher.combine(chosenAttributes)
    }
}


public struct FfiConverterTypeAttributeList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeList {
        return
            try AttributeList(
                validToYearMonth: FfiConverterString.read(from: &buf), 
                createdAtYearMonth: FfiConverterString.read(from: &buf), 
                maxAccounts: FfiConverterUInt8.read(from: &buf), 
                chosenAttributes: FfiConverterDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeList, into buf: inout [UInt8]) {
        FfiConverterString.write(value.validToYearMonth, into: &buf)
        FfiConverterString.write(value.createdAtYearMonth, into: &buf)
        FfiConverterUInt8.write(value.maxAccounts, into: &buf)
        FfiConverterDictionaryStringString.write(value.chosenAttributes, into: &buf)
    }
}


public func FfiConverterTypeAttributeList_lift(_ buf: RustBuffer) throws -> AttributeList {
    return try FfiConverterTypeAttributeList.lift(buf)
}

public func FfiConverterTypeAttributeList_lower(_ value: AttributeList) -> RustBuffer {
    return FfiConverterTypeAttributeList.lower(value)
}


public struct BakerKeyPairs {
    public var signatureSign: Bytes
    public var signatureVerify: Bytes
    public var electionSign: Bytes
    public var electionVerify: Bytes
    public var aggregationSign: Bytes
    public var aggregationVerify: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        signatureSign: Bytes, 
        signatureVerify: Bytes, 
        electionSign: Bytes, 
        electionVerify: Bytes, 
        aggregationSign: Bytes, 
        aggregationVerify: Bytes) {
        self.signatureSign = signatureSign
        self.signatureVerify = signatureVerify
        self.electionSign = electionSign
        self.electionVerify = electionVerify
        self.aggregationSign = aggregationSign
        self.aggregationVerify = aggregationVerify
    }
}


extension BakerKeyPairs: Equatable, Hashable {
    public static func ==(lhs: BakerKeyPairs, rhs: BakerKeyPairs) -> Bool {
        if lhs.signatureSign != rhs.signatureSign {
            return false
        }
        if lhs.signatureVerify != rhs.signatureVerify {
            return false
        }
        if lhs.electionSign != rhs.electionSign {
            return false
        }
        if lhs.electionVerify != rhs.electionVerify {
            return false
        }
        if lhs.aggregationSign != rhs.aggregationSign {
            return false
        }
        if lhs.aggregationVerify != rhs.aggregationVerify {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signatureSign)
        hasher.combine(signatureVerify)
        hasher.combine(electionSign)
        hasher.combine(electionVerify)
        hasher.combine(aggregationSign)
        hasher.combine(aggregationVerify)
    }
}


public struct FfiConverterTypeBakerKeyPairs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BakerKeyPairs {
        return
            try BakerKeyPairs(
                signatureSign: FfiConverterTypeBytes.read(from: &buf), 
                signatureVerify: FfiConverterTypeBytes.read(from: &buf), 
                electionSign: FfiConverterTypeBytes.read(from: &buf), 
                electionVerify: FfiConverterTypeBytes.read(from: &buf), 
                aggregationSign: FfiConverterTypeBytes.read(from: &buf), 
                aggregationVerify: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: BakerKeyPairs, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.signatureSign, into: &buf)
        FfiConverterTypeBytes.write(value.signatureVerify, into: &buf)
        FfiConverterTypeBytes.write(value.electionSign, into: &buf)
        FfiConverterTypeBytes.write(value.electionVerify, into: &buf)
        FfiConverterTypeBytes.write(value.aggregationSign, into: &buf)
        FfiConverterTypeBytes.write(value.aggregationVerify, into: &buf)
    }
}


public func FfiConverterTypeBakerKeyPairs_lift(_ buf: RustBuffer) throws -> BakerKeyPairs {
    return try FfiConverterTypeBakerKeyPairs.lift(buf)
}

public func FfiConverterTypeBakerKeyPairs_lower(_ value: BakerKeyPairs) -> RustBuffer {
    return FfiConverterTypeBakerKeyPairs.lower(value)
}


public struct BakerKeysPayload {
    public var signatureVerifyKey: Bytes
    public var electionVerifyKey: Bytes
    public var aggregationVerifyKey: Bytes
    public var proofSig: Bytes
    public var proofElection: Bytes
    public var proofAggregation: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        signatureVerifyKey: Bytes, 
        electionVerifyKey: Bytes, 
        aggregationVerifyKey: Bytes, 
        proofSig: Bytes, 
        proofElection: Bytes, 
        proofAggregation: Bytes) {
        self.signatureVerifyKey = signatureVerifyKey
        self.electionVerifyKey = electionVerifyKey
        self.aggregationVerifyKey = aggregationVerifyKey
        self.proofSig = proofSig
        self.proofElection = proofElection
        self.proofAggregation = proofAggregation
    }
}


extension BakerKeysPayload: Equatable, Hashable {
    public static func ==(lhs: BakerKeysPayload, rhs: BakerKeysPayload) -> Bool {
        if lhs.signatureVerifyKey != rhs.signatureVerifyKey {
            return false
        }
        if lhs.electionVerifyKey != rhs.electionVerifyKey {
            return false
        }
        if lhs.aggregationVerifyKey != rhs.aggregationVerifyKey {
            return false
        }
        if lhs.proofSig != rhs.proofSig {
            return false
        }
        if lhs.proofElection != rhs.proofElection {
            return false
        }
        if lhs.proofAggregation != rhs.proofAggregation {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signatureVerifyKey)
        hasher.combine(electionVerifyKey)
        hasher.combine(aggregationVerifyKey)
        hasher.combine(proofSig)
        hasher.combine(proofElection)
        hasher.combine(proofAggregation)
    }
}


public struct FfiConverterTypeBakerKeysPayload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BakerKeysPayload {
        return
            try BakerKeysPayload(
                signatureVerifyKey: FfiConverterTypeBytes.read(from: &buf), 
                electionVerifyKey: FfiConverterTypeBytes.read(from: &buf), 
                aggregationVerifyKey: FfiConverterTypeBytes.read(from: &buf), 
                proofSig: FfiConverterTypeBytes.read(from: &buf), 
                proofElection: FfiConverterTypeBytes.read(from: &buf), 
                proofAggregation: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: BakerKeysPayload, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.signatureVerifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.electionVerifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.aggregationVerifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.proofSig, into: &buf)
        FfiConverterTypeBytes.write(value.proofElection, into: &buf)
        FfiConverterTypeBytes.write(value.proofAggregation, into: &buf)
    }
}


public func FfiConverterTypeBakerKeysPayload_lift(_ buf: RustBuffer) throws -> BakerKeysPayload {
    return try FfiConverterTypeBakerKeysPayload.lift(buf)
}

public func FfiConverterTypeBakerKeysPayload_lower(_ value: BakerKeysPayload) -> RustBuffer {
    return FfiConverterTypeBakerKeysPayload.lower(value)
}


/**
 * Data relating to a single anonymity revoker constructed by the account holder.
 * Typically a vector of these will be sent to the chain.
 */
public struct ChainArData {
    public var encIdCredPubShare: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        encIdCredPubShare: Bytes) {
        self.encIdCredPubShare = encIdCredPubShare
    }
}


extension ChainArData: Equatable, Hashable {
    public static func ==(lhs: ChainArData, rhs: ChainArData) -> Bool {
        if lhs.encIdCredPubShare != rhs.encIdCredPubShare {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encIdCredPubShare)
    }
}


public struct FfiConverterTypeChainArData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainArData {
        return
            try ChainArData(
                encIdCredPubShare: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: ChainArData, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.encIdCredPubShare, into: &buf)
    }
}


public func FfiConverterTypeChainArData_lift(_ buf: RustBuffer) throws -> ChainArData {
    return try FfiConverterTypeChainArData.lift(buf)
}

public func FfiConverterTypeChainArData_lower(_ value: ChainArData) -> RustBuffer {
    return FfiConverterTypeChainArData.lower(value)
}


/**
 * Choice of anonymity revocation parameters.
 */
public struct ChoiceArParameters {
    public var arIdentities: [UInt32]
    public var threshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        arIdentities: [UInt32], 
        threshold: UInt8) {
        self.arIdentities = arIdentities
        self.threshold = threshold
    }
}


extension ChoiceArParameters: Equatable, Hashable {
    public static func ==(lhs: ChoiceArParameters, rhs: ChoiceArParameters) -> Bool {
        if lhs.arIdentities != rhs.arIdentities {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(arIdentities)
        hasher.combine(threshold)
    }
}


public struct FfiConverterTypeChoiceArParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChoiceArParameters {
        return
            try ChoiceArParameters(
                arIdentities: FfiConverterSequenceUInt32.read(from: &buf), 
                threshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ChoiceArParameters, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt32.write(value.arIdentities, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
    }
}


public func FfiConverterTypeChoiceArParameters_lift(_ buf: RustBuffer) throws -> ChoiceArParameters {
    return try FfiConverterTypeChoiceArParameters.lift(buf)
}

public func FfiConverterTypeChoiceArParameters_lower(_ value: ChoiceArParameters) -> RustBuffer {
    return FfiConverterTypeChoiceArParameters.lower(value)
}


/**
 * A credential with attributes, public keys, and proofs that it is
 * well-formed.
 */
public struct CredentialDeploymentInfo {
    /**
     * List of anonymity revokers which can revoke the identity.
     * The order is important since it is the same order as that signed by the identity provider,
     * and permuting the list will invalidate the signature from the identity provider.
     */
    public var arData: [UInt32: ChainArData]
    /**
     * Credential registration ID of the credential.
     * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base.
     */
    public var credId: Bytes
    /**
     * Credential keys (i.e. account holder keys).
     */
    public var credentialPublicKeys: CredentialPublicKeys
    /**
     * Identity of the identity provider who signed the identity object
     * from which this credential is derived.
     */
    public var ipIdentity: UInt32
    /**
     * Policy of this credential object.
     */
    public var policy: Policy
    /**
     * The proofs of ownership.
     * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base
     */
    public var proofs: Bytes
    /**
     * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
     */
    public var revocationThreshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * List of anonymity revokers which can revoke the identity.
         * The order is important since it is the same order as that signed by the identity provider,
         * and permuting the list will invalidate the signature from the identity provider.
         */
        arData: [UInt32: ChainArData], 
        /**
         * Credential registration ID of the credential.
         * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base.
         */
        credId: Bytes, 
        /**
         * Credential keys (i.e. account holder keys).
         */
        credentialPublicKeys: CredentialPublicKeys, 
        /**
         * Identity of the identity provider who signed the identity object
         * from which this credential is derived.
         */
        ipIdentity: UInt32, 
        /**
         * Policy of this credential object.
         */
        policy: Policy, 
        /**
         * The proofs of ownership.
         * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base
         */
        proofs: Bytes, 
        /**
         * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
         */
        revocationThreshold: UInt8) {
        self.arData = arData
        self.credId = credId
        self.credentialPublicKeys = credentialPublicKeys
        self.ipIdentity = ipIdentity
        self.policy = policy
        self.proofs = proofs
        self.revocationThreshold = revocationThreshold
    }
}


extension CredentialDeploymentInfo: Equatable, Hashable {
    public static func ==(lhs: CredentialDeploymentInfo, rhs: CredentialDeploymentInfo) -> Bool {
        if lhs.arData != rhs.arData {
            return false
        }
        if lhs.credId != rhs.credId {
            return false
        }
        if lhs.credentialPublicKeys != rhs.credentialPublicKeys {
            return false
        }
        if lhs.ipIdentity != rhs.ipIdentity {
            return false
        }
        if lhs.policy != rhs.policy {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        if lhs.revocationThreshold != rhs.revocationThreshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(arData)
        hasher.combine(credId)
        hasher.combine(credentialPublicKeys)
        hasher.combine(ipIdentity)
        hasher.combine(policy)
        hasher.combine(proofs)
        hasher.combine(revocationThreshold)
    }
}


public struct FfiConverterTypeCredentialDeploymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialDeploymentInfo {
        return
            try CredentialDeploymentInfo(
                arData: FfiConverterDictionaryUInt32TypeChainArData.read(from: &buf), 
                credId: FfiConverterTypeBytes.read(from: &buf), 
                credentialPublicKeys: FfiConverterTypeCredentialPublicKeys.read(from: &buf), 
                ipIdentity: FfiConverterUInt32.read(from: &buf), 
                policy: FfiConverterTypePolicy.read(from: &buf), 
                proofs: FfiConverterTypeBytes.read(from: &buf), 
                revocationThreshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialDeploymentInfo, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt32TypeChainArData.write(value.arData, into: &buf)
        FfiConverterTypeBytes.write(value.credId, into: &buf)
        FfiConverterTypeCredentialPublicKeys.write(value.credentialPublicKeys, into: &buf)
        FfiConverterUInt32.write(value.ipIdentity, into: &buf)
        FfiConverterTypePolicy.write(value.policy, into: &buf)
        FfiConverterTypeBytes.write(value.proofs, into: &buf)
        FfiConverterUInt8.write(value.revocationThreshold, into: &buf)
    }
}


public func FfiConverterTypeCredentialDeploymentInfo_lift(_ buf: RustBuffer) throws -> CredentialDeploymentInfo {
    return try FfiConverterTypeCredentialDeploymentInfo.lift(buf)
}

public func FfiConverterTypeCredentialDeploymentInfo_lower(_ value: CredentialDeploymentInfo) -> RustBuffer {
    return FfiConverterTypeCredentialDeploymentInfo.lower(value)
}


/**
 * Public credential keys currently on the account.
 * The threshold determines the number of required signatures on a transaction for it to be valid.
 */
public struct CredentialPublicKeys {
    public var keys: [UInt8: VerifyKey]
    public var threshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        keys: [UInt8: VerifyKey], 
        threshold: UInt8) {
        self.keys = keys
        self.threshold = threshold
    }
}


extension CredentialPublicKeys: Equatable, Hashable {
    public static func ==(lhs: CredentialPublicKeys, rhs: CredentialPublicKeys) -> Bool {
        if lhs.keys != rhs.keys {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keys)
        hasher.combine(threshold)
    }
}


public struct FfiConverterTypeCredentialPublicKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialPublicKeys {
        return
            try CredentialPublicKeys(
                keys: FfiConverterDictionaryUInt8TypeVerifyKey.read(from: &buf), 
                threshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialPublicKeys, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt8TypeVerifyKey.write(value.keys, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
    }
}


public func FfiConverterTypeCredentialPublicKeys_lift(_ buf: RustBuffer) throws -> CredentialPublicKeys {
    return try FfiConverterTypeCredentialPublicKeys.lift(buf)
}

public func FfiConverterTypeCredentialPublicKeys_lower(_ value: CredentialPublicKeys) -> RustBuffer {
    return FfiConverterTypeCredentialPublicKeys.lower(value)
}


/**
 * Metadata of an identity provider or anonymity revoker
 * to be visible on the chain.
 */
public struct Description {
    public var name: String
    public var url: String
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        name: String, 
        url: String, 
        description: String) {
        self.name = name
        self.url = url
        self.description = description
    }
}


extension Description: Equatable, Hashable {
    public static func ==(lhs: Description, rhs: Description) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(url)
        hasher.combine(description)
    }
}


public struct FfiConverterTypeDescription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Description {
        return
            try Description(
                name: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Description, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}


public func FfiConverterTypeDescription_lift(_ buf: RustBuffer) throws -> Description {
    return try FfiConverterTypeDescription.lift(buf)
}

public func FfiConverterTypeDescription_lower(_ value: Description) -> RustBuffer {
    return FfiConverterTypeDescription.lower(value)
}


/**
 * Encryption keypair for an account, used to handle the encrypted amount associated with a specific account.
 */
public struct EncryptionKeys {
    /**
     * The secret key serialized as bytes.
     */
    public var secret: Bytes
    /**
     * The public key serialized as bytes.
     */
    public var `public`: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The secret key serialized as bytes.
         */
        secret: Bytes, 
        /**
         * The public key serialized as bytes.
         */
        `public`: Bytes) {
        self.secret = secret
        self.`public` = `public`
    }
}


extension EncryptionKeys: Equatable, Hashable {
    public static func ==(lhs: EncryptionKeys, rhs: EncryptionKeys) -> Bool {
        if lhs.secret != rhs.secret {
            return false
        }
        if lhs.`public` != rhs.`public` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secret)
        hasher.combine(`public`)
    }
}


public struct FfiConverterTypeEncryptionKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionKeys {
        return
            try EncryptionKeys(
                secret: FfiConverterTypeBytes.read(from: &buf), 
                public: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: EncryptionKeys, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.secret, into: &buf)
        FfiConverterTypeBytes.write(value.`public`, into: &buf)
    }
}


public func FfiConverterTypeEncryptionKeys_lift(_ buf: RustBuffer) throws -> EncryptionKeys {
    return try FfiConverterTypeEncryptionKeys.lift(buf)
}

public func FfiConverterTypeEncryptionKeys_lower(_ value: EncryptionKeys) -> RustBuffer {
    return FfiConverterTypeEncryptionKeys.lower(value)
}


/**
 * A set of cryptographic parameters that are particular to the chain and
 * shared by everybody that interacts with the chain.
 */
public struct GlobalContext {
    /**
     * Shared commitment key known to the chain and the account holder (i.e. it's public).
     * The account holder uses this commitment key to generate commitments to values in the attribute list.
     */
    public var onChainCommitmentKey: Bytes
    /**
     * Generators for the bulletproofs.
     */
    public var bulletproofGenerators: Bytes
    /**
     * Free-form string used to distinguish between different chains even if they share other parameters.
     */
    public var genesisString: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Shared commitment key known to the chain and the account holder (i.e. it's public).
         * The account holder uses this commitment key to generate commitments to values in the attribute list.
         */
        onChainCommitmentKey: Bytes, 
        /**
         * Generators for the bulletproofs.
         */
        bulletproofGenerators: Bytes, 
        /**
         * Free-form string used to distinguish between different chains even if they share other parameters.
         */
        genesisString: String) {
        self.onChainCommitmentKey = onChainCommitmentKey
        self.bulletproofGenerators = bulletproofGenerators
        self.genesisString = genesisString
    }
}


extension GlobalContext: Equatable, Hashable {
    public static func ==(lhs: GlobalContext, rhs: GlobalContext) -> Bool {
        if lhs.onChainCommitmentKey != rhs.onChainCommitmentKey {
            return false
        }
        if lhs.bulletproofGenerators != rhs.bulletproofGenerators {
            return false
        }
        if lhs.genesisString != rhs.genesisString {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(onChainCommitmentKey)
        hasher.combine(bulletproofGenerators)
        hasher.combine(genesisString)
    }
}


public struct FfiConverterTypeGlobalContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalContext {
        return
            try GlobalContext(
                onChainCommitmentKey: FfiConverterTypeBytes.read(from: &buf), 
                bulletproofGenerators: FfiConverterTypeBytes.read(from: &buf), 
                genesisString: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GlobalContext, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.onChainCommitmentKey, into: &buf)
        FfiConverterTypeBytes.write(value.bulletproofGenerators, into: &buf)
        FfiConverterString.write(value.genesisString, into: &buf)
    }
}


public func FfiConverterTypeGlobalContext_lift(_ buf: RustBuffer) throws -> GlobalContext {
    return try FfiConverterTypeGlobalContext.lift(buf)
}

public func FfiConverterTypeGlobalContext_lower(_ value: GlobalContext) -> RustBuffer {
    return FfiConverterTypeGlobalContext.lower(value)
}


/**
 * Parameter object for `identity_issuance_request_json`.
 */
public struct IdentityIssuanceRequestParameters {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var arsInfos: [UInt32: AnonymityRevokerInfo]
    public var arThreshold: UInt8
    public var prfKey: Bytes
    public var idCredSec: Bytes
    public var blindingRandomness: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        ipInfo: IdentityProviderInfo, 
        globalContext: GlobalContext, 
        arsInfos: [UInt32: AnonymityRevokerInfo], 
        arThreshold: UInt8, 
        prfKey: Bytes, 
        idCredSec: Bytes, 
        blindingRandomness: Bytes) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.arsInfos = arsInfos
        self.arThreshold = arThreshold
        self.prfKey = prfKey
        self.idCredSec = idCredSec
        self.blindingRandomness = blindingRandomness
    }
}


extension IdentityIssuanceRequestParameters: Equatable, Hashable {
    public static func ==(lhs: IdentityIssuanceRequestParameters, rhs: IdentityIssuanceRequestParameters) -> Bool {
        if lhs.ipInfo != rhs.ipInfo {
            return false
        }
        if lhs.globalContext != rhs.globalContext {
            return false
        }
        if lhs.arsInfos != rhs.arsInfos {
            return false
        }
        if lhs.arThreshold != rhs.arThreshold {
            return false
        }
        if lhs.prfKey != rhs.prfKey {
            return false
        }
        if lhs.idCredSec != rhs.idCredSec {
            return false
        }
        if lhs.blindingRandomness != rhs.blindingRandomness {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ipInfo)
        hasher.combine(globalContext)
        hasher.combine(arsInfos)
        hasher.combine(arThreshold)
        hasher.combine(prfKey)
        hasher.combine(idCredSec)
        hasher.combine(blindingRandomness)
    }
}


public struct FfiConverterTypeIdentityIssuanceRequestParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityIssuanceRequestParameters {
        return
            try IdentityIssuanceRequestParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf), 
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf), 
                arsInfos: FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.read(from: &buf), 
                arThreshold: FfiConverterUInt8.read(from: &buf), 
                prfKey: FfiConverterTypeBytes.read(from: &buf), 
                idCredSec: FfiConverterTypeBytes.read(from: &buf), 
                blindingRandomness: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityIssuanceRequestParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.write(value.arsInfos, into: &buf)
        FfiConverterUInt8.write(value.arThreshold, into: &buf)
        FfiConverterTypeBytes.write(value.prfKey, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSec, into: &buf)
        FfiConverterTypeBytes.write(value.blindingRandomness, into: &buf)
    }
}


public func FfiConverterTypeIdentityIssuanceRequestParameters_lift(_ buf: RustBuffer) throws -> IdentityIssuanceRequestParameters {
    return try FfiConverterTypeIdentityIssuanceRequestParameters.lift(buf)
}

public func FfiConverterTypeIdentityIssuanceRequestParameters_lower(_ value: IdentityIssuanceRequestParameters) -> RustBuffer {
    return FfiConverterTypeIdentityIssuanceRequestParameters.lower(value)
}


/**
 * The data we get back from the identity provider in the version 1 flow.
 */
public struct IdentityObject {
    public var preIdentityObject: PreIdentityObject
    /**
     * Chosen attribute list.
     */
    public var attributeList: AttributeList
    public var signature: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        preIdentityObject: PreIdentityObject, 
        /**
         * Chosen attribute list.
         */
        attributeList: AttributeList, 
        signature: Bytes) {
        self.preIdentityObject = preIdentityObject
        self.attributeList = attributeList
        self.signature = signature
    }
}


extension IdentityObject: Equatable, Hashable {
    public static func ==(lhs: IdentityObject, rhs: IdentityObject) -> Bool {
        if lhs.preIdentityObject != rhs.preIdentityObject {
            return false
        }
        if lhs.attributeList != rhs.attributeList {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preIdentityObject)
        hasher.combine(attributeList)
        hasher.combine(signature)
    }
}


public struct FfiConverterTypeIdentityObject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityObject {
        return
            try IdentityObject(
                preIdentityObject: FfiConverterTypePreIdentityObject.read(from: &buf), 
                attributeList: FfiConverterTypeAttributeList.read(from: &buf), 
                signature: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityObject, into buf: inout [UInt8]) {
        FfiConverterTypePreIdentityObject.write(value.preIdentityObject, into: &buf)
        FfiConverterTypeAttributeList.write(value.attributeList, into: &buf)
        FfiConverterTypeBytes.write(value.signature, into: &buf)
    }
}


public func FfiConverterTypeIdentityObject_lift(_ buf: RustBuffer) throws -> IdentityObject {
    return try FfiConverterTypeIdentityObject.lift(buf)
}

public func FfiConverterTypeIdentityObject_lower(_ value: IdentityObject) -> RustBuffer {
    return FfiConverterTypeIdentityObject.lower(value)
}


/**
 * Public information about an identity provider.
 */
public struct IdentityProviderInfo {
    /**
     * Unique identifier of the identity provider.
     */
    public var identity: UInt32
    /**
     * Free form description, e.g., how to contact them off-chain.
     */
    public var description: Description
    /**
     * PS public key of the identity provider.
     */
    public var verifyKey: Bytes
    /**
     * Ed public key of the identity provider.
     */
    public var cdiVerifyKey: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier of the identity provider.
         */
        identity: UInt32, 
        /**
         * Free form description, e.g., how to contact them off-chain.
         */
        description: Description, 
        /**
         * PS public key of the identity provider.
         */
        verifyKey: Bytes, 
        /**
         * Ed public key of the identity provider.
         */
        cdiVerifyKey: Bytes) {
        self.identity = identity
        self.description = description
        self.verifyKey = verifyKey
        self.cdiVerifyKey = cdiVerifyKey
    }
}


extension IdentityProviderInfo: Equatable, Hashable {
    public static func ==(lhs: IdentityProviderInfo, rhs: IdentityProviderInfo) -> Bool {
        if lhs.identity != rhs.identity {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.verifyKey != rhs.verifyKey {
            return false
        }
        if lhs.cdiVerifyKey != rhs.cdiVerifyKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identity)
        hasher.combine(description)
        hasher.combine(verifyKey)
        hasher.combine(cdiVerifyKey)
    }
}


public struct FfiConverterTypeIdentityProviderInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityProviderInfo {
        return
            try IdentityProviderInfo(
                identity: FfiConverterUInt32.read(from: &buf), 
                description: FfiConverterTypeDescription.read(from: &buf), 
                verifyKey: FfiConverterTypeBytes.read(from: &buf), 
                cdiVerifyKey: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityProviderInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.identity, into: &buf)
        FfiConverterTypeDescription.write(value.description, into: &buf)
        FfiConverterTypeBytes.write(value.verifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.cdiVerifyKey, into: &buf)
    }
}


public func FfiConverterTypeIdentityProviderInfo_lift(_ buf: RustBuffer) throws -> IdentityProviderInfo {
    return try FfiConverterTypeIdentityProviderInfo.lift(buf)
}

public func FfiConverterTypeIdentityProviderInfo_lower(_ value: IdentityProviderInfo) -> RustBuffer {
    return FfiConverterTypeIdentityProviderInfo.lower(value)
}


/**
 * Parameter object for `identity_recovery_request_json`.
 */
public struct IdentityRecoveryRequestParameters {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var timestamp: UInt64
    public var idCredSec: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        ipInfo: IdentityProviderInfo, 
        globalContext: GlobalContext, 
        timestamp: UInt64, 
        idCredSec: Bytes) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.timestamp = timestamp
        self.idCredSec = idCredSec
    }
}


extension IdentityRecoveryRequestParameters: Equatable, Hashable {
    public static func ==(lhs: IdentityRecoveryRequestParameters, rhs: IdentityRecoveryRequestParameters) -> Bool {
        if lhs.ipInfo != rhs.ipInfo {
            return false
        }
        if lhs.globalContext != rhs.globalContext {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.idCredSec != rhs.idCredSec {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ipInfo)
        hasher.combine(globalContext)
        hasher.combine(timestamp)
        hasher.combine(idCredSec)
    }
}


public struct FfiConverterTypeIdentityRecoveryRequestParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityRecoveryRequestParameters {
        return
            try IdentityRecoveryRequestParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf), 
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf), 
                idCredSec: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityRecoveryRequestParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSec, into: &buf)
    }
}


public func FfiConverterTypeIdentityRecoveryRequestParameters_lift(_ buf: RustBuffer) throws -> IdentityRecoveryRequestParameters {
    return try FfiConverterTypeIdentityRecoveryRequestParameters.lift(buf)
}

public func FfiConverterTypeIdentityRecoveryRequestParameters_lower(_ value: IdentityRecoveryRequestParameters) -> RustBuffer {
    return FfiConverterTypeIdentityRecoveryRequestParameters.lower(value)
}


/**
 * An encrypted amount input to transfer from
 */
public struct InputEncryptedAmount {
    /**
     * The aggregated encrypted amount.
     */
    public var aggEncryptedAmount: Bytes
    /**
     * The plaintext corresponding to the aggregated encrypted amount.
     */
    public var aggAmount: UInt64
    /**
     * Index such that the `agg_amount` is the sum of all encrypted amounts on an account with indices strictly below `agg_index`.
     */
    public var aggIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The aggregated encrypted amount.
         */
        aggEncryptedAmount: Bytes, 
        /**
         * The plaintext corresponding to the aggregated encrypted amount.
         */
        aggAmount: UInt64, 
        /**
         * Index such that the `agg_amount` is the sum of all encrypted amounts on an account with indices strictly below `agg_index`.
         */
        aggIndex: UInt64) {
        self.aggEncryptedAmount = aggEncryptedAmount
        self.aggAmount = aggAmount
        self.aggIndex = aggIndex
    }
}


extension InputEncryptedAmount: Equatable, Hashable {
    public static func ==(lhs: InputEncryptedAmount, rhs: InputEncryptedAmount) -> Bool {
        if lhs.aggEncryptedAmount != rhs.aggEncryptedAmount {
            return false
        }
        if lhs.aggAmount != rhs.aggAmount {
            return false
        }
        if lhs.aggIndex != rhs.aggIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(aggEncryptedAmount)
        hasher.combine(aggAmount)
        hasher.combine(aggIndex)
    }
}


public struct FfiConverterTypeInputEncryptedAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InputEncryptedAmount {
        return
            try InputEncryptedAmount(
                aggEncryptedAmount: FfiConverterTypeBytes.read(from: &buf), 
                aggAmount: FfiConverterUInt64.read(from: &buf), 
                aggIndex: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: InputEncryptedAmount, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.aggEncryptedAmount, into: &buf)
        FfiConverterUInt64.write(value.aggAmount, into: &buf)
        FfiConverterUInt64.write(value.aggIndex, into: &buf)
    }
}


public func FfiConverterTypeInputEncryptedAmount_lift(_ buf: RustBuffer) throws -> InputEncryptedAmount {
    return try FfiConverterTypeInputEncryptedAmount.lift(buf)
}

public func FfiConverterTypeInputEncryptedAmount_lower(_ value: InputEncryptedAmount) -> RustBuffer {
    return FfiConverterTypeInputEncryptedAmount.lower(value)
}


/**
 * Represents a contract module schema of a specific version.
 */
public struct ModuleSchema {
    /**
     * The module schema serialized as bytes.
     */
    public var value: Data
    /**
     * The module schema version. This is optional, as this can also be included in the serialized schema value.
     * If the version is neither present in the serialized schema, nor defined explicitly, an error will be returned upon use.
     */
    public var version: ModuleSchemaVersion?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The module schema serialized as bytes.
         */
        value: Data, 
        /**
         * The module schema version. This is optional, as this can also be included in the serialized schema value.
         * If the version is neither present in the serialized schema, nor defined explicitly, an error will be returned upon use.
         */
        version: ModuleSchemaVersion?) {
        self.value = value
        self.version = version
    }
}


extension ModuleSchema: Equatable, Hashable {
    public static func ==(lhs: ModuleSchema, rhs: ModuleSchema) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(version)
    }
}


public struct FfiConverterTypeModuleSchema: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModuleSchema {
        return
            try ModuleSchema(
                value: FfiConverterData.read(from: &buf), 
                version: FfiConverterOptionTypeModuleSchemaVersion.read(from: &buf)
        )
    }

    public static func write(_ value: ModuleSchema, into buf: inout [UInt8]) {
        FfiConverterData.write(value.value, into: &buf)
        FfiConverterOptionTypeModuleSchemaVersion.write(value.version, into: &buf)
    }
}


public func FfiConverterTypeModuleSchema_lift(_ buf: RustBuffer) throws -> ModuleSchema {
    return try FfiConverterTypeModuleSchema.lift(buf)
}

public func FfiConverterTypeModuleSchema_lower(_ value: ModuleSchema) -> RustBuffer {
    return FfiConverterTypeModuleSchema.lower(value)
}


/**
 * A policy is (currently) revealed values of attributes that are part of the identity object.
 * Policies are part of credentials.
 */
public struct Policy {
    public var createdAtYearMonth: String
    public var validToYearMonth: String
    public var revealedAttributes: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        createdAtYearMonth: String, 
        validToYearMonth: String, 
        revealedAttributes: [String: String]) {
        self.createdAtYearMonth = createdAtYearMonth
        self.validToYearMonth = validToYearMonth
        self.revealedAttributes = revealedAttributes
    }
}


extension Policy: Equatable, Hashable {
    public static func ==(lhs: Policy, rhs: Policy) -> Bool {
        if lhs.createdAtYearMonth != rhs.createdAtYearMonth {
            return false
        }
        if lhs.validToYearMonth != rhs.validToYearMonth {
            return false
        }
        if lhs.revealedAttributes != rhs.revealedAttributes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdAtYearMonth)
        hasher.combine(validToYearMonth)
        hasher.combine(revealedAttributes)
    }
}


public struct FfiConverterTypePolicy: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Policy {
        return
            try Policy(
                createdAtYearMonth: FfiConverterString.read(from: &buf), 
                validToYearMonth: FfiConverterString.read(from: &buf), 
                revealedAttributes: FfiConverterDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: Policy, into buf: inout [UInt8]) {
        FfiConverterString.write(value.createdAtYearMonth, into: &buf)
        FfiConverterString.write(value.validToYearMonth, into: &buf)
        FfiConverterDictionaryStringString.write(value.revealedAttributes, into: &buf)
    }
}


public func FfiConverterTypePolicy_lift(_ buf: RustBuffer) throws -> Policy {
    return try FfiConverterTypePolicy.lift(buf)
}

public func FfiConverterTypePolicy_lower(_ value: Policy) -> RustBuffer {
    return FfiConverterTypePolicy.lower(value)
}


/**
 * Information sent from the account holder to the identity provider.
 * This includes only the cryptographic parts; the attribute list is in a different object below.
 * This is for the flow where no initial account is involved.
 */
public struct PreIdentityObject {
    public var idCredPub: Bytes
    /**
     * Anonymity revocation data for the chosen anonymity revokers.
     */
    public var ipArData: [UInt32: ArData]
    /**
     * Choice of anonyimity revocation parameters.
     * Identity provider checks that the values make sense in the context of the public keys they are allowed to use.
     */
    public var choiceArData: ChoiceArParameters
    /**
     * Commitment to ID cred sec using the commitment key of the identity provider derived from the PS public key.
     * This is used to compute the message that the identity provider signs.
     */
    public var idCredSecCommitment: Bytes
    /**
     * Commitment to the PRF key in group G1.
     */
    public var prfKeyCommitmentWithIp: Bytes
    /**
     * Commitments to the coefficients of the polynomial used to share the PRF key.
     */
    public var prfKeySharingCoeffCommitments: [Bytes]
    /**
     * Proof that the data sent to the identity provider is well-formed.
     */
    public var proofsOfKnowledge: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        idCredPub: Bytes, 
        /**
         * Anonymity revocation data for the chosen anonymity revokers.
         */
        ipArData: [UInt32: ArData], 
        /**
         * Choice of anonyimity revocation parameters.
         * Identity provider checks that the values make sense in the context of the public keys they are allowed to use.
         */
        choiceArData: ChoiceArParameters, 
        /**
         * Commitment to ID cred sec using the commitment key of the identity provider derived from the PS public key.
         * This is used to compute the message that the identity provider signs.
         */
        idCredSecCommitment: Bytes, 
        /**
         * Commitment to the PRF key in group G1.
         */
        prfKeyCommitmentWithIp: Bytes, 
        /**
         * Commitments to the coefficients of the polynomial used to share the PRF key.
         */
        prfKeySharingCoeffCommitments: [Bytes], 
        /**
         * Proof that the data sent to the identity provider is well-formed.
         */
        proofsOfKnowledge: Bytes) {
        self.idCredPub = idCredPub
        self.ipArData = ipArData
        self.choiceArData = choiceArData
        self.idCredSecCommitment = idCredSecCommitment
        self.prfKeyCommitmentWithIp = prfKeyCommitmentWithIp
        self.prfKeySharingCoeffCommitments = prfKeySharingCoeffCommitments
        self.proofsOfKnowledge = proofsOfKnowledge
    }
}


extension PreIdentityObject: Equatable, Hashable {
    public static func ==(lhs: PreIdentityObject, rhs: PreIdentityObject) -> Bool {
        if lhs.idCredPub != rhs.idCredPub {
            return false
        }
        if lhs.ipArData != rhs.ipArData {
            return false
        }
        if lhs.choiceArData != rhs.choiceArData {
            return false
        }
        if lhs.idCredSecCommitment != rhs.idCredSecCommitment {
            return false
        }
        if lhs.prfKeyCommitmentWithIp != rhs.prfKeyCommitmentWithIp {
            return false
        }
        if lhs.prfKeySharingCoeffCommitments != rhs.prfKeySharingCoeffCommitments {
            return false
        }
        if lhs.proofsOfKnowledge != rhs.proofsOfKnowledge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(idCredPub)
        hasher.combine(ipArData)
        hasher.combine(choiceArData)
        hasher.combine(idCredSecCommitment)
        hasher.combine(prfKeyCommitmentWithIp)
        hasher.combine(prfKeySharingCoeffCommitments)
        hasher.combine(proofsOfKnowledge)
    }
}


public struct FfiConverterTypePreIdentityObject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreIdentityObject {
        return
            try PreIdentityObject(
                idCredPub: FfiConverterTypeBytes.read(from: &buf), 
                ipArData: FfiConverterDictionaryUInt32TypeArData.read(from: &buf), 
                choiceArData: FfiConverterTypeChoiceArParameters.read(from: &buf), 
                idCredSecCommitment: FfiConverterTypeBytes.read(from: &buf), 
                prfKeyCommitmentWithIp: FfiConverterTypeBytes.read(from: &buf), 
                prfKeySharingCoeffCommitments: FfiConverterSequenceTypeBytes.read(from: &buf), 
                proofsOfKnowledge: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: PreIdentityObject, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.idCredPub, into: &buf)
        FfiConverterDictionaryUInt32TypeArData.write(value.ipArData, into: &buf)
        FfiConverterTypeChoiceArParameters.write(value.choiceArData, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSecCommitment, into: &buf)
        FfiConverterTypeBytes.write(value.prfKeyCommitmentWithIp, into: &buf)
        FfiConverterSequenceTypeBytes.write(value.prfKeySharingCoeffCommitments, into: &buf)
        FfiConverterTypeBytes.write(value.proofsOfKnowledge, into: &buf)
    }
}


public func FfiConverterTypePreIdentityObject_lift(_ buf: RustBuffer) throws -> PreIdentityObject {
    return try FfiConverterTypePreIdentityObject.lift(buf)
}

public func FfiConverterTypePreIdentityObject_lower(_ value: PreIdentityObject) -> RustBuffer {
    return FfiConverterTypePreIdentityObject.lower(value)
}


/**
 * All proofs required to prove ownership of an identity in a credential deployment.
 */
public struct Proofs {
    /**
     * Challenge used for all of the proofs.
     */
    public var challenge: Bytes
    /**
     * List of commitments to the attributes.
     */
    public var commitments: Bytes
    /**
     * Proof that credential counter is at most equal to the maximum allowed number of account.
     */
    public var credCounterLessThanMaxAccounts: Bytes
    /**
     * Responses in the proof that the computed commitment to the share
     * contains the same value as the encryption.
     * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
     */
    public var proofIdCredPub: [String: Bytes]
    /**
     * Responses in the proof of knowledge of signature of the identity provider.
     */
    public var proofIpSig: Bytes
    /**
     * Proof that registration ID is valid and computed from the PRF key signed by the identity provider.
     */
    public var proofRegId: Bytes
    /**
     * (Blinded) signature derived from the signature on the pre-identity object by the identity provider.
     */
    public var signature: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Challenge used for all of the proofs.
         */
        challenge: Bytes, 
        /**
         * List of commitments to the attributes.
         */
        commitments: Bytes, 
        /**
         * Proof that credential counter is at most equal to the maximum allowed number of account.
         */
        credCounterLessThanMaxAccounts: Bytes, 
        /**
         * Responses in the proof that the computed commitment to the share
         * contains the same value as the encryption.
         * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
         */
        proofIdCredPub: [String: Bytes], 
        /**
         * Responses in the proof of knowledge of signature of the identity provider.
         */
        proofIpSig: Bytes, 
        /**
         * Proof that registration ID is valid and computed from the PRF key signed by the identity provider.
         */
        proofRegId: Bytes, 
        /**
         * (Blinded) signature derived from the signature on the pre-identity object by the identity provider.
         */
        signature: Bytes) {
        self.challenge = challenge
        self.commitments = commitments
        self.credCounterLessThanMaxAccounts = credCounterLessThanMaxAccounts
        self.proofIdCredPub = proofIdCredPub
        self.proofIpSig = proofIpSig
        self.proofRegId = proofRegId
        self.signature = signature
    }
}


extension Proofs: Equatable, Hashable {
    public static func ==(lhs: Proofs, rhs: Proofs) -> Bool {
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.commitments != rhs.commitments {
            return false
        }
        if lhs.credCounterLessThanMaxAccounts != rhs.credCounterLessThanMaxAccounts {
            return false
        }
        if lhs.proofIdCredPub != rhs.proofIdCredPub {
            return false
        }
        if lhs.proofIpSig != rhs.proofIpSig {
            return false
        }
        if lhs.proofRegId != rhs.proofRegId {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challenge)
        hasher.combine(commitments)
        hasher.combine(credCounterLessThanMaxAccounts)
        hasher.combine(proofIdCredPub)
        hasher.combine(proofIpSig)
        hasher.combine(proofRegId)
        hasher.combine(signature)
    }
}


public struct FfiConverterTypeProofs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Proofs {
        return
            try Proofs(
                challenge: FfiConverterTypeBytes.read(from: &buf), 
                commitments: FfiConverterTypeBytes.read(from: &buf), 
                credCounterLessThanMaxAccounts: FfiConverterTypeBytes.read(from: &buf), 
                proofIdCredPub: FfiConverterDictionaryStringTypeBytes.read(from: &buf), 
                proofIpSig: FfiConverterTypeBytes.read(from: &buf), 
                proofRegId: FfiConverterTypeBytes.read(from: &buf), 
                signature: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Proofs, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.challenge, into: &buf)
        FfiConverterTypeBytes.write(value.commitments, into: &buf)
        FfiConverterTypeBytes.write(value.credCounterLessThanMaxAccounts, into: &buf)
        FfiConverterDictionaryStringTypeBytes.write(value.proofIdCredPub, into: &buf)
        FfiConverterTypeBytes.write(value.proofIpSig, into: &buf)
        FfiConverterTypeBytes.write(value.proofRegId, into: &buf)
        FfiConverterTypeBytes.write(value.signature, into: &buf)
    }
}


public func FfiConverterTypeProofs_lift(_ buf: RustBuffer) throws -> Proofs {
    return try FfiConverterTypeProofs.lift(buf)
}

public func FfiConverterTypeProofs_lower(_ value: Proofs) -> RustBuffer {
    return FfiConverterTypeProofs.lower(value)
}


/**
 * Randomness that is generated to commit to attributes when creating a credential.
 * This randomness is needed to do something with those commitments later,
 * for example reveal the committed value or prove a property of the value.
 */
public struct Randomness {
    /**
     * Randomness used to commit to any user-chosen attributes, such as country of nationality.
     */
    public var attributesRand: [String: Bytes]
    /**
     * Randomness of the commitment to the credential nonce.
     * This nonce is the number that is used to ensure that only a limited number of credentials
     * can be created from a given identity object.
     */
    public var credCounterRand: Bytes
    /**
     * Randomness of the commitment to idCredSec.
     */
    public var idCredSecRand: Bytes
    /**
     * Randomness of the commitment to the maximum number of accounts that may be created from the identity object.
     */
    public var maxAccountsRand: Bytes
    /**
     * Randomness of the commitment to the PRF key.
     */
    public var prfRand: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Randomness used to commit to any user-chosen attributes, such as country of nationality.
         */
        attributesRand: [String: Bytes], 
        /**
         * Randomness of the commitment to the credential nonce.
         * This nonce is the number that is used to ensure that only a limited number of credentials
         * can be created from a given identity object.
         */
        credCounterRand: Bytes, 
        /**
         * Randomness of the commitment to idCredSec.
         */
        idCredSecRand: Bytes, 
        /**
         * Randomness of the commitment to the maximum number of accounts that may be created from the identity object.
         */
        maxAccountsRand: Bytes, 
        /**
         * Randomness of the commitment to the PRF key.
         */
        prfRand: Bytes) {
        self.attributesRand = attributesRand
        self.credCounterRand = credCounterRand
        self.idCredSecRand = idCredSecRand
        self.maxAccountsRand = maxAccountsRand
        self.prfRand = prfRand
    }
}


extension Randomness: Equatable, Hashable {
    public static func ==(lhs: Randomness, rhs: Randomness) -> Bool {
        if lhs.attributesRand != rhs.attributesRand {
            return false
        }
        if lhs.credCounterRand != rhs.credCounterRand {
            return false
        }
        if lhs.idCredSecRand != rhs.idCredSecRand {
            return false
        }
        if lhs.maxAccountsRand != rhs.maxAccountsRand {
            return false
        }
        if lhs.prfRand != rhs.prfRand {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributesRand)
        hasher.combine(credCounterRand)
        hasher.combine(idCredSecRand)
        hasher.combine(maxAccountsRand)
        hasher.combine(prfRand)
    }
}


public struct FfiConverterTypeRandomness: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Randomness {
        return
            try Randomness(
                attributesRand: FfiConverterDictionaryStringTypeBytes.read(from: &buf), 
                credCounterRand: FfiConverterTypeBytes.read(from: &buf), 
                idCredSecRand: FfiConverterTypeBytes.read(from: &buf), 
                maxAccountsRand: FfiConverterTypeBytes.read(from: &buf), 
                prfRand: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Randomness, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringTypeBytes.write(value.attributesRand, into: &buf)
        FfiConverterTypeBytes.write(value.credCounterRand, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSecRand, into: &buf)
        FfiConverterTypeBytes.write(value.maxAccountsRand, into: &buf)
        FfiConverterTypeBytes.write(value.prfRand, into: &buf)
    }
}


public func FfiConverterTypeRandomness_lift(_ buf: RustBuffer) throws -> Randomness {
    return try FfiConverterTypeRandomness.lift(buf)
}

public func FfiConverterTypeRandomness_lower(_ value: Randomness) -> RustBuffer {
    return FfiConverterTypeRandomness.lower(value)
}


/**
 * The payload data for a TransferToPublic transaction
 */
public struct SecToPubTransferData {
    /**
     * The serialized remaining amount after deducting the amount to transfer
     * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::EncryptedAmount`]
     */
    public var remainingAmount: Bytes
    /**
     * The amount to transfer in microCCD.
     */
    public var transferAmount: MicroCCDAmount
    /**
     * The transfer index of the transfer
     */
    public var index: UInt64
    /**
     * The serialized proof that the transfer is correct.
     * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::SecToPubAmountTransferProof`]
     */
    public var proof: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The serialized remaining amount after deducting the amount to transfer
         * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::EncryptedAmount`]
         */
        remainingAmount: Bytes, 
        /**
         * The amount to transfer in microCCD.
         */
        transferAmount: MicroCCDAmount, 
        /**
         * The transfer index of the transfer
         */
        index: UInt64, 
        /**
         * The serialized proof that the transfer is correct.
         * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::SecToPubAmountTransferProof`]
         */
        proof: Bytes) {
        self.remainingAmount = remainingAmount
        self.transferAmount = transferAmount
        self.index = index
        self.proof = proof
    }
}


extension SecToPubTransferData: Equatable, Hashable {
    public static func ==(lhs: SecToPubTransferData, rhs: SecToPubTransferData) -> Bool {
        if lhs.remainingAmount != rhs.remainingAmount {
            return false
        }
        if lhs.transferAmount != rhs.transferAmount {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(remainingAmount)
        hasher.combine(transferAmount)
        hasher.combine(index)
        hasher.combine(proof)
    }
}


public struct FfiConverterTypeSecToPubTransferData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecToPubTransferData {
        return
            try SecToPubTransferData(
                remainingAmount: FfiConverterTypeBytes.read(from: &buf), 
                transferAmount: FfiConverterTypeMicroCCDAmount.read(from: &buf), 
                index: FfiConverterUInt64.read(from: &buf), 
                proof: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: SecToPubTransferData, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.remainingAmount, into: &buf)
        FfiConverterTypeMicroCCDAmount.write(value.transferAmount, into: &buf)
        FfiConverterUInt64.write(value.index, into: &buf)
        FfiConverterTypeBytes.write(value.proof, into: &buf)
    }
}


public func FfiConverterTypeSecToPubTransferData_lift(_ buf: RustBuffer) throws -> SecToPubTransferData {
    return try FfiConverterTypeSecToPubTransferData.lift(buf)
}

public func FfiConverterTypeSecToPubTransferData_lower(_ value: SecToPubTransferData) -> RustBuffer {
    return FfiConverterTypeSecToPubTransferData.lower(value)
}


public struct SecToPubTransferDataDeserializeResult {
    public var value: SecToPubTransferData
    public var bytesRead: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        value: SecToPubTransferData, 
        bytesRead: UInt64) {
        self.value = value
        self.bytesRead = bytesRead
    }
}


extension SecToPubTransferDataDeserializeResult: Equatable, Hashable {
    public static func ==(lhs: SecToPubTransferDataDeserializeResult, rhs: SecToPubTransferDataDeserializeResult) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.bytesRead != rhs.bytesRead {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(bytesRead)
    }
}


public struct FfiConverterTypeSecToPubTransferDataDeserializeResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecToPubTransferDataDeserializeResult {
        return
            try SecToPubTransferDataDeserializeResult(
                value: FfiConverterTypeSecToPubTransferData.read(from: &buf), 
                bytesRead: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SecToPubTransferDataDeserializeResult, into buf: inout [UInt8]) {
        FfiConverterTypeSecToPubTransferData.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.bytesRead, into: &buf)
    }
}


public func FfiConverterTypeSecToPubTransferDataDeserializeResult_lift(_ buf: RustBuffer) throws -> SecToPubTransferDataDeserializeResult {
    return try FfiConverterTypeSecToPubTransferDataDeserializeResult.lift(buf)
}

public func FfiConverterTypeSecToPubTransferDataDeserializeResult_lower(_ value: SecToPubTransferDataDeserializeResult) -> RustBuffer {
    return FfiConverterTypeSecToPubTransferDataDeserializeResult.lower(value)
}


/**
 * The credential deployment context required to serialize a credential deployment for submission to the chain.
 */
public struct SignedAccountCredential {
    public var credential: AccountCredential
    public var signatures: [UInt8: Bytes]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        credential: AccountCredential, 
        signatures: [UInt8: Bytes]) {
        self.credential = credential
        self.signatures = signatures
    }
}


extension SignedAccountCredential: Equatable, Hashable {
    public static func ==(lhs: SignedAccountCredential, rhs: SignedAccountCredential) -> Bool {
        if lhs.credential != rhs.credential {
            return false
        }
        if lhs.signatures != rhs.signatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(credential)
        hasher.combine(signatures)
    }
}


public struct FfiConverterTypeSignedAccountCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedAccountCredential {
        return
            try SignedAccountCredential(
                credential: FfiConverterTypeAccountCredential.read(from: &buf), 
                signatures: FfiConverterDictionaryUInt8TypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: SignedAccountCredential, into buf: inout [UInt8]) {
        FfiConverterTypeAccountCredential.write(value.credential, into: &buf)
        FfiConverterDictionaryUInt8TypeBytes.write(value.signatures, into: &buf)
    }
}


public func FfiConverterTypeSignedAccountCredential_lift(_ buf: RustBuffer) throws -> SignedAccountCredential {
    return try FfiConverterTypeSignedAccountCredential.lift(buf)
}

public func FfiConverterTypeSignedAccountCredential_lower(_ value: SignedAccountCredential) -> RustBuffer {
    return FfiConverterTypeSignedAccountCredential.lower(value)
}


/**
 * Represents a schema for a specific type used in a contract.
 */
public struct TypeSchema {
    /**
     * The type schema serialized as bytes.
     */
    public var value: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The type schema serialized as bytes.
         */
        value: Data) {
        self.value = value
    }
}


extension TypeSchema: Equatable, Hashable {
    public static func ==(lhs: TypeSchema, rhs: TypeSchema) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


public struct FfiConverterTypeTypeSchema: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypeSchema {
        return
            try TypeSchema(
                value: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: TypeSchema, into buf: inout [UInt8]) {
        FfiConverterData.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeTypeSchema_lift(_ buf: RustBuffer) throws -> TypeSchema {
    return try FfiConverterTypeTypeSchema.lift(buf)
}

public func FfiConverterTypeTypeSchema_lower(_ value: TypeSchema) -> RustBuffer {
    return FfiConverterTypeTypeSchema.lower(value)
}


public struct UpdateCredentialsPayload {
    /**
     * Credential infos and the respective indices to insert them at
     */
    public var newCredInfos: [UInt8: CredentialDeploymentInfo]
    /**
     * List of credentials to remove
     */
    public var removeCredIds: [Bytes]
    /**
     * The new threshold of the account
     */
    public var newThreshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Credential infos and the respective indices to insert them at
         */
        newCredInfos: [UInt8: CredentialDeploymentInfo], 
        /**
         * List of credentials to remove
         */
        removeCredIds: [Bytes], 
        /**
         * The new threshold of the account
         */
        newThreshold: UInt8) {
        self.newCredInfos = newCredInfos
        self.removeCredIds = removeCredIds
        self.newThreshold = newThreshold
    }
}


extension UpdateCredentialsPayload: Equatable, Hashable {
    public static func ==(lhs: UpdateCredentialsPayload, rhs: UpdateCredentialsPayload) -> Bool {
        if lhs.newCredInfos != rhs.newCredInfos {
            return false
        }
        if lhs.removeCredIds != rhs.removeCredIds {
            return false
        }
        if lhs.newThreshold != rhs.newThreshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(newCredInfos)
        hasher.combine(removeCredIds)
        hasher.combine(newThreshold)
    }
}


public struct FfiConverterTypeUpdateCredentialsPayload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateCredentialsPayload {
        return
            try UpdateCredentialsPayload(
                newCredInfos: FfiConverterDictionaryUInt8TypeCredentialDeploymentInfo.read(from: &buf), 
                removeCredIds: FfiConverterSequenceTypeBytes.read(from: &buf), 
                newThreshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateCredentialsPayload, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt8TypeCredentialDeploymentInfo.write(value.newCredInfos, into: &buf)
        FfiConverterSequenceTypeBytes.write(value.removeCredIds, into: &buf)
        FfiConverterUInt8.write(value.newThreshold, into: &buf)
    }
}


public func FfiConverterTypeUpdateCredentialsPayload_lift(_ buf: RustBuffer) throws -> UpdateCredentialsPayload {
    return try FfiConverterTypeUpdateCredentialsPayload.lift(buf)
}

public func FfiConverterTypeUpdateCredentialsPayload_lower(_ value: UpdateCredentialsPayload) -> RustBuffer {
    return FfiConverterTypeUpdateCredentialsPayload.lower(value)
}


public struct UpdateCredentialsPayloadDeserializeResult {
    public var value: UpdateCredentialsPayload
    public var bytesRead: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        value: UpdateCredentialsPayload, 
        bytesRead: UInt64) {
        self.value = value
        self.bytesRead = bytesRead
    }
}


extension UpdateCredentialsPayloadDeserializeResult: Equatable, Hashable {
    public static func ==(lhs: UpdateCredentialsPayloadDeserializeResult, rhs: UpdateCredentialsPayloadDeserializeResult) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.bytesRead != rhs.bytesRead {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(bytesRead)
    }
}


public struct FfiConverterTypeUpdateCredentialsPayloadDeserializeResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateCredentialsPayloadDeserializeResult {
        return
            try UpdateCredentialsPayloadDeserializeResult(
                value: FfiConverterTypeUpdateCredentialsPayload.read(from: &buf), 
                bytesRead: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateCredentialsPayloadDeserializeResult, into buf: inout [UInt8]) {
        FfiConverterTypeUpdateCredentialsPayload.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.bytesRead, into: &buf)
    }
}


public func FfiConverterTypeUpdateCredentialsPayloadDeserializeResult_lift(_ buf: RustBuffer) throws -> UpdateCredentialsPayloadDeserializeResult {
    return try FfiConverterTypeUpdateCredentialsPayloadDeserializeResult.lift(buf)
}

public func FfiConverterTypeUpdateCredentialsPayloadDeserializeResult_lower(_ value: UpdateCredentialsPayloadDeserializeResult) -> RustBuffer {
    return FfiConverterTypeUpdateCredentialsPayloadDeserializeResult.lower(value)
}


/**
 * Public AKA verification key for a given scheme.
 * Currently the only supported value of `scheme_id` is "Ed25519".
 */
public struct VerifyKey {
    public var schemeId: String
    public var key: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        schemeId: String, 
        key: Bytes) {
        self.schemeId = schemeId
        self.key = key
    }
}


extension VerifyKey: Equatable, Hashable {
    public static func ==(lhs: VerifyKey, rhs: VerifyKey) -> Bool {
        if lhs.schemeId != rhs.schemeId {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(schemeId)
        hasher.combine(key)
    }
}


public struct FfiConverterTypeVerifyKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifyKey {
        return
            try VerifyKey(
                schemeId: FfiConverterString.read(from: &buf), 
                key: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: VerifyKey, into buf: inout [UInt8]) {
        FfiConverterString.write(value.schemeId, into: &buf)
        FfiConverterTypeBytes.write(value.key, into: &buf)
    }
}


public func FfiConverterTypeVerifyKey_lift(_ buf: RustBuffer) throws -> VerifyKey {
    return try FfiConverterTypeVerifyKey.lift(buf)
}

public func FfiConverterTypeVerifyKey_lower(_ value: VerifyKey) -> RustBuffer {
    return FfiConverterTypeVerifyKey.lower(value)
}


/**
 * Generic error while invoking FFI
 */
public enum ConcordiumWalletCryptoError {

    
    
    case CallFailed(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeConcordiumWalletCryptoError.lift(error)
    }
}


public struct FfiConverterTypeConcordiumWalletCryptoError: FfiConverterRustBuffer {
    typealias SwiftType = ConcordiumWalletCryptoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConcordiumWalletCryptoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CallFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConcordiumWalletCryptoError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .CallFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


extension ConcordiumWalletCryptoError: Equatable, Hashable {}

extension ConcordiumWalletCryptoError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the different contract module schema versions
 */
public enum ModuleSchemaVersion {
    
    case v0
    case v1
    case v2
    case v3
}

public struct FfiConverterTypeModuleSchemaVersion: FfiConverterRustBuffer {
    typealias SwiftType = ModuleSchemaVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModuleSchemaVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v0
        
        case 2: return .v1
        
        case 3: return .v2
        
        case 4: return .v3
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ModuleSchemaVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v0:
            writeInt(&buf, Int32(1))
        
        
        case .v1:
            writeInt(&buf, Int32(2))
        
        
        case .v2:
            writeInt(&buf, Int32(3))
        
        
        case .v3:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeModuleSchemaVersion_lift(_ buf: RustBuffer) throws -> ModuleSchemaVersion {
    return try FfiConverterTypeModuleSchemaVersion.lift(buf)
}

public func FfiConverterTypeModuleSchemaVersion_lower(_ value: ModuleSchemaVersion) -> RustBuffer {
    return FfiConverterTypeModuleSchemaVersion.lower(value)
}


extension ModuleSchemaVersion: Equatable, Hashable {}




/**
 * Describes errors happening while interacting with contract schemas
 */
public enum SchemaError {

    
    
    /**
     * Failed to convert value with schema
     */
    case Convert(message: String)
    
    /**
     * Failed parse the module schema
     */
    case ParseSchema(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeSchemaError.lift(error)
    }
}


public struct FfiConverterTypeSchemaError: FfiConverterRustBuffer {
    typealias SwiftType = SchemaError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SchemaError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Convert(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .ParseSchema(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SchemaError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Convert(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .ParseSchema(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


extension SchemaError: Equatable, Hashable {}

extension SchemaError: Error { }

fileprivate struct FfiConverterOptionTypeModuleSchemaVersion: FfiConverterRustBuffer {
    typealias SwiftType = ModuleSchemaVersion?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeModuleSchemaVersion.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeModuleSchemaVersion.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeBytes: FfiConverterRustBuffer {
    typealias SwiftType = [Bytes]

    public static func write(_ value: [Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBytes.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bytes] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bytes]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBytes.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryUInt8TypeCredentialDeploymentInfo: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: CredentialDeploymentInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterTypeCredentialDeploymentInfo.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: CredentialDeploymentInfo] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: CredentialDeploymentInfo]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterTypeCredentialDeploymentInfo.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryUInt8TypeVerifyKey: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: VerifyKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterTypeVerifyKey.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: VerifyKey] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: VerifyKey]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterTypeVerifyKey.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryUInt8TypeBytes: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterTypeBytes.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: Bytes] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: Bytes]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterTypeBytes.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: AnonymityRevokerInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeAnonymityRevokerInfo.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: AnonymityRevokerInfo] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: AnonymityRevokerInfo]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeAnonymityRevokerInfo.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryUInt32TypeArData: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: ArData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeArData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: ArData] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: ArData]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeArData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryUInt32TypeChainArData: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: ChainArData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeChainArData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: ChainArData] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: ChainArData]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeChainArData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeBytes: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeBytes.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bytes] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bytes]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeBytes.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bytes = Data
public struct FfiConverterTypeBytes: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bytes {
        return try FfiConverterData.read(from: &buf)
    }

    public static func write(_ value: Bytes, into buf: inout [UInt8]) {
        return FfiConverterData.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bytes {
        return try FfiConverterData.lift(value)
    }

    public static func lower(_ value: Bytes) -> RustBuffer {
        return FfiConverterData.lower(value)
    }
}


public func FfiConverterTypeBytes_lift(_ value: RustBuffer) throws -> Bytes {
    return try FfiConverterTypeBytes.lift(value)
}

public func FfiConverterTypeBytes_lower(_ value: Bytes) -> RustBuffer {
    return FfiConverterTypeBytes.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias MicroCCDAmount = UInt64
public struct FfiConverterTypeMicroCCDAmount: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MicroCCDAmount {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: MicroCCDAmount, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> MicroCCDAmount {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: MicroCCDAmount) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}


public func FfiConverterTypeMicroCCDAmount_lift(_ value: UInt64) throws -> MicroCCDAmount {
    return try FfiConverterTypeMicroCCDAmount.lift(value)
}

public func FfiConverterTypeMicroCCDAmount_lower(_ value: MicroCCDAmount) -> UInt64 {
    return FfiConverterTypeMicroCCDAmount.lower(value)
}

/**
 * Construct an account credential from the information contained in the provided parameters.
 */
public func accountCredential(params: AccountCredentialParameters) throws  -> AccountCredentialResult {
    return try  FfiConverterTypeAccountCredentialResult.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential(
        FfiConverterTypeAccountCredentialParameters.lower(params),$0)
}
    )
}
/**
 * Compute the attribute commitment randomness for the provided seed, identity indexes, credential counter, and attribute number.
 * Supported values for `network`: "Testnet", "Mainnet".
 */
public func accountCredentialAttributeCommitmentRandomness(seed: Bytes, network: String, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8, attribute: UInt8) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_attribute_commitment_randomness(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterString.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),
        FfiConverterUInt8.lower(attribute),$0)
}
    )
}
/**
 * Compute the hash of a new credential deployment to be signed by the account key derived for the credential.
 */
public func accountCredentialDeploymentHash(credential: AccountCredential, expiryUnixSecs: UInt64) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_deployment_hash(
        FfiConverterTypeAccountCredential.lower(credential),
        FfiConverterUInt64.lower(expiryUnixSecs),$0)
}
    )
}
/**
 * Serializes the credential deployment payload for submission as a "raw" payload to a node.
 */
public func accountCredentialDeploymentSignedPayload(credential: SignedAccountCredential) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_deployment_signed_payload(
        FfiConverterTypeSignedAccountCredential.lower(credential),$0)
}
    )
}
/**
 * Compute the credential ID for the provided seed, identity indexes, credential counter, and the chain's commitment key.
 * Supported values for `network`: "Testnet", "Mainnet".
 */
public func accountCredentialId(seed: Bytes, network: String, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8, commitmentKey: Bytes) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_id(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterString.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),
        FfiConverterTypeBytes.lower(commitmentKey),$0)
}
    )
}
/**
 * Compute the account credential public key for the provided seed, identity indexes, and credential counter.
 * Supported values for `network`: "Testnet", "Mainnet".
 */
public func accountCredentialPublicKey(seed: Bytes, network: String, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_public_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterString.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),$0)
}
    )
}
/**
 * Compute the account credential signing key for the provided seed, identity indexes, and credential counter.
 * Supported values for `network`: "Testnet", "Mainnet".
 */
public func accountCredentialSigningKey(seed: Bytes, network: String, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_signing_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterString.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),$0)
}
    )
}
/**
 * Attempt to create the encryption keys associated with an account at the given credential index
 */
public func decryptAmount(encryptedAmount: Bytes, encryptionSecretKey: Bytes) throws  -> MicroCCDAmount {
    return try  FfiConverterTypeMicroCCDAmount.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_decrypt_amount(
        FfiConverterTypeBytes.lower(encryptedAmount),
        FfiConverterTypeBytes.lower(encryptionSecretKey),$0)
}
    )
}
/**
 * Attempt to deserialize SecToPubTransferData from the supplied bytes. This will fail if the number of bytes does not exactly match the expected number.
 */
public func deserializeSecToPubTransferData(bytes: Data) throws  -> SecToPubTransferDataDeserializeResult {
    return try  FfiConverterTypeSecToPubTransferDataDeserializeResult.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_deserialize_sec_to_pub_transfer_data(
        FfiConverterData.lower(bytes),$0)
}
    )
}
/**
 * Deserialize the provided value into the JSON representation of a type corresponding to the provided `schema`
 */
public func deserializeTypeValue(value: Data, schema: TypeSchema) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_deserialize_type_value(
        FfiConverterData.lower(value),
        FfiConverterTypeTypeSchema.lower(schema),$0)
}
    )
}
/**
 * Attempt to deserialize UpdateCredentialsPayloadDeserializeResult from the supplied bytes. This will fail if the number of bytes does not exactly match the expected number.
 */
public func deserializeUpdateCredentialsPayload(bytes: Data) throws  -> UpdateCredentialsPayloadDeserializeResult {
    return try  FfiConverterTypeUpdateCredentialsPayloadDeserializeResult.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_deserialize_update_credentials_payload(
        FfiConverterData.lower(bytes),$0)
}
    )
}
/**
 * Returns the schema template for the given `TypeSchema`
 */
public func displayTypeSchemaTemplate(schema: TypeSchema) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_display_type_schema_template(
        FfiConverterTypeTypeSchema.lower(schema),$0)
}
    )
}
/**
 * Create a set of baker keys
 */
public func generateBakerKeys()  -> BakerKeyPairs {
    return try!  FfiConverterTypeBakerKeyPairs.lift(
        try! rustCall() {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_generate_baker_keys($0)
}
    )
}
/**
 * Attempt to create the encryption keys associated with an account at the given credential index
 */
public func getEncryptionKeys(globalContext: GlobalContext, prfKey: Bytes, credentialIndex: UInt8) throws  -> EncryptionKeys {
    return try  FfiConverterTypeEncryptionKeys.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_encryption_keys(
        FfiConverterTypeGlobalContext.lower(globalContext),
        FfiConverterTypeBytes.lower(prfKey),
        FfiConverterUInt8.lower(credentialIndex),$0)
}
    )
}
/**
 * Get the `TypeSchema` for events emitted by a contract
 */
public func getEventSchema(schema: ModuleSchema, contractName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_event_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),$0)
}
    )
}
/**
 * Get the `TypeSchema` for an error of the init function of a contract
 */
public func getInitErrorSchema(schema: ModuleSchema, contractName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_init_error_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),$0)
}
    )
}
/**
 * Get the `TypeSchema` for a parameter of the init function of a contract
 */
public func getInitParameterSchema(schema: ModuleSchema, contractName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_init_parameter_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),$0)
}
    )
}
/**
 * Get the `TypeSchema` for an error of a given receive function
 */
public func getReceiveErrorSchema(schema: ModuleSchema, contractName: String, functionName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_receive_error_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),
        FfiConverterString.lower(functionName),$0)
}
    )
}
/**
 * Get the `TypeSchema` for a parameter of a given receive function
 */
public func getReceiveParameterSchema(schema: ModuleSchema, contractName: String, functionName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_receive_parameter_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),
        FfiConverterString.lower(functionName),$0)
}
    )
}
/**
 * Get the `TypeSchema` for a return value of a given receive function
 */
public func getReceiveReturnValueSchema(schema: ModuleSchema, contractName: String, functionName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_receive_return_value_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),
        FfiConverterString.lower(functionName),$0)
}
    )
}
/**
 * Compute the signature blinding randomness for the provided seed and identity indexes.
 * Supported values for `network`: "Testnet", "Mainnet".
 */
public func identityAttributesSignatureBlindingRandomness(seed: Bytes, network: String, identityProviderId: UInt32, identityIndex: UInt32) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_attributes_signature_blinding_randomness(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterString.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),$0)
}
    )
}
/**
 * Compute the IdCredSec for the provided seed and identity indexes.
 * Supported values for `network`: "Testnet", "Mainnet".
 */
public func identityCredSec(seed: Bytes, network: String, identityProviderId: UInt32, identityIndex: UInt32) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_cred_sec(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterString.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),$0)
}
    )
}
/**
 * Compute an identity issuance request for the identity contained in the provided parameters.
 * The result is a versioned `PreIdentityObject` encoded as JSON,
 * which is the format expected by the identity provider's issuance endpoint.
 */
public func identityIssuanceRequestJson(params: IdentityIssuanceRequestParameters) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_issuance_request_json(
        FfiConverterTypeIdentityIssuanceRequestParameters.lower(params),$0)
}
    )
}
/**
 * Compute the PRF-key for the provided seed and identity indexes.
 * Supported values for `network`: "Testnet", "Mainnet".
 */
public func identityPrfKey(seed: Bytes, network: String, identityProviderId: UInt32, identityIndex: UInt32) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_prf_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterString.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),$0)
}
    )
}
/**
 * Construct an identity recovery request for the identity contained in the provided parameters.
 * The result encoded as JSON in the format expected by the identity provider's recovery endpoint.
 */
public func identityRecoveryRequestJson(params: IdentityRecoveryRequestParameters) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_recovery_request_json(
        FfiConverterTypeIdentityRecoveryRequestParameters.lower(params),$0)
}
    )
}
/**
 * Attempt to create a BakerKeysPayload for the account and associated baker keys
 */
public func makeConfigureBakerKeysPayload(accountBase58: String, bakerKeys: BakerKeyPairs) throws  -> BakerKeysPayload {
    return try  FfiConverterTypeBakerKeysPayload.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_make_configure_baker_keys_payload(
        FfiConverterString.lower(accountBase58),
        FfiConverterTypeBakerKeyPairs.lower(bakerKeys),$0)
}
    )
}
/**
 * Construct the payload for a TransferToPublic transaction. The `to_transfer` amount is specififed in microCCD.
 */
public func secToPubTransferData(ctx: GlobalContext, senderSecretKey: Bytes, inputAmount: InputEncryptedAmount, toTransfer: MicroCCDAmount) throws  -> SecToPubTransferData {
    return try  FfiConverterTypeSecToPubTransferData.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_sec_to_pub_transfer_data(
        FfiConverterTypeGlobalContext.lower(ctx),
        FfiConverterTypeBytes.lower(senderSecretKey),
        FfiConverterTypeInputEncryptedAmount.lower(inputAmount),
        FfiConverterTypeMicroCCDAmount.lower(toTransfer),$0)
}
    )
}
/**
 * Attempt to serialize CredentialDeploymentInfo into bytes. This will fail if any of the raw hex representations do not match the corresponding types in concordium-base
 */
public func serializeCredentialDeploymentInfo(credInfo: CredentialDeploymentInfo) throws  -> Data {
    return try  FfiConverterData.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_serialize_credential_deployment_info(
        FfiConverterTypeCredentialDeploymentInfo.lower(credInfo),$0)
}
    )
}
/**
 * Serialize the provided value from the JSON representation of a type corresponding to the provided `schema`
 */
public func serializeTypeValue(json: String, schema: TypeSchema) throws  -> Data {
    return try  FfiConverterData.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_serialize_type_value(
        FfiConverterString.lower(json),
        FfiConverterTypeTypeSchema.lower(schema),$0)
}
    )
}
/**
 * Compute the encoded verifiable credential backup encryption key for the provided seed.
 * Supported values for `network`: "Testnet", "Mainnet".
 */
public func verifiableCredentialBackupEncryptionKey(seed: Bytes, network: String) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_backup_encryption_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterString.lower(network),$0)
}
    )
}
/**
 * Compute the public key for the provided seed, issuer indexes, and verifiable credential index.
 * Supported values for `network`: "Testnet", "Mainnet".
 */
public func verifiableCredentialPublicKey(seed: Bytes, network: String, issuerIndex: UInt64, issuerSubindex: UInt64, verifiableCredentialIndex: UInt32) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_public_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterString.lower(network),
        FfiConverterUInt64.lower(issuerIndex),
        FfiConverterUInt64.lower(issuerSubindex),
        FfiConverterUInt32.lower(verifiableCredentialIndex),$0)
}
    )
}
/**
 * Compute the signing key for the provided seed, issuer indexes, and verifiable credential index.
 * Supported values for `network`: "Testnet", "Mainnet".
 */
public func verifiableCredentialSigningKey(seed: Bytes, network: String, issuerIndex: UInt64, issuerSubindex: UInt64, verifiableCredentialIndex: UInt32) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_signing_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterString.lower(network),
        FfiConverterUInt64.lower(issuerIndex),
        FfiConverterUInt64.lower(issuerSubindex),
        FfiConverterUInt32.lower(verifiableCredentialIndex),$0)
}
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_concordium_wallet_crypto_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential() != 28347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_attribute_commitment_randomness() != 5266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_deployment_hash() != 17693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_deployment_signed_payload() != 42141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_id() != 35467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_public_key() != 21709) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_signing_key() != 116) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_decrypt_amount() != 53254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_deserialize_sec_to_pub_transfer_data() != 15687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_deserialize_type_value() != 39476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_deserialize_update_credentials_payload() != 65247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_display_type_schema_template() != 53699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_generate_baker_keys() != 22656) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_encryption_keys() != 21403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_event_schema() != 34116) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_init_error_schema() != 41457) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_init_parameter_schema() != 54176) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_receive_error_schema() != 54098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_receive_parameter_schema() != 54281) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_receive_return_value_schema() != 56848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_attributes_signature_blinding_randomness() != 51381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_cred_sec() != 9447) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_issuance_request_json() != 28061) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_prf_key() != 34345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_recovery_request_json() != 33579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_make_configure_baker_keys_payload() != 25683) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_sec_to_pub_transfer_data() != 40421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_serialize_credential_deployment_info() != 61448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_serialize_type_value() != 39554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_backup_encryption_key() != 58160) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_public_key() != 57213) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_signing_key() != 59666) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}