// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(cryptoFFI)
import cryptoFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_concordium_wallet_crypto_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_concordium_wallet_crypto_uniffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureConcordiumWalletCryptoUniffiInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
// Initial value and increment amount for handles. 
// These ensure that SWIFT handles always have the lowest bit set
fileprivate let UNIFFI_HANDLEMAP_INITIAL: UInt64 = 1
fileprivate let UNIFFI_HANDLEMAP_DELTA: UInt64 = 2

fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = UNIFFI_HANDLEMAP_INITIAL

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            return doInsert(obj)
        }
    }

    // Low-level insert function, this assumes `lock` is held.
    private func doInsert(_ obj: T) -> UInt64 {
        let handle = currentHandle
        currentHandle += UNIFFI_HANDLEMAP_DELTA
        map[handle] = obj
        return handle
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

     func clone(handle: UInt64) throws -> UInt64 {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return doInsert(obj)
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Date {
        let seconds: Int64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        if seconds >= 0 {
            let delta = Double(seconds) + (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        } else {
            let delta = Double(seconds) - (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        }
    }

    public static func write(_ value: Date, into buf: inout [UInt8]) {
        var delta = value.timeIntervalSince1970
        var sign: Int64 = 1
        if delta < 0 {
            // The nanoseconds portion of the epoch offset must always be
            // positive, to simplify the calculation we will use the absolute
            // value of the offset.
            sign = -1
            delta = -delta
        }
        if delta.rounded(.down) > Double(Int64.max) {
            fatalError("Timestamp overflow, exceeds max bounds supported by Uniffi")
        }
        let seconds = Int64(delta)
        let nanoseconds = UInt32((delta - Double(seconds)) * 1.0e9)
        writeInt(&buf, sign * seconds)
        writeInt(&buf, nanoseconds)
    }
}


/**
 * Private and public data chosen by the credential holder before the
 * interaction with the identity provider. 
 */
public struct AccCredentialInfo: Equatable, Hashable {
    public var credHolderInfo: CredentialHolderInfo
    public var prfKey: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(credHolderInfo: CredentialHolderInfo, prfKey: Bytes) {
        self.credHolderInfo = credHolderInfo
        self.prfKey = prfKey
    }

    

    
}

#if compiler(>=6)
extension AccCredentialInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccCredentialInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccCredentialInfo {
        return
            try AccCredentialInfo(
                credHolderInfo: FfiConverterTypeCredentialHolderInfo.read(from: &buf), 
                prfKey: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: AccCredentialInfo, into buf: inout [UInt8]) {
        FfiConverterTypeCredentialHolderInfo.write(value.credHolderInfo, into: &buf)
        FfiConverterTypeBytes.write(value.prfKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccCredentialInfo_lift(_ buf: RustBuffer) throws -> AccCredentialInfo {
    return try FfiConverterTypeAccCredentialInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccCredentialInfo_lower(_ value: AccCredentialInfo) -> RustBuffer {
    return FfiConverterTypeAccCredentialInfo.lower(value)
}


/**
 * Account based credentials. This contains almost
 * all the information needed to verify it, except the public commitments.
 */
public struct AccountBasedCredentialV1: Equatable, Hashable {
    public var issuer: UInt32
    public var subject: AccountCredentialSubject
    public var proofs: ConcordiumCredentialZkProofs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(issuer: UInt32, subject: AccountCredentialSubject, proofs: ConcordiumCredentialZkProofs) {
        self.issuer = issuer
        self.subject = subject
        self.proofs = proofs
    }

    

    
}

#if compiler(>=6)
extension AccountBasedCredentialV1: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountBasedCredentialV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountBasedCredentialV1 {
        return
            try AccountBasedCredentialV1(
                issuer: FfiConverterUInt32.read(from: &buf), 
                subject: FfiConverterTypeAccountCredentialSubject.read(from: &buf), 
                proofs: FfiConverterTypeConcordiumCredentialZKProofs.read(from: &buf)
        )
    }

    public static func write(_ value: AccountBasedCredentialV1, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.issuer, into: &buf)
        FfiConverterTypeAccountCredentialSubject.write(value.subject, into: &buf)
        FfiConverterTypeConcordiumCredentialZKProofs.write(value.proofs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountBasedCredentialV1_lift(_ buf: RustBuffer) throws -> AccountBasedCredentialV1 {
    return try FfiConverterTypeAccountBasedCredentialV1.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountBasedCredentialV1_lower(_ value: AccountBasedCredentialV1) -> RustBuffer {
    return FfiConverterTypeAccountBasedCredentialV1.lower(value)
}


/**
 * Claims about a single account based subject. Accounts are on-chain credentials
 * deployed from identity credentials.
 */
public struct AccountBasedSubjectClaims: Equatable, Hashable {
    /**
     * Network on which the account exists
     */
    public var network: Network
    /**
     * Identity provider which issued the credentials
     */
    public var issuer: UInt32
    /**
     * Account registration id
     */
    public var credId: Bytes
    /**
     * Attribute statements
     */
    public var statements: [AtomicStatementV1]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Network on which the account exists
         */network: Network, 
        /**
         * Identity provider which issued the credentials
         */issuer: UInt32, 
        /**
         * Account registration id
         */credId: Bytes, 
        /**
         * Attribute statements
         */statements: [AtomicStatementV1]) {
        self.network = network
        self.issuer = issuer
        self.credId = credId
        self.statements = statements
    }

    

    
}

#if compiler(>=6)
extension AccountBasedSubjectClaims: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountBasedSubjectClaims: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountBasedSubjectClaims {
        return
            try AccountBasedSubjectClaims(
                network: FfiConverterTypeNetwork.read(from: &buf), 
                issuer: FfiConverterUInt32.read(from: &buf), 
                credId: FfiConverterTypeBytes.read(from: &buf), 
                statements: FfiConverterSequenceTypeAtomicStatementV1.read(from: &buf)
        )
    }

    public static func write(_ value: AccountBasedSubjectClaims, into buf: inout [UInt8]) {
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterUInt32.write(value.issuer, into: &buf)
        FfiConverterTypeBytes.write(value.credId, into: &buf)
        FfiConverterSequenceTypeAtomicStatementV1.write(value.statements, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountBasedSubjectClaims_lift(_ buf: RustBuffer) throws -> AccountBasedSubjectClaims {
    return try FfiConverterTypeAccountBasedSubjectClaims.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountBasedSubjectClaims_lower(_ value: AccountBasedSubjectClaims) -> RustBuffer {
    return FfiConverterTypeAccountBasedSubjectClaims.lower(value)
}


/**
 * An account credential containing proofs without signatures.
 * To deploy a credential, an object of this type is
 * hashed using `account_credential_deployment_hash`
 * which is signed using the key derived for the credential.
 * The results are collected into a `SignedAccountCredential`
 * and serialized using `account_credential_deployment_signed_payload`.
 * The result of this call can be submitted to the chain.
 */
public struct AccountCredential: Equatable, Hashable {
    /**
     * List of anonymity revokers which can revoke the identity.
     * The order is important since it is the same order as that signed by the identity provider,
     * and permuting the list will invalidate the signature from the identity provider.
     */
    public var arData: [UInt32: ChainArData]
    /**
     * Credential registration ID of the credential.
     */
    public var credId: Bytes
    /**
     * Credential keys (i.e. account holder keys).
     */
    public var credentialPublicKeys: CredentialPublicKeys
    /**
     * Identity of the identity provider who signed the identity object
     * from which this credential is derived.
     */
    public var ipIdentity: UInt32
    /**
     * Policy of this credential object.
     */
    public var policy: Policy
    public var proofs: Proofs
    /**
     * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
     */
    public var revocationThreshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * List of anonymity revokers which can revoke the identity.
         * The order is important since it is the same order as that signed by the identity provider,
         * and permuting the list will invalidate the signature from the identity provider.
         */arData: [UInt32: ChainArData], 
        /**
         * Credential registration ID of the credential.
         */credId: Bytes, 
        /**
         * Credential keys (i.e. account holder keys).
         */credentialPublicKeys: CredentialPublicKeys, 
        /**
         * Identity of the identity provider who signed the identity object
         * from which this credential is derived.
         */ipIdentity: UInt32, 
        /**
         * Policy of this credential object.
         */policy: Policy, proofs: Proofs, 
        /**
         * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
         */revocationThreshold: UInt8) {
        self.arData = arData
        self.credId = credId
        self.credentialPublicKeys = credentialPublicKeys
        self.ipIdentity = ipIdentity
        self.policy = policy
        self.proofs = proofs
        self.revocationThreshold = revocationThreshold
    }

    

    
}

#if compiler(>=6)
extension AccountCredential: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredential {
        return
            try AccountCredential(
                arData: FfiConverterDictionaryUInt32TypeChainArData.read(from: &buf), 
                credId: FfiConverterTypeBytes.read(from: &buf), 
                credentialPublicKeys: FfiConverterTypeCredentialPublicKeys.read(from: &buf), 
                ipIdentity: FfiConverterUInt32.read(from: &buf), 
                policy: FfiConverterTypePolicy.read(from: &buf), 
                proofs: FfiConverterTypeProofs.read(from: &buf), 
                revocationThreshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: AccountCredential, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt32TypeChainArData.write(value.arData, into: &buf)
        FfiConverterTypeBytes.write(value.credId, into: &buf)
        FfiConverterTypeCredentialPublicKeys.write(value.credentialPublicKeys, into: &buf)
        FfiConverterUInt32.write(value.ipIdentity, into: &buf)
        FfiConverterTypePolicy.write(value.policy, into: &buf)
        FfiConverterTypeProofs.write(value.proofs, into: &buf)
        FfiConverterUInt8.write(value.revocationThreshold, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountCredential_lift(_ buf: RustBuffer) throws -> AccountCredential {
    return try FfiConverterTypeAccountCredential.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountCredential_lower(_ value: AccountCredential) -> RustBuffer {
    return FfiConverterTypeAccountCredential.lower(value)
}


/**
 * Parameter object for `account_credential`.
 */
public struct AccountCredentialParameters: Equatable, Hashable {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var arsInfos: [UInt32: AnonymityRevokerInfo]
    public var idObject: IdentityObject
    public var revealedAttributes: [AttributeTag]
    public var credNumber: UInt8
    public var idCredSec: Bytes
    public var prfKey: Bytes
    public var blindingRandomness: Bytes
    public var attributeRandomness: [AttributeTag: Bytes]
    public var credentialPublicKeys: CredentialPublicKeys

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ipInfo: IdentityProviderInfo, globalContext: GlobalContext, arsInfos: [UInt32: AnonymityRevokerInfo], idObject: IdentityObject, revealedAttributes: [AttributeTag], credNumber: UInt8, idCredSec: Bytes, prfKey: Bytes, blindingRandomness: Bytes, attributeRandomness: [AttributeTag: Bytes], credentialPublicKeys: CredentialPublicKeys) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.arsInfos = arsInfos
        self.idObject = idObject
        self.revealedAttributes = revealedAttributes
        self.credNumber = credNumber
        self.idCredSec = idCredSec
        self.prfKey = prfKey
        self.blindingRandomness = blindingRandomness
        self.attributeRandomness = attributeRandomness
        self.credentialPublicKeys = credentialPublicKeys
    }

    

    
}

#if compiler(>=6)
extension AccountCredentialParameters: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountCredentialParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredentialParameters {
        return
            try AccountCredentialParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf), 
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf), 
                arsInfos: FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.read(from: &buf), 
                idObject: FfiConverterTypeIdentityObject.read(from: &buf), 
                revealedAttributes: FfiConverterSequenceTypeAttributeTag.read(from: &buf), 
                credNumber: FfiConverterUInt8.read(from: &buf), 
                idCredSec: FfiConverterTypeBytes.read(from: &buf), 
                prfKey: FfiConverterTypeBytes.read(from: &buf), 
                blindingRandomness: FfiConverterTypeBytes.read(from: &buf), 
                attributeRandomness: FfiConverterDictionaryTypeAttributeTagTypeBytes.read(from: &buf), 
                credentialPublicKeys: FfiConverterTypeCredentialPublicKeys.read(from: &buf)
        )
    }

    public static func write(_ value: AccountCredentialParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.write(value.arsInfos, into: &buf)
        FfiConverterTypeIdentityObject.write(value.idObject, into: &buf)
        FfiConverterSequenceTypeAttributeTag.write(value.revealedAttributes, into: &buf)
        FfiConverterUInt8.write(value.credNumber, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSec, into: &buf)
        FfiConverterTypeBytes.write(value.prfKey, into: &buf)
        FfiConverterTypeBytes.write(value.blindingRandomness, into: &buf)
        FfiConverterDictionaryTypeAttributeTagTypeBytes.write(value.attributeRandomness, into: &buf)
        FfiConverterTypeCredentialPublicKeys.write(value.credentialPublicKeys, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountCredentialParameters_lift(_ buf: RustBuffer) throws -> AccountCredentialParameters {
    return try FfiConverterTypeAccountCredentialParameters.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountCredentialParameters_lower(_ value: AccountCredentialParameters) -> RustBuffer {
    return FfiConverterTypeAccountCredentialParameters.lower(value)
}


/**
 * Subject of account based credential
 */
public struct AccountCredentialSubject: Equatable, Hashable {
    public var network: Network
    public var credId: Bytes
    public var statements: [AtomicStatementV1]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(network: Network, credId: Bytes, statements: [AtomicStatementV1]) {
        self.network = network
        self.credId = credId
        self.statements = statements
    }

    

    
}

#if compiler(>=6)
extension AccountCredentialSubject: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountCredentialSubject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredentialSubject {
        return
            try AccountCredentialSubject(
                network: FfiConverterTypeNetwork.read(from: &buf), 
                credId: FfiConverterTypeBytes.read(from: &buf), 
                statements: FfiConverterSequenceTypeAtomicStatementV1.read(from: &buf)
        )
    }

    public static func write(_ value: AccountCredentialSubject, into buf: inout [UInt8]) {
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterTypeBytes.write(value.credId, into: &buf)
        FfiConverterSequenceTypeAtomicStatementV1.write(value.statements, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountCredentialSubject_lift(_ buf: RustBuffer) throws -> AccountCredentialSubject {
    return try FfiConverterTypeAccountCredentialSubject.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountCredentialSubject_lower(_ value: AccountCredentialSubject) -> RustBuffer {
    return FfiConverterTypeAccountCredentialSubject.lower(value)
}


/**
 * The result of a new credential being created using the function `account_credential`.
 */
public struct AccountCredentialWithRandomness: Equatable, Hashable {
    public var credential: AccountCredential
    public var randomness: Randomness

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(credential: AccountCredential, randomness: Randomness) {
        self.credential = credential
        self.randomness = randomness
    }

    

    
}

#if compiler(>=6)
extension AccountCredentialWithRandomness: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountCredentialWithRandomness: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredentialWithRandomness {
        return
            try AccountCredentialWithRandomness(
                credential: FfiConverterTypeAccountCredential.read(from: &buf), 
                randomness: FfiConverterTypeRandomness.read(from: &buf)
        )
    }

    public static func write(_ value: AccountCredentialWithRandomness, into buf: inout [UInt8]) {
        FfiConverterTypeAccountCredential.write(value.credential, into: &buf)
        FfiConverterTypeRandomness.write(value.randomness, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountCredentialWithRandomness_lift(_ buf: RustBuffer) throws -> AccountCredentialWithRandomness {
    return try FfiConverterTypeAccountCredentialWithRandomness.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountCredentialWithRandomness_lower(_ value: AccountCredentialWithRandomness) -> RustBuffer {
    return FfiConverterTypeAccountCredentialWithRandomness.lower(value)
}


/**
 * A pair of a statement and a proof for an account credential statement.
 */
public struct AccountStatementWithProof: Equatable, Hashable {
    public var statement: AtomicIdentityStatement
    public var proof: AtomicIdentityProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statement: AtomicIdentityStatement, proof: AtomicIdentityProof) {
        self.statement = statement
        self.proof = proof
    }

    

    
}

#if compiler(>=6)
extension AccountStatementWithProof: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountStatementWithProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountStatementWithProof {
        return
            try AccountStatementWithProof(
                statement: FfiConverterTypeAtomicIdentityStatement.read(from: &buf), 
                proof: FfiConverterTypeAtomicIdentityProof.read(from: &buf)
        )
    }

    public static func write(_ value: AccountStatementWithProof, into buf: inout [UInt8]) {
        FfiConverterTypeAtomicIdentityStatement.write(value.statement, into: &buf)
        FfiConverterTypeAtomicIdentityProof.write(value.proof, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountStatementWithProof_lift(_ buf: RustBuffer) throws -> AccountStatementWithProof {
    return try FfiConverterTypeAccountStatementWithProof.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountStatementWithProof_lower(_ value: AccountStatementWithProof) -> RustBuffer {
    return FfiConverterTypeAccountStatementWithProof.lower(value)
}


/**
 * Information on an anonymity revoker held by the identity provider.
 */
public struct AnonymityRevokerInfo: Equatable, Hashable {
    /**
     * Unique identifier of the anonymity revoker.
     */
    public var identity: UInt32
    /**
     * Description of the anonymity revoker (e.g. name, contact number).
     */
    public var description: Description
    /**
     * Elgamal encryption key of the anonymity revoker.
     */
    public var publicKey: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier of the anonymity revoker.
         */identity: UInt32, 
        /**
         * Description of the anonymity revoker (e.g. name, contact number).
         */description: Description, 
        /**
         * Elgamal encryption key of the anonymity revoker.
         */publicKey: Bytes) {
        self.identity = identity
        self.description = description
        self.publicKey = publicKey
    }

    

    
}

#if compiler(>=6)
extension AnonymityRevokerInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnonymityRevokerInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnonymityRevokerInfo {
        return
            try AnonymityRevokerInfo(
                identity: FfiConverterUInt32.read(from: &buf), 
                description: FfiConverterTypeDescription.read(from: &buf), 
                publicKey: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: AnonymityRevokerInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.identity, into: &buf)
        FfiConverterTypeDescription.write(value.description, into: &buf)
        FfiConverterTypeBytes.write(value.publicKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnonymityRevokerInfo_lift(_ buf: RustBuffer) throws -> AnonymityRevokerInfo {
    return try FfiConverterTypeAnonymityRevokerInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnonymityRevokerInfo_lower(_ value: AnonymityRevokerInfo) -> RustBuffer {
    return FfiConverterTypeAnonymityRevokerInfo.lower(value)
}


/**
 * The data relating to a single anonymity revoker
 * sent by the account holder to the identity provider.
 * Typically the account holder will send a vector of these.
 */
public struct ArData: Equatable, Hashable {
    /**
     * Encryption in chunks (in little endian) of the PRF key share.
     */
    public var encPrfKeyShare: Bytes
    /**
     * Response in the proof that the computed commitment to the share
     * contains the same value as the encryption.
     * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
     */
    public var proofComEncEq: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Encryption in chunks (in little endian) of the PRF key share.
         */encPrfKeyShare: Bytes, 
        /**
         * Response in the proof that the computed commitment to the share
         * contains the same value as the encryption.
         * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
         */proofComEncEq: Bytes) {
        self.encPrfKeyShare = encPrfKeyShare
        self.proofComEncEq = proofComEncEq
    }

    

    
}

#if compiler(>=6)
extension ArData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArData {
        return
            try ArData(
                encPrfKeyShare: FfiConverterTypeBytes.read(from: &buf), 
                proofComEncEq: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: ArData, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.encPrfKeyShare, into: &buf)
        FfiConverterTypeBytes.write(value.proofComEncEq, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArData_lift(_ buf: RustBuffer) throws -> ArData {
    return try FfiConverterTypeArData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArData_lower(_ value: ArData) -> RustBuffer {
    return FfiConverterTypeArData.lower(value)
}


/**
 * Collection of anonymity revokers.
 */
public struct ArInfos: Equatable, Hashable {
    public var anonymityRevokers: [UInt32: AnonymityRevokerInfo]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(anonymityRevokers: [UInt32: AnonymityRevokerInfo]) {
        self.anonymityRevokers = anonymityRevokers
    }

    

    
}

#if compiler(>=6)
extension ArInfos: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArInfos: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArInfos {
        return
            try ArInfos(
                anonymityRevokers: FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.read(from: &buf)
        )
    }

    public static func write(_ value: ArInfos, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.write(value.anonymityRevokers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArInfos_lift(_ buf: RustBuffer) throws -> ArInfos {
    return try FfiConverterTypeArInfos.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArInfos_lower(_ value: ArInfos) -> RustBuffer {
    return FfiConverterTypeArInfos.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * in a range. The statement is that the attribute value lies in `[lower,
 * upper)` in the scalar field.
 */
public struct AttributeInRangeIdentityStatement: Equatable, Hashable {
    /**
     * The attribute that the verifier wants the user to prove is in a range.
     */
    public var attributeTag: AttributeTag
    /**
     * The lower bound on the range.
     */
    public var lower: String
    /**
     * The upper bound of the range.
     */
    public var upper: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to prove is in a range.
         */attributeTag: AttributeTag, 
        /**
         * The lower bound on the range.
         */lower: String, 
        /**
         * The upper bound of the range.
         */upper: String) {
        self.attributeTag = attributeTag
        self.lower = lower
        self.upper = upper
    }

    

    
}

#if compiler(>=6)
extension AttributeInRangeIdentityStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeInRangeIdentityStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeInRangeIdentityStatement {
        return
            try AttributeInRangeIdentityStatement(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf), 
                lower: FfiConverterString.read(from: &buf), 
                upper: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeInRangeIdentityStatement, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
        FfiConverterString.write(value.lower, into: &buf)
        FfiConverterString.write(value.upper, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInRangeIdentityStatement_lift(_ buf: RustBuffer) throws -> AttributeInRangeIdentityStatement {
    return try FfiConverterTypeAttributeInRangeIdentityStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInRangeIdentityStatement_lower(_ value: AttributeInRangeIdentityStatement) -> RustBuffer {
    return FfiConverterTypeAttributeInRangeIdentityStatement.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * in a range. The statement is that the attribute value lies in `[lower,
 * upper)` in the scalar field.
 */
public struct AttributeInRangeIdentityStatementV1: Equatable, Hashable {
    /**
     * The attribute that the verifier wants the user to prove is in a range.
     */
    public var attributeTag: AttributeTag
    /**
     * The lower bound on the range.
     */
    public var lower: Web3IdAttribute
    /**
     * The upper bound of the range.
     */
    public var upper: Web3IdAttribute

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to prove is in a range.
         */attributeTag: AttributeTag, 
        /**
         * The lower bound on the range.
         */lower: Web3IdAttribute, 
        /**
         * The upper bound of the range.
         */upper: Web3IdAttribute) {
        self.attributeTag = attributeTag
        self.lower = lower
        self.upper = upper
    }

    

    
}

#if compiler(>=6)
extension AttributeInRangeIdentityStatementV1: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeInRangeIdentityStatementV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeInRangeIdentityStatementV1 {
        return
            try AttributeInRangeIdentityStatementV1(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf), 
                lower: FfiConverterTypeWeb3IdAttribute.read(from: &buf), 
                upper: FfiConverterTypeWeb3IdAttribute.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeInRangeIdentityStatementV1, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
        FfiConverterTypeWeb3IdAttribute.write(value.lower, into: &buf)
        FfiConverterTypeWeb3IdAttribute.write(value.upper, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInRangeIdentityStatementV1_lift(_ buf: RustBuffer) throws -> AttributeInRangeIdentityStatementV1 {
    return try FfiConverterTypeAttributeInRangeIdentityStatementV1.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInRangeIdentityStatementV1_lower(_ value: AttributeInRangeIdentityStatementV1) -> RustBuffer {
    return FfiConverterTypeAttributeInRangeIdentityStatementV1.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * in a range. The statement is that the attribute value lies in `[lower,
 * upper)` in the scalar field.
 */
public struct AttributeInRangeWeb3IdStatement: Equatable, Hashable {
    /**
     * The attribute that the verifier wants the user to prove is in a range.
     */
    public var attributeTag: String
    /**
     * The lower bound on the range.
     */
    public var lower: Web3IdAttribute
    /**
     * The upper bound of the range.
     */
    public var upper: Web3IdAttribute

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to prove is in a range.
         */attributeTag: String, 
        /**
         * The lower bound on the range.
         */lower: Web3IdAttribute, 
        /**
         * The upper bound of the range.
         */upper: Web3IdAttribute) {
        self.attributeTag = attributeTag
        self.lower = lower
        self.upper = upper
    }

    

    
}

#if compiler(>=6)
extension AttributeInRangeWeb3IdStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeInRangeWeb3IdStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeInRangeWeb3IdStatement {
        return
            try AttributeInRangeWeb3IdStatement(
                attributeTag: FfiConverterString.read(from: &buf), 
                lower: FfiConverterTypeWeb3IdAttribute.read(from: &buf), 
                upper: FfiConverterTypeWeb3IdAttribute.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeInRangeWeb3IdStatement, into buf: inout [UInt8]) {
        FfiConverterString.write(value.attributeTag, into: &buf)
        FfiConverterTypeWeb3IdAttribute.write(value.lower, into: &buf)
        FfiConverterTypeWeb3IdAttribute.write(value.upper, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInRangeWeb3IdStatement_lift(_ buf: RustBuffer) throws -> AttributeInRangeWeb3IdStatement {
    return try FfiConverterTypeAttributeInRangeWeb3IdStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInRangeWeb3IdStatement_lower(_ value: AttributeInRangeWeb3IdStatement) -> RustBuffer {
    return FfiConverterTypeAttributeInRangeWeb3IdStatement.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * in a set of attributes.
 */
public struct AttributeInSetIdentityStatement: Equatable, Hashable {
    /**
     * The attribute that the verifier wants the user prove lies in a set.
     */
    public var attributeTag: AttributeTag
    /**
     * The set that the attribute should lie in.
     */
    public var set: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user prove lies in a set.
         */attributeTag: AttributeTag, 
        /**
         * The set that the attribute should lie in.
         */set: [String]) {
        self.attributeTag = attributeTag
        self.set = set
    }

    

    
}

#if compiler(>=6)
extension AttributeInSetIdentityStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeInSetIdentityStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeInSetIdentityStatement {
        return
            try AttributeInSetIdentityStatement(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf), 
                set: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeInSetIdentityStatement, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
        FfiConverterSequenceString.write(value.set, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInSetIdentityStatement_lift(_ buf: RustBuffer) throws -> AttributeInSetIdentityStatement {
    return try FfiConverterTypeAttributeInSetIdentityStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInSetIdentityStatement_lower(_ value: AttributeInSetIdentityStatement) -> RustBuffer {
    return FfiConverterTypeAttributeInSetIdentityStatement.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * in a set of attributes.
 */
public struct AttributeInSetIdentityStatementV1: Equatable, Hashable {
    /**
     * The attribute that the verifier wants the user prove lies in a set.
     */
    public var attributeTag: AttributeTag
    /**
     * The set that the attribute should lie in.
     */
    public var set: [Web3IdAttribute]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user prove lies in a set.
         */attributeTag: AttributeTag, 
        /**
         * The set that the attribute should lie in.
         */set: [Web3IdAttribute]) {
        self.attributeTag = attributeTag
        self.set = set
    }

    

    
}

#if compiler(>=6)
extension AttributeInSetIdentityStatementV1: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeInSetIdentityStatementV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeInSetIdentityStatementV1 {
        return
            try AttributeInSetIdentityStatementV1(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf), 
                set: FfiConverterSequenceTypeWeb3IdAttribute.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeInSetIdentityStatementV1, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
        FfiConverterSequenceTypeWeb3IdAttribute.write(value.set, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInSetIdentityStatementV1_lift(_ buf: RustBuffer) throws -> AttributeInSetIdentityStatementV1 {
    return try FfiConverterTypeAttributeInSetIdentityStatementV1.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInSetIdentityStatementV1_lower(_ value: AttributeInSetIdentityStatementV1) -> RustBuffer {
    return FfiConverterTypeAttributeInSetIdentityStatementV1.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * in a set of attributes.
 */
public struct AttributeInSetWeb3IdStatement: Equatable, Hashable {
    /**
     * The attribute that the verifier wants the user prove lies in a set.
     */
    public var attributeTag: String
    /**
     * The set that the attribute should lie in.
     */
    public var set: [Web3IdAttribute]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user prove lies in a set.
         */attributeTag: String, 
        /**
         * The set that the attribute should lie in.
         */set: [Web3IdAttribute]) {
        self.attributeTag = attributeTag
        self.set = set
    }

    

    
}

#if compiler(>=6)
extension AttributeInSetWeb3IdStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeInSetWeb3IdStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeInSetWeb3IdStatement {
        return
            try AttributeInSetWeb3IdStatement(
                attributeTag: FfiConverterString.read(from: &buf), 
                set: FfiConverterSequenceTypeWeb3IdAttribute.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeInSetWeb3IdStatement, into buf: inout [UInt8]) {
        FfiConverterString.write(value.attributeTag, into: &buf)
        FfiConverterSequenceTypeWeb3IdAttribute.write(value.set, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInSetWeb3IdStatement_lift(_ buf: RustBuffer) throws -> AttributeInSetWeb3IdStatement {
    return try FfiConverterTypeAttributeInSetWeb3IdStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeInSetWeb3IdStatement_lower(_ value: AttributeInSetWeb3IdStatement) -> RustBuffer {
    return FfiConverterTypeAttributeInSetWeb3IdStatement.lower(value)
}


/**
 * An attribute list that is part of a normal credential.
 * It consists of some mandatory attributes and some user selected attributes.
 */
public struct AttributeList: Equatable, Hashable {
    /**
     * The latest month and year where the credential is still valid.
     */
    public var validToYearMonth: String
    /**
     * The year and month when the identity object from which the credential is derived was created.
     * This deliberately has low granularity since if it was, e.g., a unix timestamp in seconds,
     * then the identity provider could link accounts on the chain to identities they have issued.
     */
    public var createdAtYearMonth: String
    /**
     * Maximum number of accounts that can be created from the owning identity object.
     */
    public var maxAccounts: UInt8
    /**
     * The attributes map.
     */
    public var chosenAttributes: [AttributeTag: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The latest month and year where the credential is still valid.
         */validToYearMonth: String, 
        /**
         * The year and month when the identity object from which the credential is derived was created.
         * This deliberately has low granularity since if it was, e.g., a unix timestamp in seconds,
         * then the identity provider could link accounts on the chain to identities they have issued.
         */createdAtYearMonth: String, 
        /**
         * Maximum number of accounts that can be created from the owning identity object.
         */maxAccounts: UInt8, 
        /**
         * The attributes map.
         */chosenAttributes: [AttributeTag: String]) {
        self.validToYearMonth = validToYearMonth
        self.createdAtYearMonth = createdAtYearMonth
        self.maxAccounts = maxAccounts
        self.chosenAttributes = chosenAttributes
    }

    

    
}

#if compiler(>=6)
extension AttributeList: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeList {
        return
            try AttributeList(
                validToYearMonth: FfiConverterString.read(from: &buf), 
                createdAtYearMonth: FfiConverterString.read(from: &buf), 
                maxAccounts: FfiConverterUInt8.read(from: &buf), 
                chosenAttributes: FfiConverterDictionaryTypeAttributeTagString.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeList, into buf: inout [UInt8]) {
        FfiConverterString.write(value.validToYearMonth, into: &buf)
        FfiConverterString.write(value.createdAtYearMonth, into: &buf)
        FfiConverterUInt8.write(value.maxAccounts, into: &buf)
        FfiConverterDictionaryTypeAttributeTagString.write(value.chosenAttributes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeList_lift(_ buf: RustBuffer) throws -> AttributeList {
    return try FfiConverterTypeAttributeList.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeList_lower(_ value: AttributeList) -> RustBuffer {
    return FfiConverterTypeAttributeList.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * not in a set of attributes.
 */
public struct AttributeNotInSetIdentityStatement: Equatable, Hashable {
    /**
     * The attribute that the verifier wants the user to prove does not lie in
     * a set.
     */
    public var attributeTag: AttributeTag
    /**
     * The set that the attribute should not lie in.
     */
    public var set: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to prove does not lie in
         * a set.
         */attributeTag: AttributeTag, 
        /**
         * The set that the attribute should not lie in.
         */set: [String]) {
        self.attributeTag = attributeTag
        self.set = set
    }

    

    
}

#if compiler(>=6)
extension AttributeNotInSetIdentityStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeNotInSetIdentityStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeNotInSetIdentityStatement {
        return
            try AttributeNotInSetIdentityStatement(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf), 
                set: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeNotInSetIdentityStatement, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
        FfiConverterSequenceString.write(value.set, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeNotInSetIdentityStatement_lift(_ buf: RustBuffer) throws -> AttributeNotInSetIdentityStatement {
    return try FfiConverterTypeAttributeNotInSetIdentityStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeNotInSetIdentityStatement_lower(_ value: AttributeNotInSetIdentityStatement) -> RustBuffer {
    return FfiConverterTypeAttributeNotInSetIdentityStatement.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * not in a set of attributes.
 */
public struct AttributeNotInSetIdentityStatementV1: Equatable, Hashable {
    /**
     * The attribute that the verifier wants the user to prove does not lie in
     * a set.
     */
    public var attributeTag: AttributeTag
    /**
     * The set that the attribute should not lie in.
     */
    public var set: [Web3IdAttribute]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to prove does not lie in
         * a set.
         */attributeTag: AttributeTag, 
        /**
         * The set that the attribute should not lie in.
         */set: [Web3IdAttribute]) {
        self.attributeTag = attributeTag
        self.set = set
    }

    

    
}

#if compiler(>=6)
extension AttributeNotInSetIdentityStatementV1: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeNotInSetIdentityStatementV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeNotInSetIdentityStatementV1 {
        return
            try AttributeNotInSetIdentityStatementV1(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf), 
                set: FfiConverterSequenceTypeWeb3IdAttribute.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeNotInSetIdentityStatementV1, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
        FfiConverterSequenceTypeWeb3IdAttribute.write(value.set, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeNotInSetIdentityStatementV1_lift(_ buf: RustBuffer) throws -> AttributeNotInSetIdentityStatementV1 {
    return try FfiConverterTypeAttributeNotInSetIdentityStatementV1.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeNotInSetIdentityStatementV1_lower(_ value: AttributeNotInSetIdentityStatementV1) -> RustBuffer {
    return FfiConverterTypeAttributeNotInSetIdentityStatementV1.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * not in a set of attributes.
 */
public struct AttributeNotInSetWeb3IdStatement: Equatable, Hashable {
    /**
     * The attribute that the verifier wants the user to prove does not lie in
     * a set.
     */
    public var attributeTag: String
    /**
     * The set that the attribute should not lie in.
     */
    public var set: [Web3IdAttribute]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to prove does not lie in
         * a set.
         */attributeTag: String, 
        /**
         * The set that the attribute should not lie in.
         */set: [Web3IdAttribute]) {
        self.attributeTag = attributeTag
        self.set = set
    }

    

    
}

#if compiler(>=6)
extension AttributeNotInSetWeb3IdStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeNotInSetWeb3IdStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeNotInSetWeb3IdStatement {
        return
            try AttributeNotInSetWeb3IdStatement(
                attributeTag: FfiConverterString.read(from: &buf), 
                set: FfiConverterSequenceTypeWeb3IdAttribute.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeNotInSetWeb3IdStatement, into buf: inout [UInt8]) {
        FfiConverterString.write(value.attributeTag, into: &buf)
        FfiConverterSequenceTypeWeb3IdAttribute.write(value.set, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeNotInSetWeb3IdStatement_lift(_ buf: RustBuffer) throws -> AttributeNotInSetWeb3IdStatement {
    return try FfiConverterTypeAttributeNotInSetWeb3IdStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeNotInSetWeb3IdStatement_lower(_ value: AttributeNotInSetWeb3IdStatement) -> RustBuffer {
    return FfiConverterTypeAttributeNotInSetWeb3IdStatement.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * equal to a public value. The statement is that the attribute value is equal to `attribute_value`.
 */
public struct AttributeValueIdentityStatementV1: Equatable, Hashable {
    public var attributeTag: AttributeTag
    public var attributeValue: Web3IdAttribute

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(attributeTag: AttributeTag, attributeValue: Web3IdAttribute) {
        self.attributeTag = attributeTag
        self.attributeValue = attributeValue
    }

    

    
}

#if compiler(>=6)
extension AttributeValueIdentityStatementV1: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeValueIdentityStatementV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeValueIdentityStatementV1 {
        return
            try AttributeValueIdentityStatementV1(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf), 
                attributeValue: FfiConverterTypeWeb3IdAttribute.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeValueIdentityStatementV1, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
        FfiConverterTypeWeb3IdAttribute.write(value.attributeValue, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeValueIdentityStatementV1_lift(_ buf: RustBuffer) throws -> AttributeValueIdentityStatementV1 {
    return try FfiConverterTypeAttributeValueIdentityStatementV1.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeValueIdentityStatementV1_lower(_ value: AttributeValueIdentityStatementV1) -> RustBuffer {
    return FfiConverterTypeAttributeValueIdentityStatementV1.lower(value)
}


public struct BakerKeyPairs: Equatable, Hashable {
    public var signatureSign: Bytes
    public var signatureVerify: Bytes
    public var electionSign: Bytes
    public var electionVerify: Bytes
    public var aggregationSign: Bytes
    public var aggregationVerify: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signatureSign: Bytes, signatureVerify: Bytes, electionSign: Bytes, electionVerify: Bytes, aggregationSign: Bytes, aggregationVerify: Bytes) {
        self.signatureSign = signatureSign
        self.signatureVerify = signatureVerify
        self.electionSign = electionSign
        self.electionVerify = electionVerify
        self.aggregationSign = aggregationSign
        self.aggregationVerify = aggregationVerify
    }

    

    
}

#if compiler(>=6)
extension BakerKeyPairs: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBakerKeyPairs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BakerKeyPairs {
        return
            try BakerKeyPairs(
                signatureSign: FfiConverterTypeBytes.read(from: &buf), 
                signatureVerify: FfiConverterTypeBytes.read(from: &buf), 
                electionSign: FfiConverterTypeBytes.read(from: &buf), 
                electionVerify: FfiConverterTypeBytes.read(from: &buf), 
                aggregationSign: FfiConverterTypeBytes.read(from: &buf), 
                aggregationVerify: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: BakerKeyPairs, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.signatureSign, into: &buf)
        FfiConverterTypeBytes.write(value.signatureVerify, into: &buf)
        FfiConverterTypeBytes.write(value.electionSign, into: &buf)
        FfiConverterTypeBytes.write(value.electionVerify, into: &buf)
        FfiConverterTypeBytes.write(value.aggregationSign, into: &buf)
        FfiConverterTypeBytes.write(value.aggregationVerify, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBakerKeyPairs_lift(_ buf: RustBuffer) throws -> BakerKeyPairs {
    return try FfiConverterTypeBakerKeyPairs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBakerKeyPairs_lower(_ value: BakerKeyPairs) -> RustBuffer {
    return FfiConverterTypeBakerKeyPairs.lower(value)
}


public struct BakerKeysPayload: Equatable, Hashable {
    public var signatureVerifyKey: Bytes
    public var electionVerifyKey: Bytes
    public var aggregationVerifyKey: Bytes
    public var proofSig: Bytes
    public var proofElection: Bytes
    public var proofAggregation: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signatureVerifyKey: Bytes, electionVerifyKey: Bytes, aggregationVerifyKey: Bytes, proofSig: Bytes, proofElection: Bytes, proofAggregation: Bytes) {
        self.signatureVerifyKey = signatureVerifyKey
        self.electionVerifyKey = electionVerifyKey
        self.aggregationVerifyKey = aggregationVerifyKey
        self.proofSig = proofSig
        self.proofElection = proofElection
        self.proofAggregation = proofAggregation
    }

    

    
}

#if compiler(>=6)
extension BakerKeysPayload: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBakerKeysPayload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BakerKeysPayload {
        return
            try BakerKeysPayload(
                signatureVerifyKey: FfiConverterTypeBytes.read(from: &buf), 
                electionVerifyKey: FfiConverterTypeBytes.read(from: &buf), 
                aggregationVerifyKey: FfiConverterTypeBytes.read(from: &buf), 
                proofSig: FfiConverterTypeBytes.read(from: &buf), 
                proofElection: FfiConverterTypeBytes.read(from: &buf), 
                proofAggregation: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: BakerKeysPayload, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.signatureVerifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.electionVerifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.aggregationVerifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.proofSig, into: &buf)
        FfiConverterTypeBytes.write(value.proofElection, into: &buf)
        FfiConverterTypeBytes.write(value.proofAggregation, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBakerKeysPayload_lift(_ buf: RustBuffer) throws -> BakerKeysPayload {
    return try FfiConverterTypeBakerKeysPayload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBakerKeysPayload_lower(_ value: BakerKeysPayload) -> RustBuffer {
    return FfiConverterTypeBakerKeysPayload.lower(value)
}


/**
 * Data relating to a single anonymity revoker constructed by the account holder.
 * Typically a vector of these will be sent to the chain.
 */
public struct ChainArData: Equatable, Hashable {
    public var encIdCredPubShare: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(encIdCredPubShare: Bytes) {
        self.encIdCredPubShare = encIdCredPubShare
    }

    

    
}

#if compiler(>=6)
extension ChainArData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainArData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainArData {
        return
            try ChainArData(
                encIdCredPubShare: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: ChainArData, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.encIdCredPubShare, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainArData_lift(_ buf: RustBuffer) throws -> ChainArData {
    return try FfiConverterTypeChainArData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainArData_lower(_ value: ChainArData) -> RustBuffer {
    return FfiConverterTypeChainArData.lower(value)
}


/**
 * Choice of anonymity revocation parameters.
 */
public struct ChoiceArParameters: Equatable, Hashable {
    public var arIdentities: [UInt32]
    public var threshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(arIdentities: [UInt32], threshold: UInt8) {
        self.arIdentities = arIdentities
        self.threshold = threshold
    }

    

    
}

#if compiler(>=6)
extension ChoiceArParameters: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChoiceArParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChoiceArParameters {
        return
            try ChoiceArParameters(
                arIdentities: FfiConverterSequenceUInt32.read(from: &buf), 
                threshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ChoiceArParameters, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt32.write(value.arIdentities, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChoiceArParameters_lift(_ buf: RustBuffer) throws -> ChoiceArParameters {
    return try FfiConverterTypeChoiceArParameters.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChoiceArParameters_lower(_ value: ChoiceArParameters) -> RustBuffer {
    return FfiConverterTypeChoiceArParameters.lower(value)
}


/**
 * Proof of account based credential
 */
public struct ConcordiumCredentialZkProofs: Equatable, Hashable {
    public var createdAt: Date
    public var proofValue: Bytes
    public var proofVersion: ConcordiumZkProofVersion

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(createdAt: Date, proofValue: Bytes, proofVersion: ConcordiumZkProofVersion) {
        self.createdAt = createdAt
        self.proofValue = proofValue
        self.proofVersion = proofVersion
    }

    

    
}

#if compiler(>=6)
extension ConcordiumCredentialZkProofs: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConcordiumCredentialZKProofs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConcordiumCredentialZkProofs {
        return
            try ConcordiumCredentialZkProofs(
                createdAt: FfiConverterTimestamp.read(from: &buf), 
                proofValue: FfiConverterTypeBytes.read(from: &buf), 
                proofVersion: FfiConverterTypeConcordiumZKProofVersion.read(from: &buf)
        )
    }

    public static func write(_ value: ConcordiumCredentialZkProofs, into buf: inout [UInt8]) {
        FfiConverterTimestamp.write(value.createdAt, into: &buf)
        FfiConverterTypeBytes.write(value.proofValue, into: &buf)
        FfiConverterTypeConcordiumZKProofVersion.write(value.proofVersion, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConcordiumCredentialZKProofs_lift(_ buf: RustBuffer) throws -> ConcordiumCredentialZkProofs {
    return try FfiConverterTypeConcordiumCredentialZKProofs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConcordiumCredentialZKProofs_lower(_ value: ConcordiumCredentialZkProofs) -> RustBuffer {
    return FfiConverterTypeConcordiumCredentialZKProofs.lower(value)
}


/**
 * Verification context information that serves as a distinguishing context when requesting
 * proofs.
 */
public struct ContextInformation: Equatable, Hashable {
    public var given: [ContextProperty]
    public var requested: [ContextProperty]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(given: [ContextProperty], requested: [ContextProperty]) {
        self.given = given
        self.requested = requested
    }

    

    
}

#if compiler(>=6)
extension ContextInformation: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContextInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContextInformation {
        return
            try ContextInformation(
                given: FfiConverterSequenceTypeContextProperty.read(from: &buf), 
                requested: FfiConverterSequenceTypeContextProperty.read(from: &buf)
        )
    }

    public static func write(_ value: ContextInformation, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeContextProperty.write(value.given, into: &buf)
        FfiConverterSequenceTypeContextProperty.write(value.requested, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContextInformation_lift(_ buf: RustBuffer) throws -> ContextInformation {
    return try FfiConverterTypeContextInformation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContextInformation_lower(_ value: ContextInformation) -> RustBuffer {
    return FfiConverterTypeContextInformation.lower(value)
}


/**
 * Property value used in `ContextInformation`
 */
public struct ContextProperty: Equatable, Hashable {
    public var label: String
    public var context: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(label: String, context: String) {
        self.label = label
        self.context = context
    }

    

    
}

#if compiler(>=6)
extension ContextProperty: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContextProperty: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContextProperty {
        return
            try ContextProperty(
                label: FfiConverterString.read(from: &buf), 
                context: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ContextProperty, into buf: inout [UInt8]) {
        FfiConverterString.write(value.label, into: &buf)
        FfiConverterString.write(value.context, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContextProperty_lift(_ buf: RustBuffer) throws -> ContextProperty {
    return try FfiConverterTypeContextProperty.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContextProperty_lower(_ value: ContextProperty) -> RustBuffer {
    return FfiConverterTypeContextProperty.lower(value)
}


/**
 * Represents an address of a smart contract
 */
public struct ContractAddress: Equatable, Hashable {
    public var index: UInt64
    public var subindex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(index: UInt64, subindex: UInt64) {
        self.index = index
        self.subindex = subindex
    }

    

    
}

#if compiler(>=6)
extension ContractAddress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContractAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContractAddress {
        return
            try ContractAddress(
                index: FfiConverterUInt64.read(from: &buf), 
                subindex: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ContractAddress, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.index, into: &buf)
        FfiConverterUInt64.write(value.subindex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContractAddress_lift(_ buf: RustBuffer) throws -> ContractAddress {
    return try FfiConverterTypeContractAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContractAddress_lower(_ value: ContractAddress) -> RustBuffer {
    return FfiConverterTypeContractAddress.lower(value)
}


/**
 * A credential with attributes, public keys, and proofs that it is
 * well-formed.
 */
public struct CredentialDeploymentInfo: Equatable, Hashable {
    /**
     * List of anonymity revokers which can revoke the identity.
     * The order is important since it is the same order as that signed by the identity provider,
     * and permuting the list will invalidate the signature from the identity provider.
     */
    public var arData: [UInt32: ChainArData]
    /**
     * Credential registration ID of the credential.
     * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base.
     */
    public var credId: Bytes
    /**
     * Credential keys (i.e. account holder keys).
     */
    public var credentialPublicKeys: CredentialPublicKeys
    /**
     * Identity of the identity provider who signed the identity object
     * from which this credential is derived.
     */
    public var ipIdentity: UInt32
    /**
     * Policy of this credential object.
     */
    public var policy: Policy
    /**
     * The proofs of ownership.
     * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base
     */
    public var proofs: Bytes
    /**
     * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
     */
    public var revocationThreshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * List of anonymity revokers which can revoke the identity.
         * The order is important since it is the same order as that signed by the identity provider,
         * and permuting the list will invalidate the signature from the identity provider.
         */arData: [UInt32: ChainArData], 
        /**
         * Credential registration ID of the credential.
         * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base.
         */credId: Bytes, 
        /**
         * Credential keys (i.e. account holder keys).
         */credentialPublicKeys: CredentialPublicKeys, 
        /**
         * Identity of the identity provider who signed the identity object
         * from which this credential is derived.
         */ipIdentity: UInt32, 
        /**
         * Policy of this credential object.
         */policy: Policy, 
        /**
         * The proofs of ownership.
         * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base
         */proofs: Bytes, 
        /**
         * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
         */revocationThreshold: UInt8) {
        self.arData = arData
        self.credId = credId
        self.credentialPublicKeys = credentialPublicKeys
        self.ipIdentity = ipIdentity
        self.policy = policy
        self.proofs = proofs
        self.revocationThreshold = revocationThreshold
    }

    

    
}

#if compiler(>=6)
extension CredentialDeploymentInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialDeploymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialDeploymentInfo {
        return
            try CredentialDeploymentInfo(
                arData: FfiConverterDictionaryUInt32TypeChainArData.read(from: &buf), 
                credId: FfiConverterTypeBytes.read(from: &buf), 
                credentialPublicKeys: FfiConverterTypeCredentialPublicKeys.read(from: &buf), 
                ipIdentity: FfiConverterUInt32.read(from: &buf), 
                policy: FfiConverterTypePolicy.read(from: &buf), 
                proofs: FfiConverterTypeBytes.read(from: &buf), 
                revocationThreshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialDeploymentInfo, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt32TypeChainArData.write(value.arData, into: &buf)
        FfiConverterTypeBytes.write(value.credId, into: &buf)
        FfiConverterTypeCredentialPublicKeys.write(value.credentialPublicKeys, into: &buf)
        FfiConverterUInt32.write(value.ipIdentity, into: &buf)
        FfiConverterTypePolicy.write(value.policy, into: &buf)
        FfiConverterTypeBytes.write(value.proofs, into: &buf)
        FfiConverterUInt8.write(value.revocationThreshold, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialDeploymentInfo_lift(_ buf: RustBuffer) throws -> CredentialDeploymentInfo {
    return try FfiConverterTypeCredentialDeploymentInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialDeploymentInfo_lower(_ value: CredentialDeploymentInfo) -> RustBuffer {
    return FfiConverterTypeCredentialDeploymentInfo.lower(value)
}


/**
 * Private credential holder information. A user maintaints these
 * through many different interactions with the identity provider and
 * the chain.
 */
public struct CredentialHolderInfo: Equatable, Hashable {
    public var idCred: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(idCred: Bytes) {
        self.idCred = idCred
    }

    

    
}

#if compiler(>=6)
extension CredentialHolderInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialHolderInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialHolderInfo {
        return
            try CredentialHolderInfo(
                idCred: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialHolderInfo, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.idCred, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialHolderInfo_lift(_ buf: RustBuffer) throws -> CredentialHolderInfo {
    return try FfiConverterTypeCredentialHolderInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialHolderInfo_lower(_ value: CredentialHolderInfo) -> RustBuffer {
    return FfiConverterTypeCredentialHolderInfo.lower(value)
}


/**
 * Public credential keys currently on the account.
 * The threshold determines the number of required signatures on a transaction for it to be valid.
 */
public struct CredentialPublicKeys: Equatable, Hashable {
    public var keys: [UInt8: VerifyKey]
    public var threshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(keys: [UInt8: VerifyKey], threshold: UInt8) {
        self.keys = keys
        self.threshold = threshold
    }

    

    
}

#if compiler(>=6)
extension CredentialPublicKeys: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialPublicKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialPublicKeys {
        return
            try CredentialPublicKeys(
                keys: FfiConverterDictionaryUInt8TypeVerifyKey.read(from: &buf), 
                threshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialPublicKeys, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt8TypeVerifyKey.write(value.keys, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialPublicKeys_lift(_ buf: RustBuffer) throws -> CredentialPublicKeys {
    return try FfiConverterTypeCredentialPublicKeys.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialPublicKeys_lower(_ value: CredentialPublicKeys) -> RustBuffer {
    return FfiConverterTypeCredentialPublicKeys.lower(value)
}


public struct Did: Equatable, Hashable {
    /**
     * The network part of the method.
     */
    public var network: Network
    /**
     * The remaining identifier.
     */
    public var idType: IdentifierType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The network part of the method.
         */network: Network, 
        /**
         * The remaining identifier.
         */idType: IdentifierType) {
        self.network = network
        self.idType = idType
    }

    

    
}

#if compiler(>=6)
extension Did: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDID: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Did {
        return
            try Did(
                network: FfiConverterTypeNetwork.read(from: &buf), 
                idType: FfiConverterTypeIdentifierType.read(from: &buf)
        )
    }

    public static func write(_ value: Did, into buf: inout [UInt8]) {
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterTypeIdentifierType.write(value.idType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDID_lift(_ buf: RustBuffer) throws -> Did {
    return try FfiConverterTypeDID.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDID_lower(_ value: Did) -> RustBuffer {
    return FfiConverterTypeDID.lower(value)
}


/**
 * Metadata of an identity provider or anonymity revoker
 * to be visible on the chain.
 */
public struct Description: Equatable, Hashable {
    public var name: String
    public var url: String
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, url: String, description: String) {
        self.name = name
        self.url = url
        self.description = description
    }

    

    
}

#if compiler(>=6)
extension Description: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Description {
        return
            try Description(
                name: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Description, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescription_lift(_ buf: RustBuffer) throws -> Description {
    return try FfiConverterTypeDescription.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescription_lower(_ value: Description) -> RustBuffer {
    return FfiConverterTypeDescription.lower(value)
}


/**
 * Encryption keypair for an account, used to handle the encrypted amount associated with a specific account.
 */
public struct EncryptionKeys: Equatable, Hashable {
    /**
     * The secret key serialized as bytes.
     */
    public var secret: Bytes
    /**
     * The public key serialized as bytes.
     */
    public var `public`: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The secret key serialized as bytes.
         */secret: Bytes, 
        /**
         * The public key serialized as bytes.
         */`public`: Bytes) {
        self.secret = secret
        self.`public` = `public`
    }

    

    
}

#if compiler(>=6)
extension EncryptionKeys: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEncryptionKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionKeys {
        return
            try EncryptionKeys(
                secret: FfiConverterTypeBytes.read(from: &buf), 
                public: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: EncryptionKeys, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.secret, into: &buf)
        FfiConverterTypeBytes.write(value.`public`, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptionKeys_lift(_ buf: RustBuffer) throws -> EncryptionKeys {
    return try FfiConverterTypeEncryptionKeys.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptionKeys_lower(_ value: EncryptionKeys) -> RustBuffer {
    return FfiConverterTypeEncryptionKeys.lower(value)
}


/**
 * A set of cryptographic parameters that are particular to the chain and
 * shared by everybody that interacts with the chain.
 */
public struct GlobalContext: Equatable, Hashable {
    /**
     * Shared commitment key known to the chain and the account holder (i.e. it's public).
     * The account holder uses this commitment key to generate commitments to values in the attribute list.
     */
    public var onChainCommitmentKey: Bytes
    /**
     * Generators for the bulletproofs.
     */
    public var bulletproofGenerators: Bytes
    /**
     * Free-form string used to distinguish between different chains even if they share other parameters.
     */
    public var genesisString: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Shared commitment key known to the chain and the account holder (i.e. it's public).
         * The account holder uses this commitment key to generate commitments to values in the attribute list.
         */onChainCommitmentKey: Bytes, 
        /**
         * Generators for the bulletproofs.
         */bulletproofGenerators: Bytes, 
        /**
         * Free-form string used to distinguish between different chains even if they share other parameters.
         */genesisString: String) {
        self.onChainCommitmentKey = onChainCommitmentKey
        self.bulletproofGenerators = bulletproofGenerators
        self.genesisString = genesisString
    }

    

    
}

#if compiler(>=6)
extension GlobalContext: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalContext {
        return
            try GlobalContext(
                onChainCommitmentKey: FfiConverterTypeBytes.read(from: &buf), 
                bulletproofGenerators: FfiConverterTypeBytes.read(from: &buf), 
                genesisString: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GlobalContext, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.onChainCommitmentKey, into: &buf)
        FfiConverterTypeBytes.write(value.bulletproofGenerators, into: &buf)
        FfiConverterString.write(value.genesisString, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalContext_lift(_ buf: RustBuffer) throws -> GlobalContext {
    return try FfiConverterTypeGlobalContext.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalContext_lower(_ value: GlobalContext) -> RustBuffer {
    return FfiConverterTypeGlobalContext.lower(value)
}


/**
 * Data needed to use the retrieved identity object to generate credentials.
 */
public struct IdObjectUseData: Equatable, Hashable {
    public var aci: AccCredentialInfo
    public var randomness: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(aci: AccCredentialInfo, randomness: Bytes) {
        self.aci = aci
        self.randomness = randomness
    }

    

    
}

#if compiler(>=6)
extension IdObjectUseData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdObjectUseData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdObjectUseData {
        return
            try IdObjectUseData(
                aci: FfiConverterTypeAccCredentialInfo.read(from: &buf), 
                randomness: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdObjectUseData, into buf: inout [UInt8]) {
        FfiConverterTypeAccCredentialInfo.write(value.aci, into: &buf)
        FfiConverterTypeBytes.write(value.randomness, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdObjectUseData_lift(_ buf: RustBuffer) throws -> IdObjectUseData {
    return try FfiConverterTypeIdObjectUseData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdObjectUseData_lower(_ value: IdObjectUseData) -> RustBuffer {
    return FfiConverterTypeIdObjectUseData.lower(value)
}


/**
 * Identity based credential. This type of credential is derived from identity credentials issued
 * by an identity provider. The type contains almost
 * all the information needed to verify it, except the identity provider and privacy guardian (anonymity revoker) public keys.
 */
public struct IdentityBasedCredentialV1: Equatable, Hashable {
    public var issuer: UInt32
    public var validFrom: Date
    public var validUntil: Date
    public var subject: IdentityCredentialSubject
    public var proofs: ConcordiumCredentialZkProofs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(issuer: UInt32, validFrom: Date, validUntil: Date, subject: IdentityCredentialSubject, proofs: ConcordiumCredentialZkProofs) {
        self.issuer = issuer
        self.validFrom = validFrom
        self.validUntil = validUntil
        self.subject = subject
        self.proofs = proofs
    }

    

    
}

#if compiler(>=6)
extension IdentityBasedCredentialV1: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityBasedCredentialV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityBasedCredentialV1 {
        return
            try IdentityBasedCredentialV1(
                issuer: FfiConverterUInt32.read(from: &buf), 
                validFrom: FfiConverterTimestamp.read(from: &buf), 
                validUntil: FfiConverterTimestamp.read(from: &buf), 
                subject: FfiConverterTypeIdentityCredentialSubject.read(from: &buf), 
                proofs: FfiConverterTypeConcordiumCredentialZKProofs.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityBasedCredentialV1, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.issuer, into: &buf)
        FfiConverterTimestamp.write(value.validFrom, into: &buf)
        FfiConverterTimestamp.write(value.validUntil, into: &buf)
        FfiConverterTypeIdentityCredentialSubject.write(value.subject, into: &buf)
        FfiConverterTypeConcordiumCredentialZKProofs.write(value.proofs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityBasedCredentialV1_lift(_ buf: RustBuffer) throws -> IdentityBasedCredentialV1 {
    return try FfiConverterTypeIdentityBasedCredentialV1.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityBasedCredentialV1_lower(_ value: IdentityBasedCredentialV1) -> RustBuffer {
    return FfiConverterTypeIdentityBasedCredentialV1.lower(value)
}


/**
 * Claims about a single identity based subject. Identity credentials
 * are issued by identity providers.
 */
public struct IdentityBasedSubjectClaims: Equatable, Hashable {
    /**
     * Network to which the identity credentials are issued
     */
    public var network: Network
    /**
     * Identity provider which issued the credentials
     */
    public var issuer: UInt32
    /**
     * Attribute statements
     */
    public var statements: [AtomicStatementV1]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Network to which the identity credentials are issued
         */network: Network, 
        /**
         * Identity provider which issued the credentials
         */issuer: UInt32, 
        /**
         * Attribute statements
         */statements: [AtomicStatementV1]) {
        self.network = network
        self.issuer = issuer
        self.statements = statements
    }

    

    
}

#if compiler(>=6)
extension IdentityBasedSubjectClaims: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityBasedSubjectClaims: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityBasedSubjectClaims {
        return
            try IdentityBasedSubjectClaims(
                network: FfiConverterTypeNetwork.read(from: &buf), 
                issuer: FfiConverterUInt32.read(from: &buf), 
                statements: FfiConverterSequenceTypeAtomicStatementV1.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityBasedSubjectClaims, into buf: inout [UInt8]) {
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterUInt32.write(value.issuer, into: &buf)
        FfiConverterSequenceTypeAtomicStatementV1.write(value.statements, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityBasedSubjectClaims_lift(_ buf: RustBuffer) throws -> IdentityBasedSubjectClaims {
    return try FfiConverterTypeIdentityBasedSubjectClaims.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityBasedSubjectClaims_lower(_ value: IdentityBasedSubjectClaims) -> RustBuffer {
    return FfiConverterTypeIdentityBasedSubjectClaims.lower(value)
}


/**
 * Subject of identity based credential
 */
public struct IdentityCredentialSubject: Equatable, Hashable {
    public var network: Network
    public var credId: Bytes
    public var statements: [AtomicStatementV1]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(network: Network, credId: Bytes, statements: [AtomicStatementV1]) {
        self.network = network
        self.credId = credId
        self.statements = statements
    }

    

    
}

#if compiler(>=6)
extension IdentityCredentialSubject: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityCredentialSubject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityCredentialSubject {
        return
            try IdentityCredentialSubject(
                network: FfiConverterTypeNetwork.read(from: &buf), 
                credId: FfiConverterTypeBytes.read(from: &buf), 
                statements: FfiConverterSequenceTypeAtomicStatementV1.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityCredentialSubject, into buf: inout [UInt8]) {
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterTypeBytes.write(value.credId, into: &buf)
        FfiConverterSequenceTypeAtomicStatementV1.write(value.statements, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityCredentialSubject_lift(_ buf: RustBuffer) throws -> IdentityCredentialSubject {
    return try FfiConverterTypeIdentityCredentialSubject.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityCredentialSubject_lower(_ value: IdentityCredentialSubject) -> RustBuffer {
    return FfiConverterTypeIdentityCredentialSubject.lower(value)
}


/**
 * Parameter object for `identity_issuance_request_json`.
 */
public struct IdentityIssuanceRequestParameters: Equatable, Hashable {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var arsInfos: [UInt32: AnonymityRevokerInfo]
    public var arThreshold: UInt8
    public var prfKey: Bytes
    public var idCredSec: Bytes
    public var blindingRandomness: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ipInfo: IdentityProviderInfo, globalContext: GlobalContext, arsInfos: [UInt32: AnonymityRevokerInfo], arThreshold: UInt8, prfKey: Bytes, idCredSec: Bytes, blindingRandomness: Bytes) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.arsInfos = arsInfos
        self.arThreshold = arThreshold
        self.prfKey = prfKey
        self.idCredSec = idCredSec
        self.blindingRandomness = blindingRandomness
    }

    

    
}

#if compiler(>=6)
extension IdentityIssuanceRequestParameters: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityIssuanceRequestParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityIssuanceRequestParameters {
        return
            try IdentityIssuanceRequestParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf), 
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf), 
                arsInfos: FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.read(from: &buf), 
                arThreshold: FfiConverterUInt8.read(from: &buf), 
                prfKey: FfiConverterTypeBytes.read(from: &buf), 
                idCredSec: FfiConverterTypeBytes.read(from: &buf), 
                blindingRandomness: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityIssuanceRequestParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.write(value.arsInfos, into: &buf)
        FfiConverterUInt8.write(value.arThreshold, into: &buf)
        FfiConverterTypeBytes.write(value.prfKey, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSec, into: &buf)
        FfiConverterTypeBytes.write(value.blindingRandomness, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityIssuanceRequestParameters_lift(_ buf: RustBuffer) throws -> IdentityIssuanceRequestParameters {
    return try FfiConverterTypeIdentityIssuanceRequestParameters.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityIssuanceRequestParameters_lower(_ value: IdentityIssuanceRequestParameters) -> RustBuffer {
    return FfiConverterTypeIdentityIssuanceRequestParameters.lower(value)
}


/**
 * The data we get back from the identity provider in the version 1 flow.
 */
public struct IdentityObject: Equatable, Hashable {
    public var preIdentityObject: PreIdentityObject
    /**
     * Chosen attribute list.
     */
    public var attributeList: AttributeList
    public var signature: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(preIdentityObject: PreIdentityObject, 
        /**
         * Chosen attribute list.
         */attributeList: AttributeList, signature: Bytes) {
        self.preIdentityObject = preIdentityObject
        self.attributeList = attributeList
        self.signature = signature
    }

    

    
}

#if compiler(>=6)
extension IdentityObject: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityObject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityObject {
        return
            try IdentityObject(
                preIdentityObject: FfiConverterTypePreIdentityObject.read(from: &buf), 
                attributeList: FfiConverterTypeAttributeList.read(from: &buf), 
                signature: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityObject, into buf: inout [UInt8]) {
        FfiConverterTypePreIdentityObject.write(value.preIdentityObject, into: &buf)
        FfiConverterTypeAttributeList.write(value.attributeList, into: &buf)
        FfiConverterTypeBytes.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityObject_lift(_ buf: RustBuffer) throws -> IdentityObject {
    return try FfiConverterTypeIdentityObject.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityObject_lower(_ value: IdentityObject) -> RustBuffer {
    return FfiConverterTypeIdentityObject.lower(value)
}


/**
 * A proof of a statement, composed of one or more atomic proofs.
 */
public struct IdentityProof: Equatable, Hashable {
    public var proofs: [AtomicIdentityProof]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(proofs: [AtomicIdentityProof]) {
        self.proofs = proofs
    }

    

    
}

#if compiler(>=6)
extension IdentityProof: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityProof {
        return
            try IdentityProof(
                proofs: FfiConverterSequenceTypeAtomicIdentityProof.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityProof, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAtomicIdentityProof.write(value.proofs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityProof_lift(_ buf: RustBuffer) throws -> IdentityProof {
    return try FfiConverterTypeIdentityProof.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityProof_lower(_ value: IdentityProof) -> RustBuffer {
    return FfiConverterTypeIdentityProof.lower(value)
}


/**
 * DID for a Concordium Identity Provider.
 */
public struct IdentityProviderDid: Equatable, Hashable {
    /**
     * The network part of the method.
     */
    public var network: Network
    /**
     * The on-chain identifier of the Concordium Identity Provider.
     */
    public var identityProvider: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The network part of the method.
         */network: Network, 
        /**
         * The on-chain identifier of the Concordium Identity Provider.
         */identityProvider: UInt32) {
        self.network = network
        self.identityProvider = identityProvider
    }

    

    
}

#if compiler(>=6)
extension IdentityProviderDid: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityProviderDid: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityProviderDid {
        return
            try IdentityProviderDid(
                network: FfiConverterTypeNetwork.read(from: &buf), 
                identityProvider: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityProviderDid, into buf: inout [UInt8]) {
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterUInt32.write(value.identityProvider, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityProviderDid_lift(_ buf: RustBuffer) throws -> IdentityProviderDid {
    return try FfiConverterTypeIdentityProviderDid.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityProviderDid_lower(_ value: IdentityProviderDid) -> RustBuffer {
    return FfiConverterTypeIdentityProviderDid.lower(value)
}


/**
 * Public information about an identity provider.
 */
public struct IdentityProviderInfo: Equatable, Hashable {
    /**
     * Unique identifier of the identity provider.
     */
    public var identity: UInt32
    /**
     * Free form description, e.g., how to contact them off-chain.
     */
    public var description: Description
    /**
     * PS public key of the identity provider.
     */
    public var verifyKey: Bytes
    /**
     * Ed public key of the identity provider.
     */
    public var cdiVerifyKey: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier of the identity provider.
         */identity: UInt32, 
        /**
         * Free form description, e.g., how to contact them off-chain.
         */description: Description, 
        /**
         * PS public key of the identity provider.
         */verifyKey: Bytes, 
        /**
         * Ed public key of the identity provider.
         */cdiVerifyKey: Bytes) {
        self.identity = identity
        self.description = description
        self.verifyKey = verifyKey
        self.cdiVerifyKey = cdiVerifyKey
    }

    

    
}

#if compiler(>=6)
extension IdentityProviderInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityProviderInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityProviderInfo {
        return
            try IdentityProviderInfo(
                identity: FfiConverterUInt32.read(from: &buf), 
                description: FfiConverterTypeDescription.read(from: &buf), 
                verifyKey: FfiConverterTypeBytes.read(from: &buf), 
                cdiVerifyKey: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityProviderInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.identity, into: &buf)
        FfiConverterTypeDescription.write(value.description, into: &buf)
        FfiConverterTypeBytes.write(value.verifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.cdiVerifyKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityProviderInfo_lift(_ buf: RustBuffer) throws -> IdentityProviderInfo {
    return try FfiConverterTypeIdentityProviderInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityProviderInfo_lower(_ value: IdentityProviderInfo) -> RustBuffer {
    return FfiConverterTypeIdentityProviderInfo.lower(value)
}


/**
 * Parameter object for `identity_recovery_request_json`.
 */
public struct IdentityRecoveryRequestParameters: Equatable, Hashable {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var timestamp: UInt64
    public var idCredSec: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ipInfo: IdentityProviderInfo, globalContext: GlobalContext, timestamp: UInt64, idCredSec: Bytes) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.timestamp = timestamp
        self.idCredSec = idCredSec
    }

    

    
}

#if compiler(>=6)
extension IdentityRecoveryRequestParameters: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityRecoveryRequestParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityRecoveryRequestParameters {
        return
            try IdentityRecoveryRequestParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf), 
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf), 
                idCredSec: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityRecoveryRequestParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSec, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityRecoveryRequestParameters_lift(_ buf: RustBuffer) throws -> IdentityRecoveryRequestParameters {
    return try FfiConverterTypeIdentityRecoveryRequestParameters.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityRecoveryRequestParameters_lower(_ value: IdentityRecoveryRequestParameters) -> RustBuffer {
    return FfiConverterTypeIdentityRecoveryRequestParameters.lower(value)
}


/**
 * A statement is a list of atomic statements.
 */
public struct IdentityStatement: Equatable, Hashable {
    public var statements: [AtomicIdentityStatement]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statements: [AtomicIdentityStatement]) {
        self.statements = statements
    }

    

    
}

#if compiler(>=6)
extension IdentityStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityStatement {
        return
            try IdentityStatement(
                statements: FfiConverterSequenceTypeAtomicIdentityStatement.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityStatement, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAtomicIdentityStatement.write(value.statements, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityStatement_lift(_ buf: RustBuffer) throws -> IdentityStatement {
    return try FfiConverterTypeIdentityStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityStatement_lower(_ value: IdentityStatement) -> RustBuffer {
    return FfiConverterTypeIdentityStatement.lower(value)
}


/**
 * An encrypted amount input to transfer from
 */
public struct InputEncryptedAmount: Equatable, Hashable {
    /**
     * The aggregated encrypted amount.
     */
    public var aggEncryptedAmount: Bytes
    /**
     * The plaintext corresponding to the aggregated encrypted amount.
     */
    public var aggAmount: UInt64
    /**
     * Index such that the `agg_amount` is the sum of all encrypted amounts on an account with indices strictly below `agg_index`.
     */
    public var aggIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The aggregated encrypted amount.
         */aggEncryptedAmount: Bytes, 
        /**
         * The plaintext corresponding to the aggregated encrypted amount.
         */aggAmount: UInt64, 
        /**
         * Index such that the `agg_amount` is the sum of all encrypted amounts on an account with indices strictly below `agg_index`.
         */aggIndex: UInt64) {
        self.aggEncryptedAmount = aggEncryptedAmount
        self.aggAmount = aggAmount
        self.aggIndex = aggIndex
    }

    

    
}

#if compiler(>=6)
extension InputEncryptedAmount: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInputEncryptedAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InputEncryptedAmount {
        return
            try InputEncryptedAmount(
                aggEncryptedAmount: FfiConverterTypeBytes.read(from: &buf), 
                aggAmount: FfiConverterUInt64.read(from: &buf), 
                aggIndex: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: InputEncryptedAmount, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.aggEncryptedAmount, into: &buf)
        FfiConverterUInt64.write(value.aggAmount, into: &buf)
        FfiConverterUInt64.write(value.aggIndex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputEncryptedAmount_lift(_ buf: RustBuffer) throws -> InputEncryptedAmount {
    return try FfiConverterTypeInputEncryptedAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputEncryptedAmount_lower(_ value: InputEncryptedAmount) -> RustBuffer {
    return FfiConverterTypeInputEncryptedAmount.lower(value)
}


/**
 * A proof that establishes that the owner of the credential has indeed created
 * the presentation. At present this is a list of signatures.
 */
public struct LinkingProof: Equatable, Hashable {
    public var created: Date
    public var proofValue: [Bytes]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(created: Date, proofValue: [Bytes]) {
        self.created = created
        self.proofValue = proofValue
    }

    

    
}

#if compiler(>=6)
extension LinkingProof: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLinkingProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkingProof {
        return
            try LinkingProof(
                created: FfiConverterTimestamp.read(from: &buf), 
                proofValue: FfiConverterSequenceTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: LinkingProof, into buf: inout [UInt8]) {
        FfiConverterTimestamp.write(value.created, into: &buf)
        FfiConverterSequenceTypeBytes.write(value.proofValue, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLinkingProof_lift(_ buf: RustBuffer) throws -> LinkingProof {
    return try FfiConverterTypeLinkingProof.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLinkingProof_lower(_ value: LinkingProof) -> RustBuffer {
    return FfiConverterTypeLinkingProof.lower(value)
}


/**
 * Proof that the credential holder has created the presentation. Currently
 * not used.
 */
public struct LinkingProofV1: Equatable, Hashable {
    public var createdAt: Date
    public var proofValue: Data
    public var proofType: ConcordiumLinkingProofVersion

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(createdAt: Date, proofValue: Data, proofType: ConcordiumLinkingProofVersion) {
        self.createdAt = createdAt
        self.proofValue = proofValue
        self.proofType = proofType
    }

    

    
}

#if compiler(>=6)
extension LinkingProofV1: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLinkingProofV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkingProofV1 {
        return
            try LinkingProofV1(
                createdAt: FfiConverterTimestamp.read(from: &buf), 
                proofValue: FfiConverterData.read(from: &buf), 
                proofType: FfiConverterTypeConcordiumLinkingProofVersion.read(from: &buf)
        )
    }

    public static func write(_ value: LinkingProofV1, into buf: inout [UInt8]) {
        FfiConverterTimestamp.write(value.createdAt, into: &buf)
        FfiConverterData.write(value.proofValue, into: &buf)
        FfiConverterTypeConcordiumLinkingProofVersion.write(value.proofType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLinkingProofV1_lift(_ buf: RustBuffer) throws -> LinkingProofV1 {
    return try FfiConverterTypeLinkingProofV1.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLinkingProofV1_lower(_ value: LinkingProofV1) -> RustBuffer {
    return FfiConverterTypeLinkingProofV1.lower(value)
}


/**
 * Represents a contract module schema of a specific version.
 */
public struct ModuleSchema: Equatable, Hashable {
    /**
     * The module schema serialized as bytes.
     */
    public var value: Data
    /**
     * The module schema version. This is optional, as this can also be included in the serialized schema value.
     * If the version is neither present in the serialized schema, nor defined explicitly, an error will be returned upon use.
     */
    public var version: ModuleSchemaVersion?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The module schema serialized as bytes.
         */value: Data, 
        /**
         * The module schema version. This is optional, as this can also be included in the serialized schema value.
         * If the version is neither present in the serialized schema, nor defined explicitly, an error will be returned upon use.
         */version: ModuleSchemaVersion?) {
        self.value = value
        self.version = version
    }

    

    
}

#if compiler(>=6)
extension ModuleSchema: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModuleSchema: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModuleSchema {
        return
            try ModuleSchema(
                value: FfiConverterData.read(from: &buf), 
                version: FfiConverterOptionTypeModuleSchemaVersion.read(from: &buf)
        )
    }

    public static func write(_ value: ModuleSchema, into buf: inout [UInt8]) {
        FfiConverterData.write(value.value, into: &buf)
        FfiConverterOptionTypeModuleSchemaVersion.write(value.version, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModuleSchema_lift(_ buf: RustBuffer) throws -> ModuleSchema {
    return try FfiConverterTypeModuleSchema.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModuleSchema_lower(_ value: ModuleSchema) -> RustBuffer {
    return FfiConverterTypeModuleSchema.lower(value)
}


/**
 * Private inputs for an account credential proof.
 */
public struct OwnedAccountCredentialProofPrivateInputs: Equatable, Hashable {
    /**
     * Issuer of the identity credentials used to deploy the account credentials
     */
    public var issuer: UInt32
    /**
     * The attribute values that are committed to in the account credentials
     */
    public var attributeValues: [AttributeTag: Web3IdAttribute]
    /**
     * The randomness of the attribute commitments in the account credentials
     */
    public var attributeRandomness: [AttributeTag: Bytes]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Issuer of the identity credentials used to deploy the account credentials
         */issuer: UInt32, 
        /**
         * The attribute values that are committed to in the account credentials
         */attributeValues: [AttributeTag: Web3IdAttribute], 
        /**
         * The randomness of the attribute commitments in the account credentials
         */attributeRandomness: [AttributeTag: Bytes]) {
        self.issuer = issuer
        self.attributeValues = attributeValues
        self.attributeRandomness = attributeRandomness
    }

    

    
}

#if compiler(>=6)
extension OwnedAccountCredentialProofPrivateInputs: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOwnedAccountCredentialProofPrivateInputs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OwnedAccountCredentialProofPrivateInputs {
        return
            try OwnedAccountCredentialProofPrivateInputs(
                issuer: FfiConverterUInt32.read(from: &buf), 
                attributeValues: FfiConverterDictionaryTypeAttributeTagTypeWeb3IdAttribute.read(from: &buf), 
                attributeRandomness: FfiConverterDictionaryTypeAttributeTagTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: OwnedAccountCredentialProofPrivateInputs, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.issuer, into: &buf)
        FfiConverterDictionaryTypeAttributeTagTypeWeb3IdAttribute.write(value.attributeValues, into: &buf)
        FfiConverterDictionaryTypeAttributeTagTypeBytes.write(value.attributeRandomness, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOwnedAccountCredentialProofPrivateInputs_lift(_ buf: RustBuffer) throws -> OwnedAccountCredentialProofPrivateInputs {
    return try FfiConverterTypeOwnedAccountCredentialProofPrivateInputs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOwnedAccountCredentialProofPrivateInputs_lower(_ value: OwnedAccountCredentialProofPrivateInputs) -> RustBuffer {
    return FfiConverterTypeOwnedAccountCredentialProofPrivateInputs.lower(value)
}


/**
 * Private inputs for an identity credential proof.
 */
public struct OwnedIdentityCredentialProofPrivateInputs: Equatable, Hashable {
    /**
     * Identity provider information
     */
    public var ipInfo: IdentityProviderInfo
    /**
     * Public information on the __supported__ anonymity revokers.
     * Must include at least the anonymity revokers supported by the identity provider.
     * This is used to create and validate credential.
     */
    public var arsInfos: ArInfos
    /**
     * Identity object. Together with `id_object_use_data`, it constitutes the identity credentials.
     */
    public var idObject: IdentityObject
    /**
     * Parts of the identity credentials created locally and not by the identity provider
     */
    public var idObjectUseData: IdObjectUseData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Identity provider information
         */ipInfo: IdentityProviderInfo, 
        /**
         * Public information on the __supported__ anonymity revokers.
         * Must include at least the anonymity revokers supported by the identity provider.
         * This is used to create and validate credential.
         */arsInfos: ArInfos, 
        /**
         * Identity object. Together with `id_object_use_data`, it constitutes the identity credentials.
         */idObject: IdentityObject, 
        /**
         * Parts of the identity credentials created locally and not by the identity provider
         */idObjectUseData: IdObjectUseData) {
        self.ipInfo = ipInfo
        self.arsInfos = arsInfos
        self.idObject = idObject
        self.idObjectUseData = idObjectUseData
    }

    

    
}

#if compiler(>=6)
extension OwnedIdentityCredentialProofPrivateInputs: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOwnedIdentityCredentialProofPrivateInputs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OwnedIdentityCredentialProofPrivateInputs {
        return
            try OwnedIdentityCredentialProofPrivateInputs(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf), 
                arsInfos: FfiConverterTypeArInfos.read(from: &buf), 
                idObject: FfiConverterTypeIdentityObject.read(from: &buf), 
                idObjectUseData: FfiConverterTypeIdObjectUseData.read(from: &buf)
        )
    }

    public static func write(_ value: OwnedIdentityCredentialProofPrivateInputs, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeArInfos.write(value.arsInfos, into: &buf)
        FfiConverterTypeIdentityObject.write(value.idObject, into: &buf)
        FfiConverterTypeIdObjectUseData.write(value.idObjectUseData, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOwnedIdentityCredentialProofPrivateInputs_lift(_ buf: RustBuffer) throws -> OwnedIdentityCredentialProofPrivateInputs {
    return try FfiConverterTypeOwnedIdentityCredentialProofPrivateInputs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOwnedIdentityCredentialProofPrivateInputs_lower(_ value: OwnedIdentityCredentialProofPrivateInputs) -> RustBuffer {
    return FfiConverterTypeOwnedIdentityCredentialProofPrivateInputs.lower(value)
}


/**
 * A policy is (currently) revealed values of attributes that are part of the identity object.
 * Policies are part of credentials.
 */
public struct Policy: Equatable, Hashable {
    public var createdAtYearMonth: String
    public var validToYearMonth: String
    public var revealedAttributes: [AttributeTag: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(createdAtYearMonth: String, validToYearMonth: String, revealedAttributes: [AttributeTag: String]) {
        self.createdAtYearMonth = createdAtYearMonth
        self.validToYearMonth = validToYearMonth
        self.revealedAttributes = revealedAttributes
    }

    

    
}

#if compiler(>=6)
extension Policy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePolicy: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Policy {
        return
            try Policy(
                createdAtYearMonth: FfiConverterString.read(from: &buf), 
                validToYearMonth: FfiConverterString.read(from: &buf), 
                revealedAttributes: FfiConverterDictionaryTypeAttributeTagString.read(from: &buf)
        )
    }

    public static func write(_ value: Policy, into buf: inout [UInt8]) {
        FfiConverterString.write(value.createdAtYearMonth, into: &buf)
        FfiConverterString.write(value.validToYearMonth, into: &buf)
        FfiConverterDictionaryTypeAttributeTagString.write(value.revealedAttributes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolicy_lift(_ buf: RustBuffer) throws -> Policy {
    return try FfiConverterTypePolicy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolicy_lower(_ value: Policy) -> RustBuffer {
    return FfiConverterTypePolicy.lower(value)
}


/**
 * Information sent from the account holder to the identity provider.
 * This includes only the cryptographic parts; the attribute list is in a different object below.
 * This is for the flow where no initial account is involved.
 */
public struct PreIdentityObject: Equatable, Hashable {
    public var idCredPub: Bytes
    /**
     * Anonymity revocation data for the chosen anonymity revokers.
     */
    public var ipArData: [UInt32: ArData]
    /**
     * Choice of anonyimity revocation parameters.
     * Identity provider checks that the values make sense in the context of the public keys they are allowed to use.
     */
    public var choiceArData: ChoiceArParameters
    /**
     * Commitment to ID cred sec using the commitment key of the identity provider derived from the PS public key.
     * This is used to compute the message that the identity provider signs.
     */
    public var idCredSecCommitment: Bytes
    /**
     * Commitment to the PRF key in group G1.
     */
    public var prfKeyCommitmentWithIp: Bytes
    /**
     * Commitments to the coefficients of the polynomial used to share the PRF key.
     */
    public var prfKeySharingCoeffCommitments: [Bytes]
    /**
     * Proof that the data sent to the identity provider is well-formed.
     */
    public var proofsOfKnowledge: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(idCredPub: Bytes, 
        /**
         * Anonymity revocation data for the chosen anonymity revokers.
         */ipArData: [UInt32: ArData], 
        /**
         * Choice of anonyimity revocation parameters.
         * Identity provider checks that the values make sense in the context of the public keys they are allowed to use.
         */choiceArData: ChoiceArParameters, 
        /**
         * Commitment to ID cred sec using the commitment key of the identity provider derived from the PS public key.
         * This is used to compute the message that the identity provider signs.
         */idCredSecCommitment: Bytes, 
        /**
         * Commitment to the PRF key in group G1.
         */prfKeyCommitmentWithIp: Bytes, 
        /**
         * Commitments to the coefficients of the polynomial used to share the PRF key.
         */prfKeySharingCoeffCommitments: [Bytes], 
        /**
         * Proof that the data sent to the identity provider is well-formed.
         */proofsOfKnowledge: Bytes) {
        self.idCredPub = idCredPub
        self.ipArData = ipArData
        self.choiceArData = choiceArData
        self.idCredSecCommitment = idCredSecCommitment
        self.prfKeyCommitmentWithIp = prfKeyCommitmentWithIp
        self.prfKeySharingCoeffCommitments = prfKeySharingCoeffCommitments
        self.proofsOfKnowledge = proofsOfKnowledge
    }

    

    
}

#if compiler(>=6)
extension PreIdentityObject: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePreIdentityObject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreIdentityObject {
        return
            try PreIdentityObject(
                idCredPub: FfiConverterTypeBytes.read(from: &buf), 
                ipArData: FfiConverterDictionaryUInt32TypeArData.read(from: &buf), 
                choiceArData: FfiConverterTypeChoiceArParameters.read(from: &buf), 
                idCredSecCommitment: FfiConverterTypeBytes.read(from: &buf), 
                prfKeyCommitmentWithIp: FfiConverterTypeBytes.read(from: &buf), 
                prfKeySharingCoeffCommitments: FfiConverterSequenceTypeBytes.read(from: &buf), 
                proofsOfKnowledge: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: PreIdentityObject, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.idCredPub, into: &buf)
        FfiConverterDictionaryUInt32TypeArData.write(value.ipArData, into: &buf)
        FfiConverterTypeChoiceArParameters.write(value.choiceArData, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSecCommitment, into: &buf)
        FfiConverterTypeBytes.write(value.prfKeyCommitmentWithIp, into: &buf)
        FfiConverterSequenceTypeBytes.write(value.prfKeySharingCoeffCommitments, into: &buf)
        FfiConverterTypeBytes.write(value.proofsOfKnowledge, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreIdentityObject_lift(_ buf: RustBuffer) throws -> PreIdentityObject {
    return try FfiConverterTypePreIdentityObject.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreIdentityObject_lower(_ value: PreIdentityObject) -> RustBuffer {
    return FfiConverterTypePreIdentityObject.lower(value)
}


/**
 * Verifiable presentation that contains verifiable credentials each
 * consisting of subject claims and proofs of them.
 */
public struct PresentationV1: Equatable, Hashable {
    public var presentationContext: ContextInformation
    public var verifiableCredentials: [CredentialV1]
    public var linkingProof: LinkingProofV1

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(presentationContext: ContextInformation, verifiableCredentials: [CredentialV1], linkingProof: LinkingProofV1) {
        self.presentationContext = presentationContext
        self.verifiableCredentials = verifiableCredentials
        self.linkingProof = linkingProof
    }

    

    
}

#if compiler(>=6)
extension PresentationV1: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePresentationV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PresentationV1 {
        return
            try PresentationV1(
                presentationContext: FfiConverterTypeContextInformation.read(from: &buf), 
                verifiableCredentials: FfiConverterSequenceTypeCredentialV1.read(from: &buf), 
                linkingProof: FfiConverterTypeLinkingProofV1.read(from: &buf)
        )
    }

    public static func write(_ value: PresentationV1, into buf: inout [UInt8]) {
        FfiConverterTypeContextInformation.write(value.presentationContext, into: &buf)
        FfiConverterSequenceTypeCredentialV1.write(value.verifiableCredentials, into: &buf)
        FfiConverterTypeLinkingProofV1.write(value.linkingProof, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresentationV1_lift(_ buf: RustBuffer) throws -> PresentationV1 {
    return try FfiConverterTypePresentationV1.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresentationV1_lower(_ value: PresentationV1) -> RustBuffer {
    return FfiConverterTypePresentationV1.lower(value)
}


/**
 * All proofs required to prove ownership of an identity in a credential deployment.
 */
public struct Proofs: Equatable, Hashable {
    /**
     * Challenge used for all of the proofs.
     */
    public var challenge: Bytes
    /**
     * List of commitments to the attributes.
     */
    public var commitments: Bytes
    /**
     * Proof that credential counter is at most equal to the maximum allowed number of account.
     */
    public var credCounterLessThanMaxAccounts: Bytes
    /**
     * Responses in the proof that the computed commitment to the share
     * contains the same value as the encryption.
     * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
     */
    public var proofIdCredPub: [String: Bytes]
    /**
     * Responses in the proof of knowledge of signature of the identity provider.
     */
    public var proofIpSig: Bytes
    /**
     * Proof that registration ID is valid and computed from the PRF key signed by the identity provider.
     */
    public var proofRegId: Bytes
    /**
     * (Blinded) signature derived from the signature on the pre-identity object by the identity provider.
     */
    public var signature: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Challenge used for all of the proofs.
         */challenge: Bytes, 
        /**
         * List of commitments to the attributes.
         */commitments: Bytes, 
        /**
         * Proof that credential counter is at most equal to the maximum allowed number of account.
         */credCounterLessThanMaxAccounts: Bytes, 
        /**
         * Responses in the proof that the computed commitment to the share
         * contains the same value as the encryption.
         * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
         */proofIdCredPub: [String: Bytes], 
        /**
         * Responses in the proof of knowledge of signature of the identity provider.
         */proofIpSig: Bytes, 
        /**
         * Proof that registration ID is valid and computed from the PRF key signed by the identity provider.
         */proofRegId: Bytes, 
        /**
         * (Blinded) signature derived from the signature on the pre-identity object by the identity provider.
         */signature: Bytes) {
        self.challenge = challenge
        self.commitments = commitments
        self.credCounterLessThanMaxAccounts = credCounterLessThanMaxAccounts
        self.proofIdCredPub = proofIdCredPub
        self.proofIpSig = proofIpSig
        self.proofRegId = proofRegId
        self.signature = signature
    }

    

    
}

#if compiler(>=6)
extension Proofs: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProofs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Proofs {
        return
            try Proofs(
                challenge: FfiConverterTypeBytes.read(from: &buf), 
                commitments: FfiConverterTypeBytes.read(from: &buf), 
                credCounterLessThanMaxAccounts: FfiConverterTypeBytes.read(from: &buf), 
                proofIdCredPub: FfiConverterDictionaryStringTypeBytes.read(from: &buf), 
                proofIpSig: FfiConverterTypeBytes.read(from: &buf), 
                proofRegId: FfiConverterTypeBytes.read(from: &buf), 
                signature: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Proofs, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.challenge, into: &buf)
        FfiConverterTypeBytes.write(value.commitments, into: &buf)
        FfiConverterTypeBytes.write(value.credCounterLessThanMaxAccounts, into: &buf)
        FfiConverterDictionaryStringTypeBytes.write(value.proofIdCredPub, into: &buf)
        FfiConverterTypeBytes.write(value.proofIpSig, into: &buf)
        FfiConverterTypeBytes.write(value.proofRegId, into: &buf)
        FfiConverterTypeBytes.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProofs_lift(_ buf: RustBuffer) throws -> Proofs {
    return try FfiConverterTypeProofs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProofs_lower(_ value: Proofs) -> RustBuffer {
    return FfiConverterTypeProofs.lower(value)
}


/**
 * Randomness that is generated to commit to attributes when creating a credential.
 * This randomness is needed to do something with those commitments later,
 * for example reveal the committed value or prove a property of the value.
 */
public struct Randomness: Equatable, Hashable {
    /**
     * Randomness used to commit to any user-chosen attributes, such as country of nationality.
     */
    public var attributesRand: [AttributeTag: Bytes]
    /**
     * Randomness of the commitment to the credential nonce.
     * This nonce is the number that is used to ensure that only a limited number of credentials
     * can be created from a given identity object.
     */
    public var credCounterRand: Bytes
    /**
     * Randomness of the commitment to idCredSec.
     */
    public var idCredSecRand: Bytes
    /**
     * Randomness of the commitment to the maximum number of accounts that may be created from the identity object.
     */
    public var maxAccountsRand: Bytes
    /**
     * Randomness of the commitment to the PRF key.
     */
    public var prfRand: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Randomness used to commit to any user-chosen attributes, such as country of nationality.
         */attributesRand: [AttributeTag: Bytes], 
        /**
         * Randomness of the commitment to the credential nonce.
         * This nonce is the number that is used to ensure that only a limited number of credentials
         * can be created from a given identity object.
         */credCounterRand: Bytes, 
        /**
         * Randomness of the commitment to idCredSec.
         */idCredSecRand: Bytes, 
        /**
         * Randomness of the commitment to the maximum number of accounts that may be created from the identity object.
         */maxAccountsRand: Bytes, 
        /**
         * Randomness of the commitment to the PRF key.
         */prfRand: Bytes) {
        self.attributesRand = attributesRand
        self.credCounterRand = credCounterRand
        self.idCredSecRand = idCredSecRand
        self.maxAccountsRand = maxAccountsRand
        self.prfRand = prfRand
    }

    

    
}

#if compiler(>=6)
extension Randomness: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRandomness: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Randomness {
        return
            try Randomness(
                attributesRand: FfiConverterDictionaryTypeAttributeTagTypeBytes.read(from: &buf), 
                credCounterRand: FfiConverterTypeBytes.read(from: &buf), 
                idCredSecRand: FfiConverterTypeBytes.read(from: &buf), 
                maxAccountsRand: FfiConverterTypeBytes.read(from: &buf), 
                prfRand: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Randomness, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeAttributeTagTypeBytes.write(value.attributesRand, into: &buf)
        FfiConverterTypeBytes.write(value.credCounterRand, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSecRand, into: &buf)
        FfiConverterTypeBytes.write(value.maxAccountsRand, into: &buf)
        FfiConverterTypeBytes.write(value.prfRand, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRandomness_lift(_ buf: RustBuffer) throws -> Randomness {
    return try FfiConverterTypeRandomness.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRandomness_lower(_ value: Randomness) -> RustBuffer {
    return FfiConverterTypeRandomness.lower(value)
}


/**
 * A request to prove a verifiable presentation [`PresentationV1`]
 */
public struct RequestV1: Equatable, Hashable {
    public var context: ContextInformation
    public var subjectClaims: [SubjectClaims]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(context: ContextInformation, subjectClaims: [SubjectClaims]) {
        self.context = context
        self.subjectClaims = subjectClaims
    }

    

    
}

#if compiler(>=6)
extension RequestV1: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestV1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestV1 {
        return
            try RequestV1(
                context: FfiConverterTypeContextInformation.read(from: &buf), 
                subjectClaims: FfiConverterSequenceTypeSubjectClaims.read(from: &buf)
        )
    }

    public static func write(_ value: RequestV1, into buf: inout [UInt8]) {
        FfiConverterTypeContextInformation.write(value.context, into: &buf)
        FfiConverterSequenceTypeSubjectClaims.write(value.subjectClaims, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestV1_lift(_ buf: RustBuffer) throws -> RequestV1 {
    return try FfiConverterTypeRequestV1.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestV1_lower(_ value: RequestV1) -> RustBuffer {
    return FfiConverterTypeRequestV1.lower(value)
}


/**
 * A subject claims request concerning the Concordium ID object (held by the credential holder
 * in the wallet).
 */
public struct RequestedIdentitySubjectClaims: Equatable, Hashable {
    public var statements: [RequestedStatement]
    public var issuers: [IdentityProviderDid]
    public var source: [IdentityCredentialType]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statements: [RequestedStatement], issuers: [IdentityProviderDid], source: [IdentityCredentialType]) {
        self.statements = statements
        self.issuers = issuers
        self.source = source
    }

    

    
}

#if compiler(>=6)
extension RequestedIdentitySubjectClaims: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestedIdentitySubjectClaims: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedIdentitySubjectClaims {
        return
            try RequestedIdentitySubjectClaims(
                statements: FfiConverterSequenceTypeRequestedStatement.read(from: &buf), 
                issuers: FfiConverterSequenceTypeIdentityProviderDid.read(from: &buf), 
                source: FfiConverterSequenceTypeIdentityCredentialType.read(from: &buf)
        )
    }

    public static func write(_ value: RequestedIdentitySubjectClaims, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeRequestedStatement.write(value.statements, into: &buf)
        FfiConverterSequenceTypeIdentityProviderDid.write(value.issuers, into: &buf)
        FfiConverterSequenceTypeIdentityCredentialType.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedIdentitySubjectClaims_lift(_ buf: RustBuffer) throws -> RequestedIdentitySubjectClaims {
    return try FfiConverterTypeRequestedIdentitySubjectClaims.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedIdentitySubjectClaims_lower(_ value: RequestedIdentitySubjectClaims) -> RustBuffer {
    return FfiConverterTypeRequestedIdentitySubjectClaims.lower(value)
}


/**
 * For the case where the verifier wants the user to show the value of an
 * attribute and prove that it is indeed the value inside the on-chain
 * commitment. Since the verifier does not know the attribute value before
 * seeing the proof, the value is not present here.
 */
public struct RevealAttributeIdentityStatement: Equatable, Hashable {
    /**
     * The attribute that the verifier wants the user to reveal.
     */
    public var attributeTag: AttributeTag

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to reveal.
         */attributeTag: AttributeTag) {
        self.attributeTag = attributeTag
    }

    

    
}

#if compiler(>=6)
extension RevealAttributeIdentityStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRevealAttributeIdentityStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RevealAttributeIdentityStatement {
        return
            try RevealAttributeIdentityStatement(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf)
        )
    }

    public static func write(_ value: RevealAttributeIdentityStatement, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRevealAttributeIdentityStatement_lift(_ buf: RustBuffer) throws -> RevealAttributeIdentityStatement {
    return try FfiConverterTypeRevealAttributeIdentityStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRevealAttributeIdentityStatement_lower(_ value: RevealAttributeIdentityStatement) -> RustBuffer {
    return FfiConverterTypeRevealAttributeIdentityStatement.lower(value)
}


/**
 * For the case where the verifier wants the user to show the value of an
 * attribute and prove that it is indeed the value inside the on-chain
 * commitment. Since the verifier does not know the attribute value before
 * seeing the proof, the value is not present here.
 */
public struct RevealAttributeWeb3IdStatement: Equatable, Hashable {
    /**
     * The attribute that the verifier wants the user to reveal.
     */
    public var attributeTag: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to reveal.
         */attributeTag: String) {
        self.attributeTag = attributeTag
    }

    

    
}

#if compiler(>=6)
extension RevealAttributeWeb3IdStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRevealAttributeWeb3IdStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RevealAttributeWeb3IdStatement {
        return
            try RevealAttributeWeb3IdStatement(
                attributeTag: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RevealAttributeWeb3IdStatement, into buf: inout [UInt8]) {
        FfiConverterString.write(value.attributeTag, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRevealAttributeWeb3IdStatement_lift(_ buf: RustBuffer) throws -> RevealAttributeWeb3IdStatement {
    return try FfiConverterTypeRevealAttributeWeb3IdStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRevealAttributeWeb3IdStatement_lower(_ value: RevealAttributeWeb3IdStatement) -> RustBuffer {
    return FfiConverterTypeRevealAttributeWeb3IdStatement.lower(value)
}


/**
 * The payload data for a TransferToPublic transaction
 */
public struct SecToPubTransferData: Equatable, Hashable {
    /**
     * The serialized remaining amount after deducting the amount to transfer
     * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::EncryptedAmount`]
     */
    public var remainingAmount: Bytes
    /**
     * The amount to transfer in microCCD.
     */
    public var transferAmount: MicroCcdAmount
    /**
     * The transfer index of the transfer
     */
    public var index: UInt64
    /**
     * The serialized proof that the transfer is correct.
     * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::SecToPubAmountTransferProof`]
     */
    public var proof: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The serialized remaining amount after deducting the amount to transfer
         * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::EncryptedAmount`]
         */remainingAmount: Bytes, 
        /**
         * The amount to transfer in microCCD.
         */transferAmount: MicroCcdAmount, 
        /**
         * The transfer index of the transfer
         */index: UInt64, 
        /**
         * The serialized proof that the transfer is correct.
         * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::SecToPubAmountTransferProof`]
         */proof: Bytes) {
        self.remainingAmount = remainingAmount
        self.transferAmount = transferAmount
        self.index = index
        self.proof = proof
    }

    

    
}

#if compiler(>=6)
extension SecToPubTransferData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecToPubTransferData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecToPubTransferData {
        return
            try SecToPubTransferData(
                remainingAmount: FfiConverterTypeBytes.read(from: &buf), 
                transferAmount: FfiConverterTypeMicroCCDAmount.read(from: &buf), 
                index: FfiConverterUInt64.read(from: &buf), 
                proof: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: SecToPubTransferData, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.remainingAmount, into: &buf)
        FfiConverterTypeMicroCCDAmount.write(value.transferAmount, into: &buf)
        FfiConverterUInt64.write(value.index, into: &buf)
        FfiConverterTypeBytes.write(value.proof, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecToPubTransferData_lift(_ buf: RustBuffer) throws -> SecToPubTransferData {
    return try FfiConverterTypeSecToPubTransferData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecToPubTransferData_lower(_ value: SecToPubTransferData) -> RustBuffer {
    return FfiConverterTypeSecToPubTransferData.lower(value)
}


public struct SecToPubTransferDataDeserializeResult: Equatable, Hashable {
    public var value: SecToPubTransferData
    public var bytesRead: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: SecToPubTransferData, bytesRead: UInt64) {
        self.value = value
        self.bytesRead = bytesRead
    }

    

    
}

#if compiler(>=6)
extension SecToPubTransferDataDeserializeResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecToPubTransferDataDeserializeResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecToPubTransferDataDeserializeResult {
        return
            try SecToPubTransferDataDeserializeResult(
                value: FfiConverterTypeSecToPubTransferData.read(from: &buf), 
                bytesRead: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SecToPubTransferDataDeserializeResult, into buf: inout [UInt8]) {
        FfiConverterTypeSecToPubTransferData.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.bytesRead, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecToPubTransferDataDeserializeResult_lift(_ buf: RustBuffer) throws -> SecToPubTransferDataDeserializeResult {
    return try FfiConverterTypeSecToPubTransferDataDeserializeResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecToPubTransferDataDeserializeResult_lower(_ value: SecToPubTransferDataDeserializeResult) -> RustBuffer {
    return FfiConverterTypeSecToPubTransferDataDeserializeResult.lower(value)
}


/**
 * The credential deployment context required to serialize a credential deployment for submission to the chain.
 */
public struct SignedAccountCredential: Equatable, Hashable {
    public var credential: AccountCredential
    public var signatures: [UInt8: Bytes]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(credential: AccountCredential, signatures: [UInt8: Bytes]) {
        self.credential = credential
        self.signatures = signatures
    }

    

    
}

#if compiler(>=6)
extension SignedAccountCredential: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignedAccountCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedAccountCredential {
        return
            try SignedAccountCredential(
                credential: FfiConverterTypeAccountCredential.read(from: &buf), 
                signatures: FfiConverterDictionaryUInt8TypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: SignedAccountCredential, into buf: inout [UInt8]) {
        FfiConverterTypeAccountCredential.write(value.credential, into: &buf)
        FfiConverterDictionaryUInt8TypeBytes.write(value.signatures, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedAccountCredential_lift(_ buf: RustBuffer) throws -> SignedAccountCredential {
    return try FfiConverterTypeSignedAccountCredential.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedAccountCredential_lower(_ value: SignedAccountCredential) -> RustBuffer {
    return FfiConverterTypeSignedAccountCredential.lower(value)
}


/**
 * Commitments signed by the issuer.
 */
public struct SignedCommitments: Equatable, Hashable {
    public var signature: Bytes
    public var commitments: [String: Bytes]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signature: Bytes, commitments: [String: Bytes]) {
        self.signature = signature
        self.commitments = commitments
    }

    

    
}

#if compiler(>=6)
extension SignedCommitments: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignedCommitments: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedCommitments {
        return
            try SignedCommitments(
                signature: FfiConverterTypeBytes.read(from: &buf), 
                commitments: FfiConverterDictionaryStringTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: SignedCommitments, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.signature, into: &buf)
        FfiConverterDictionaryStringTypeBytes.write(value.commitments, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedCommitments_lift(_ buf: RustBuffer) throws -> SignedCommitments {
    return try FfiConverterTypeSignedCommitments.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedCommitments_lower(_ value: SignedCommitments) -> RustBuffer {
    return FfiConverterTypeSignedCommitments.lower(value)
}


/**
 * Represents a schema for a specific type used in a contract.
 */
public struct TypeSchema: Equatable, Hashable {
    /**
     * The type schema serialized as bytes.
     */
    public var value: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The type schema serialized as bytes.
         */value: Data) {
        self.value = value
    }

    

    
}

#if compiler(>=6)
extension TypeSchema: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTypeSchema: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypeSchema {
        return
            try TypeSchema(
                value: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: TypeSchema, into buf: inout [UInt8]) {
        FfiConverterData.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTypeSchema_lift(_ buf: RustBuffer) throws -> TypeSchema {
    return try FfiConverterTypeTypeSchema.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTypeSchema_lower(_ value: TypeSchema) -> RustBuffer {
    return FfiConverterTypeTypeSchema.lower(value)
}


/**
 * Context information for a verification request.
 */
public struct UnfilledContextInformation: Equatable, Hashable {
    public var given: [LabeledContextProperty]
    public var requested: [ContextLabel]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(given: [LabeledContextProperty], requested: [ContextLabel]) {
        self.given = given
        self.requested = requested
    }

    

    
}

#if compiler(>=6)
extension UnfilledContextInformation: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnfilledContextInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnfilledContextInformation {
        return
            try UnfilledContextInformation(
                given: FfiConverterSequenceTypeLabeledContextProperty.read(from: &buf), 
                requested: FfiConverterSequenceTypeContextLabel.read(from: &buf)
        )
    }

    public static func write(_ value: UnfilledContextInformation, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeLabeledContextProperty.write(value.given, into: &buf)
        FfiConverterSequenceTypeContextLabel.write(value.requested, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnfilledContextInformation_lift(_ buf: RustBuffer) throws -> UnfilledContextInformation {
    return try FfiConverterTypeUnfilledContextInformation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnfilledContextInformation_lower(_ value: UnfilledContextInformation) -> RustBuffer {
    return FfiConverterTypeUnfilledContextInformation.lower(value)
}


public struct UpdateCredentialsPayload: Equatable, Hashable {
    /**
     * Credential infos and the respective indices to insert them at
     */
    public var newCredInfos: [UInt8: CredentialDeploymentInfo]
    /**
     * List of credentials to remove
     */
    public var removeCredIds: [Bytes]
    /**
     * The new threshold of the account
     */
    public var newThreshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Credential infos and the respective indices to insert them at
         */newCredInfos: [UInt8: CredentialDeploymentInfo], 
        /**
         * List of credentials to remove
         */removeCredIds: [Bytes], 
        /**
         * The new threshold of the account
         */newThreshold: UInt8) {
        self.newCredInfos = newCredInfos
        self.removeCredIds = removeCredIds
        self.newThreshold = newThreshold
    }

    

    
}

#if compiler(>=6)
extension UpdateCredentialsPayload: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdateCredentialsPayload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateCredentialsPayload {
        return
            try UpdateCredentialsPayload(
                newCredInfos: FfiConverterDictionaryUInt8TypeCredentialDeploymentInfo.read(from: &buf), 
                removeCredIds: FfiConverterSequenceTypeBytes.read(from: &buf), 
                newThreshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateCredentialsPayload, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt8TypeCredentialDeploymentInfo.write(value.newCredInfos, into: &buf)
        FfiConverterSequenceTypeBytes.write(value.removeCredIds, into: &buf)
        FfiConverterUInt8.write(value.newThreshold, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateCredentialsPayload_lift(_ buf: RustBuffer) throws -> UpdateCredentialsPayload {
    return try FfiConverterTypeUpdateCredentialsPayload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateCredentialsPayload_lower(_ value: UpdateCredentialsPayload) -> RustBuffer {
    return FfiConverterTypeUpdateCredentialsPayload.lower(value)
}


public struct UpdateCredentialsPayloadDeserializeResult: Equatable, Hashable {
    public var value: UpdateCredentialsPayload
    public var bytesRead: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UpdateCredentialsPayload, bytesRead: UInt64) {
        self.value = value
        self.bytesRead = bytesRead
    }

    

    
}

#if compiler(>=6)
extension UpdateCredentialsPayloadDeserializeResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdateCredentialsPayloadDeserializeResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateCredentialsPayloadDeserializeResult {
        return
            try UpdateCredentialsPayloadDeserializeResult(
                value: FfiConverterTypeUpdateCredentialsPayload.read(from: &buf), 
                bytesRead: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateCredentialsPayloadDeserializeResult, into buf: inout [UInt8]) {
        FfiConverterTypeUpdateCredentialsPayload.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.bytesRead, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateCredentialsPayloadDeserializeResult_lift(_ buf: RustBuffer) throws -> UpdateCredentialsPayloadDeserializeResult {
    return try FfiConverterTypeUpdateCredentialsPayloadDeserializeResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateCredentialsPayloadDeserializeResult_lower(_ value: UpdateCredentialsPayloadDeserializeResult) -> RustBuffer {
    return FfiConverterTypeUpdateCredentialsPayloadDeserializeResult.lower(value)
}


/**
 * A presentation is the response to a `VerifiableCredentialRequest`. It contains proofs for
 * statements, ownership proof for all Web3 credentials, and a context. The
 * only missing part to verify the proof are the public commitments.
 */
public struct VerifiablePresentation: Equatable, Hashable {
    public var presentationContext: Bytes
    public var verifiableCredential: [VerifiableCredentialProof]
    /**
     * Signatures from keys of Web3 credentials (not from ID credentials).
     * The order is the same as that in the `credential_proofs` field.
     */
    public var linkingProof: LinkingProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(presentationContext: Bytes, verifiableCredential: [VerifiableCredentialProof], 
        /**
         * Signatures from keys of Web3 credentials (not from ID credentials).
         * The order is the same as that in the `credential_proofs` field.
         */linkingProof: LinkingProof) {
        self.presentationContext = presentationContext
        self.verifiableCredential = verifiableCredential
        self.linkingProof = linkingProof
    }

    

    
}

#if compiler(>=6)
extension VerifiablePresentation: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerifiablePresentation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiablePresentation {
        return
            try VerifiablePresentation(
                presentationContext: FfiConverterTypeBytes.read(from: &buf), 
                verifiableCredential: FfiConverterSequenceTypeVerifiableCredentialProof.read(from: &buf), 
                linkingProof: FfiConverterTypeLinkingProof.read(from: &buf)
        )
    }

    public static func write(_ value: VerifiablePresentation, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.presentationContext, into: &buf)
        FfiConverterSequenceTypeVerifiableCredentialProof.write(value.verifiableCredential, into: &buf)
        FfiConverterTypeLinkingProof.write(value.linkingProof, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiablePresentation_lift(_ buf: RustBuffer) throws -> VerifiablePresentation {
    return try FfiConverterTypeVerifiablePresentation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiablePresentation_lower(_ value: VerifiablePresentation) -> RustBuffer {
    return FfiConverterTypeVerifiablePresentation.lower(value)
}


/**
 * A request for a proof. This is the statement and challenge. The secret data
 * comes separately.
 */
public struct VerifiablePresentationRequest: Equatable, Hashable {
    public var challenge: Bytes
    public var statements: [VerifiableCredentialStatement]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(challenge: Bytes, statements: [VerifiableCredentialStatement]) {
        self.challenge = challenge
        self.statements = statements
    }

    

    
}

#if compiler(>=6)
extension VerifiablePresentationRequest: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerifiablePresentationRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiablePresentationRequest {
        return
            try VerifiablePresentationRequest(
                challenge: FfiConverterTypeBytes.read(from: &buf), 
                statements: FfiConverterSequenceTypeVerifiableCredentialStatement.read(from: &buf)
        )
    }

    public static func write(_ value: VerifiablePresentationRequest, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.challenge, into: &buf)
        FfiConverterSequenceTypeVerifiableCredentialStatement.write(value.statements, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiablePresentationRequest_lift(_ buf: RustBuffer) throws -> VerifiablePresentationRequest {
    return try FfiConverterTypeVerifiablePresentationRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiablePresentationRequest_lower(_ value: VerifiablePresentationRequest) -> RustBuffer {
    return FfiConverterTypeVerifiablePresentationRequest.lower(value)
}


/**
 * Data that constitutes a verification request to create a verifiable presentation.
 * Described the subject claims being requested from a credential holder.
 */
public struct VerificationRequestData: Equatable, Hashable {
    public var context: UnfilledContextInformation
    public var subjectClaims: [RequestedSubjectClaims]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(context: UnfilledContextInformation, subjectClaims: [RequestedSubjectClaims]) {
        self.context = context
        self.subjectClaims = subjectClaims
    }

    

    
}

#if compiler(>=6)
extension VerificationRequestData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerificationRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationRequestData {
        return
            try VerificationRequestData(
                context: FfiConverterTypeUnfilledContextInformation.read(from: &buf), 
                subjectClaims: FfiConverterSequenceTypeRequestedSubjectClaims.read(from: &buf)
        )
    }

    public static func write(_ value: VerificationRequestData, into buf: inout [UInt8]) {
        FfiConverterTypeUnfilledContextInformation.write(value.context, into: &buf)
        FfiConverterSequenceTypeRequestedSubjectClaims.write(value.subjectClaims, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerificationRequestData_lift(_ buf: RustBuffer) throws -> VerificationRequestData {
    return try FfiConverterTypeVerificationRequestData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerificationRequestData_lower(_ value: VerificationRequestData) -> RustBuffer {
    return FfiConverterTypeVerificationRequestData.lower(value)
}


/**
 * Public AKA verification key for a given scheme.
 * Currently the only supported value of `scheme_id` is "Ed25519".
 */
public struct VerifyKey: Equatable, Hashable {
    public var schemeId: String
    public var key: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(schemeId: String, key: Bytes) {
        self.schemeId = schemeId
        self.key = key
    }

    

    
}

#if compiler(>=6)
extension VerifyKey: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerifyKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifyKey {
        return
            try VerifyKey(
                schemeId: FfiConverterString.read(from: &buf), 
                key: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: VerifyKey, into buf: inout [UInt8]) {
        FfiConverterString.write(value.schemeId, into: &buf)
        FfiConverterTypeBytes.write(value.key, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifyKey_lift(_ buf: RustBuffer) throws -> VerifyKey {
    return try FfiConverterTypeVerifyKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifyKey_lower(_ value: VerifyKey) -> RustBuffer {
    return FfiConverterTypeVerifyKey.lower(value)
}


/**
 * A versioned variant of `IdentityProof`
 */
public struct VersionedIdentityProof: Equatable, Hashable {
    /**
     * The version associated with the value
     */
    public var version: UInt32
    /**
     * The proof
     */
    public var value: IdentityProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The version associated with the value
         */version: UInt32, 
        /**
         * The proof
         */value: IdentityProof) {
        self.version = version
        self.value = value
    }

    

    
}

#if compiler(>=6)
extension VersionedIdentityProof: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVersionedIdentityProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VersionedIdentityProof {
        return
            try VersionedIdentityProof(
                version: FfiConverterUInt32.read(from: &buf), 
                value: FfiConverterTypeIdentityProof.read(from: &buf)
        )
    }

    public static func write(_ value: VersionedIdentityProof, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.version, into: &buf)
        FfiConverterTypeIdentityProof.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVersionedIdentityProof_lift(_ buf: RustBuffer) throws -> VersionedIdentityProof {
    return try FfiConverterTypeVersionedIdentityProof.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVersionedIdentityProof_lower(_ value: VersionedIdentityProof) -> RustBuffer {
    return FfiConverterTypeVersionedIdentityProof.lower(value)
}


/**
 * A full verifiable credential for Web3 ID credentials, including secrets.
 */
public struct Web3IdCredential: Equatable, Hashable {
    /**
     * The credential holder's public key.
     */
    public var holderId: Bytes
    /**
     * The network to which the credential applies.
     */
    public var network: Network
    /**
     * The address of the credential registry where the credential is tracked.
     */
    public var registry: ContractAddress
    /**
     * Credential type describing what kind of a credential it is.
     */
    public var credentialType: [String]
    /**
     * Link to the credential schema.
     */
    public var credentialSchema: String
    /**
     * The issuer's public key.
     */
    public var issuerKey: Bytes
    /**
     * Start of the validity of the credential.
     */
    public var validFrom: Date
    /**
     * After this date, the credential becomes expired. `None` corresponds to a
     * credential that cannot expire.
     */
    public var validUntil: Date?
    /**
     * The values of different attributes, indexed by attribute tags.
     */
    public var values: [String: Web3IdAttribute]
    /**
     * The randomness to go along with commitments in `values`. This has to
     * have the same keys as the `values` field, but it is more
     * convenient if it is a separate map itself.
     */
    public var randomness: [String: Bytes]
    /**
     * The signature on the holder's public key, the contract address of the
     * issuer, and the commitments from the issuer.
     */
    public var signature: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The credential holder's public key.
         */holderId: Bytes, 
        /**
         * The network to which the credential applies.
         */network: Network, 
        /**
         * The address of the credential registry where the credential is tracked.
         */registry: ContractAddress, 
        /**
         * Credential type describing what kind of a credential it is.
         */credentialType: [String], 
        /**
         * Link to the credential schema.
         */credentialSchema: String, 
        /**
         * The issuer's public key.
         */issuerKey: Bytes, 
        /**
         * Start of the validity of the credential.
         */validFrom: Date, 
        /**
         * After this date, the credential becomes expired. `None` corresponds to a
         * credential that cannot expire.
         */validUntil: Date?, 
        /**
         * The values of different attributes, indexed by attribute tags.
         */values: [String: Web3IdAttribute], 
        /**
         * The randomness to go along with commitments in `values`. This has to
         * have the same keys as the `values` field, but it is more
         * convenient if it is a separate map itself.
         */randomness: [String: Bytes], 
        /**
         * The signature on the holder's public key, the contract address of the
         * issuer, and the commitments from the issuer.
         */signature: Bytes) {
        self.holderId = holderId
        self.network = network
        self.registry = registry
        self.credentialType = credentialType
        self.credentialSchema = credentialSchema
        self.issuerKey = issuerKey
        self.validFrom = validFrom
        self.validUntil = validUntil
        self.values = values
        self.randomness = randomness
        self.signature = signature
    }

    

    
}

#if compiler(>=6)
extension Web3IdCredential: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWeb3IdCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Web3IdCredential {
        return
            try Web3IdCredential(
                holderId: FfiConverterTypeBytes.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                registry: FfiConverterTypeContractAddress.read(from: &buf), 
                credentialType: FfiConverterSequenceString.read(from: &buf), 
                credentialSchema: FfiConverterString.read(from: &buf), 
                issuerKey: FfiConverterTypeBytes.read(from: &buf), 
                validFrom: FfiConverterTimestamp.read(from: &buf), 
                validUntil: FfiConverterOptionTimestamp.read(from: &buf), 
                values: FfiConverterDictionaryStringTypeWeb3IdAttribute.read(from: &buf), 
                randomness: FfiConverterDictionaryStringTypeBytes.read(from: &buf), 
                signature: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Web3IdCredential, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.holderId, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterTypeContractAddress.write(value.registry, into: &buf)
        FfiConverterSequenceString.write(value.credentialType, into: &buf)
        FfiConverterString.write(value.credentialSchema, into: &buf)
        FfiConverterTypeBytes.write(value.issuerKey, into: &buf)
        FfiConverterTimestamp.write(value.validFrom, into: &buf)
        FfiConverterOptionTimestamp.write(value.validUntil, into: &buf)
        FfiConverterDictionaryStringTypeWeb3IdAttribute.write(value.values, into: &buf)
        FfiConverterDictionaryStringTypeBytes.write(value.randomness, into: &buf)
        FfiConverterTypeBytes.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWeb3IdCredential_lift(_ buf: RustBuffer) throws -> Web3IdCredential {
    return try FfiConverterTypeWeb3IdCredential.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWeb3IdCredential_lower(_ value: Web3IdCredential) -> RustBuffer {
    return FfiConverterTypeWeb3IdCredential.lower(value)
}


/**
 * A pair of a statement and a proof for a Web3 ID credential statement.
 */
public struct Web3IdStatementWithProof: Equatable, Hashable {
    public var statement: AtomicWeb3IdStatement
    public var proof: AtomicWeb3IdProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statement: AtomicWeb3IdStatement, proof: AtomicWeb3IdProof) {
        self.statement = statement
        self.proof = proof
    }

    

    
}

#if compiler(>=6)
extension Web3IdStatementWithProof: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWeb3IdStatementWithProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Web3IdStatementWithProof {
        return
            try Web3IdStatementWithProof(
                statement: FfiConverterTypeAtomicWeb3IdStatement.read(from: &buf), 
                proof: FfiConverterTypeAtomicWeb3IdProof.read(from: &buf)
        )
    }

    public static func write(_ value: Web3IdStatementWithProof, into buf: inout [UInt8]) {
        FfiConverterTypeAtomicWeb3IdStatement.write(value.statement, into: &buf)
        FfiConverterTypeAtomicWeb3IdProof.write(value.proof, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWeb3IdStatementWithProof_lift(_ buf: RustBuffer) throws -> Web3IdStatementWithProof {
    return try FfiConverterTypeWeb3IdStatementWithProof.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWeb3IdStatementWithProof_lower(_ value: Web3IdStatementWithProof) -> RustBuffer {
    return FfiConverterTypeWeb3IdStatementWithProof.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The different types of proofs, corresponding to the statements above.
 */

public enum AtomicIdentityProof: Equatable, Hashable {
    
    /**
     * Revealing an attribute and a proof that it equals the attribute value
     * inside the attribute commitment.
     */
    case revealAttribute(attribute: String, proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is in a range.
     */
    case attributeInRange(proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is in a set.
     */
    case attributeInSet(proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is not in a set.
     */
    case attributeNotInSet(proof: Bytes
    )





}

#if compiler(>=6)
extension AtomicIdentityProof: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAtomicIdentityProof: FfiConverterRustBuffer {
    typealias SwiftType = AtomicIdentityProof

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AtomicIdentityProof {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .revealAttribute(attribute: try FfiConverterString.read(from: &buf), proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 2: return .attributeInRange(proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 3: return .attributeInSet(proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 4: return .attributeNotInSet(proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AtomicIdentityProof, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .revealAttribute(attribute,proof):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(attribute, into: &buf)
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeInRange(proof):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeInSet(proof):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeNotInSet(proof):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAtomicIdentityProof_lift(_ buf: RustBuffer) throws -> AtomicIdentityProof {
    return try FfiConverterTypeAtomicIdentityProof.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAtomicIdentityProof_lower(_ value: AtomicIdentityProof) -> RustBuffer {
    return FfiConverterTypeAtomicIdentityProof.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Statements are composed of one or more atomic statements.
 * This type defines the different types of atomic statements.
 */

public enum AtomicIdentityStatement: Equatable, Hashable {
    
    /**
     * The atomic statement stating that an attribute should be revealed.
     */
    case revealAttribute(statement: RevealAttributeIdentityStatement
    )
    /**
     * The atomic statement stating that an attribute is in a range.
     */
    case attributeInRange(statement: AttributeInRangeIdentityStatement
    )
    /**
     * The atomic statement stating that an attribute is in a set.
     */
    case attributeInSet(statement: AttributeInSetIdentityStatement
    )
    /**
     * The atomic statement stating that an attribute is not in a set.
     */
    case attributeNotInSet(statement: AttributeNotInSetIdentityStatement
    )





}

#if compiler(>=6)
extension AtomicIdentityStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAtomicIdentityStatement: FfiConverterRustBuffer {
    typealias SwiftType = AtomicIdentityStatement

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AtomicIdentityStatement {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .revealAttribute(statement: try FfiConverterTypeRevealAttributeIdentityStatement.read(from: &buf)
        )
        
        case 2: return .attributeInRange(statement: try FfiConverterTypeAttributeInRangeIdentityStatement.read(from: &buf)
        )
        
        case 3: return .attributeInSet(statement: try FfiConverterTypeAttributeInSetIdentityStatement.read(from: &buf)
        )
        
        case 4: return .attributeNotInSet(statement: try FfiConverterTypeAttributeNotInSetIdentityStatement.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AtomicIdentityStatement, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .revealAttribute(statement):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRevealAttributeIdentityStatement.write(statement, into: &buf)
            
        
        case let .attributeInRange(statement):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAttributeInRangeIdentityStatement.write(statement, into: &buf)
            
        
        case let .attributeInSet(statement):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAttributeInSetIdentityStatement.write(statement, into: &buf)
            
        
        case let .attributeNotInSet(statement):
            writeInt(&buf, Int32(4))
            FfiConverterTypeAttributeNotInSetIdentityStatement.write(statement, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAtomicIdentityStatement_lift(_ buf: RustBuffer) throws -> AtomicIdentityStatement {
    return try FfiConverterTypeAtomicIdentityStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAtomicIdentityStatement_lower(_ value: AtomicIdentityStatement) -> RustBuffer {
    return FfiConverterTypeAtomicIdentityStatement.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The types of statements that can be used in subject claims
 */

public enum AtomicStatementV1: Equatable, Hashable {
    
    case attributeValue(statement: AttributeValueIdentityStatementV1
    )
    case attributeInRange(statement: AttributeInRangeIdentityStatementV1
    )
    case attributeInSet(statement: AttributeInSetIdentityStatementV1
    )
    case attributeNotInSet(statement: AttributeNotInSetIdentityStatementV1
    )





}

#if compiler(>=6)
extension AtomicStatementV1: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAtomicStatementV1: FfiConverterRustBuffer {
    typealias SwiftType = AtomicStatementV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AtomicStatementV1 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .attributeValue(statement: try FfiConverterTypeAttributeValueIdentityStatementV1.read(from: &buf)
        )
        
        case 2: return .attributeInRange(statement: try FfiConverterTypeAttributeInRangeIdentityStatementV1.read(from: &buf)
        )
        
        case 3: return .attributeInSet(statement: try FfiConverterTypeAttributeInSetIdentityStatementV1.read(from: &buf)
        )
        
        case 4: return .attributeNotInSet(statement: try FfiConverterTypeAttributeNotInSetIdentityStatementV1.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AtomicStatementV1, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .attributeValue(statement):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAttributeValueIdentityStatementV1.write(statement, into: &buf)
            
        
        case let .attributeInRange(statement):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAttributeInRangeIdentityStatementV1.write(statement, into: &buf)
            
        
        case let .attributeInSet(statement):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAttributeInSetIdentityStatementV1.write(statement, into: &buf)
            
        
        case let .attributeNotInSet(statement):
            writeInt(&buf, Int32(4))
            FfiConverterTypeAttributeNotInSetIdentityStatementV1.write(statement, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAtomicStatementV1_lift(_ buf: RustBuffer) throws -> AtomicStatementV1 {
    return try FfiConverterTypeAtomicStatementV1.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAtomicStatementV1_lower(_ value: AtomicStatementV1) -> RustBuffer {
    return FfiConverterTypeAtomicStatementV1.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The different types of proofs, corresponding to the statements above.
 */

public enum AtomicWeb3IdProof: Equatable, Hashable {
    
    /**
     * Revealing an attribute and a proof that it equals the attribute value
     * inside the attribute commitment.
     */
    case revealAttribute(attribute: Web3IdAttribute, proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is in a range.
     */
    case attributeInRange(proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is in a set.
     */
    case attributeInSet(proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is not in a set.
     */
    case attributeNotInSet(proof: Bytes
    )





}

#if compiler(>=6)
extension AtomicWeb3IdProof: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAtomicWeb3IdProof: FfiConverterRustBuffer {
    typealias SwiftType = AtomicWeb3IdProof

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AtomicWeb3IdProof {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .revealAttribute(attribute: try FfiConverterTypeWeb3IdAttribute.read(from: &buf), proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 2: return .attributeInRange(proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 3: return .attributeInSet(proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 4: return .attributeNotInSet(proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AtomicWeb3IdProof, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .revealAttribute(attribute,proof):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWeb3IdAttribute.write(attribute, into: &buf)
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeInRange(proof):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeInSet(proof):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeNotInSet(proof):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAtomicWeb3IdProof_lift(_ buf: RustBuffer) throws -> AtomicWeb3IdProof {
    return try FfiConverterTypeAtomicWeb3IdProof.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAtomicWeb3IdProof_lower(_ value: AtomicWeb3IdProof) -> RustBuffer {
    return FfiConverterTypeAtomicWeb3IdProof.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Statements are composed of one or more atomic statements.
 * This type defines the different types of atomic statements.
 */

public enum AtomicWeb3IdStatement: Equatable, Hashable {
    
    /**
     * The atomic statement stating that an attribute should be revealed.
     */
    case revealAttribute(statement: RevealAttributeWeb3IdStatement
    )
    /**
     * The atomic statement stating that an attribute is in a range.
     */
    case attributeInRange(statement: AttributeInRangeWeb3IdStatement
    )
    /**
     * The atomic statement stating that an attribute is in a set.
     */
    case attributeInSet(statement: AttributeInSetWeb3IdStatement
    )
    /**
     * The atomic statement stating that an attribute is not in a set.
     */
    case attributeNotInSet(statement: AttributeNotInSetWeb3IdStatement
    )





}

#if compiler(>=6)
extension AtomicWeb3IdStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAtomicWeb3IdStatement: FfiConverterRustBuffer {
    typealias SwiftType = AtomicWeb3IdStatement

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AtomicWeb3IdStatement {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .revealAttribute(statement: try FfiConverterTypeRevealAttributeWeb3IdStatement.read(from: &buf)
        )
        
        case 2: return .attributeInRange(statement: try FfiConverterTypeAttributeInRangeWeb3IdStatement.read(from: &buf)
        )
        
        case 3: return .attributeInSet(statement: try FfiConverterTypeAttributeInSetWeb3IdStatement.read(from: &buf)
        )
        
        case 4: return .attributeNotInSet(statement: try FfiConverterTypeAttributeNotInSetWeb3IdStatement.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AtomicWeb3IdStatement, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .revealAttribute(statement):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRevealAttributeWeb3IdStatement.write(statement, into: &buf)
            
        
        case let .attributeInRange(statement):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAttributeInRangeWeb3IdStatement.write(statement, into: &buf)
            
        
        case let .attributeInSet(statement):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAttributeInSetWeb3IdStatement.write(statement, into: &buf)
            
        
        case let .attributeNotInSet(statement):
            writeInt(&buf, Int32(4))
            FfiConverterTypeAttributeNotInSetWeb3IdStatement.write(statement, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAtomicWeb3IdStatement_lift(_ buf: RustBuffer) throws -> AtomicWeb3IdStatement {
    return try FfiConverterTypeAtomicWeb3IdStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAtomicWeb3IdStatement_lower(_ value: AtomicWeb3IdStatement) -> RustBuffer {
    return FfiConverterTypeAtomicWeb3IdStatement.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The supported set of attributes which are stored on identities and optionally revealed by accounts.
 * In some contexts (such as the gRPC API), attribute tags are represented by a byte (the raw type of this enum).
 * Where human readability is a concern, the string representation implemented by ``description`` is used.
 * Note that since ``AttributeList`` (which is a component of ``IdentityObject``) is defined in another library, it cannot use this type.
 * Instead, its field `chosenAttributes` is a map from the string representation of the tag to the value.
 * Use the appropriate initializer of this type to convert it.
 * All attribute values are strings of 31 bytes or less. The expected format of the values is documented
 * [here](https://docs.google.com/spreadsheets/d/1CxpFvtAoUcylHQyeBtRBaRt1zsibtpmQOVsk7bsHPGA/edit).
 */

public enum AttributeTag: Equatable, Hashable {
    
    /**
     * First name (format: string up to 31 bytes).
     */
    case firstName
    /**
     * Last name (format: string up to 31 bytes).
     */
    case lastName
    /**
     * Sex (format: ISO/IEC 5218).
     */
    case sex
    /**
     * Date of birth (format: ISO8601 YYYYMMDD).
     */
    case dateOfBirth
    /**
     * Country of residence (format: ISO3166-1 alpha-2).
     */
    case countryOfResidence
    /**
     * Country of nationality (format: ISO3166-1 alpha-2).
     */
    case nationality
    /**
     * Identity document type
     *
     * Format:
     * - 0 : na
     * - 1 : passport
     * - 2 : national ID card
     * - 3 : driving license
     * - 4 : immigration card
     * - eID string (see below)
     *
     * eID strings as of Apr 2024:
     * - DK:MITID        : Danish MitId
     * - SE:BANKID       : Swedish BankID
     * - NO:BANKID       : Norwegian BankID
     * - NO:VIPPS        : Norwegian Vipps
     * - FI:TRUSTNETWORK : Finnish Trust Network
     * - NL:DIGID        : Netherlands DigiD
     * - NL:IDIN         : Netherlands iDIN
     * - BE:EID          : Belgian eID
     * - ITSME           : (Cross-national) ItsME
     * - SOFORT          : (Cross-national) Sofort
     */
    case idDocType
    /**
     * Identity document number (format: string up to 31 bytes).
     */
    case idDocNo
    /**
     * Identity document issuer (format: ISO3166-1 alpha-2 or ISO3166-2 if applicable).
     */
    case idDocIssuer
    /**
     * Time from which the ID is valid (format: ISO8601 YYYYMMDD).
     */
    case idDocIssuedAt
    /**
     * Time to which the ID is valid (format: ISO8601 YYYYMMDD).
     */
    case idDocExpiresAt
    /**
     * National ID number (format: string up to 31 bytes).
     */
    case nationalIdNo
    /**
     * Tax ID number (format: string up to 31 bytes).
     */
    case taxIdNo
    /**
     * LEI-code - companies only (format: ISO17442).
     */
    case legalEntityId
    /**
     * Legal name - companies only
     */
    case legalName
    /**
     * Legal country - companies only
     */
    case legalCountry
    /**
     * Business number associated with the company - companies only
     */
    case businessNumber
    /**
     * Registration authority - companies only
     */
    case registrationAuth





}

#if compiler(>=6)
extension AttributeTag: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeTag: FfiConverterRustBuffer {
    typealias SwiftType = AttributeTag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeTag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .firstName
        
        case 2: return .lastName
        
        case 3: return .sex
        
        case 4: return .dateOfBirth
        
        case 5: return .countryOfResidence
        
        case 6: return .nationality
        
        case 7: return .idDocType
        
        case 8: return .idDocNo
        
        case 9: return .idDocIssuer
        
        case 10: return .idDocIssuedAt
        
        case 11: return .idDocExpiresAt
        
        case 12: return .nationalIdNo
        
        case 13: return .taxIdNo
        
        case 14: return .legalEntityId
        
        case 15: return .legalName
        
        case 16: return .legalCountry
        
        case 17: return .businessNumber
        
        case 18: return .registrationAuth
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AttributeTag, into buf: inout [UInt8]) {
        switch value {
        
        
        case .firstName:
            writeInt(&buf, Int32(1))
        
        
        case .lastName:
            writeInt(&buf, Int32(2))
        
        
        case .sex:
            writeInt(&buf, Int32(3))
        
        
        case .dateOfBirth:
            writeInt(&buf, Int32(4))
        
        
        case .countryOfResidence:
            writeInt(&buf, Int32(5))
        
        
        case .nationality:
            writeInt(&buf, Int32(6))
        
        
        case .idDocType:
            writeInt(&buf, Int32(7))
        
        
        case .idDocNo:
            writeInt(&buf, Int32(8))
        
        
        case .idDocIssuer:
            writeInt(&buf, Int32(9))
        
        
        case .idDocIssuedAt:
            writeInt(&buf, Int32(10))
        
        
        case .idDocExpiresAt:
            writeInt(&buf, Int32(11))
        
        
        case .nationalIdNo:
            writeInt(&buf, Int32(12))
        
        
        case .taxIdNo:
            writeInt(&buf, Int32(13))
        
        
        case .legalEntityId:
            writeInt(&buf, Int32(14))
        
        
        case .legalName:
            writeInt(&buf, Int32(15))
        
        
        case .legalCountry:
            writeInt(&buf, Int32(16))
        
        
        case .businessNumber:
            writeInt(&buf, Int32(17))
        
        
        case .registrationAuth:
            writeInt(&buf, Int32(18))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeTag_lift(_ buf: RustBuffer) throws -> AttributeTag {
    return try FfiConverterTypeAttributeTag.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeTag_lower(_ value: AttributeTag) -> RustBuffer {
    return FfiConverterTypeAttributeTag.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Version of proof
 */

public enum ConcordiumLinkingProofVersion: Equatable, Hashable {
    
    case concordiumWeakLinkingProofV1





}

#if compiler(>=6)
extension ConcordiumLinkingProofVersion: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConcordiumLinkingProofVersion: FfiConverterRustBuffer {
    typealias SwiftType = ConcordiumLinkingProofVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConcordiumLinkingProofVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .concordiumWeakLinkingProofV1
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConcordiumLinkingProofVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .concordiumWeakLinkingProofV1:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConcordiumLinkingProofVersion_lift(_ buf: RustBuffer) throws -> ConcordiumLinkingProofVersion {
    return try FfiConverterTypeConcordiumLinkingProofVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConcordiumLinkingProofVersion_lower(_ value: ConcordiumLinkingProofVersion) -> RustBuffer {
    return FfiConverterTypeConcordiumLinkingProofVersion.lower(value)
}



/**
 * Generic error while invoking FFI
 */
public enum ConcordiumWalletCryptoError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case CallFailed(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension ConcordiumWalletCryptoError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConcordiumWalletCryptoError: FfiConverterRustBuffer {
    typealias SwiftType = ConcordiumWalletCryptoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConcordiumWalletCryptoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CallFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConcordiumWalletCryptoError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .CallFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConcordiumWalletCryptoError_lift(_ buf: RustBuffer) throws -> ConcordiumWalletCryptoError {
    return try FfiConverterTypeConcordiumWalletCryptoError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConcordiumWalletCryptoError_lower(_ value: ConcordiumWalletCryptoError) -> RustBuffer {
    return FfiConverterTypeConcordiumWalletCryptoError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Version of proof
 */

public enum ConcordiumZkProofVersion: Equatable, Hashable {
    
    case concordiumZkProofV4





}

#if compiler(>=6)
extension ConcordiumZkProofVersion: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConcordiumZKProofVersion: FfiConverterRustBuffer {
    typealias SwiftType = ConcordiumZkProofVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConcordiumZkProofVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .concordiumZkProofV4
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConcordiumZkProofVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .concordiumZkProofV4:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConcordiumZKProofVersion_lift(_ buf: RustBuffer) throws -> ConcordiumZkProofVersion {
    return try FfiConverterTypeConcordiumZKProofVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConcordiumZKProofVersion_lower(_ value: ConcordiumZkProofVersion) -> RustBuffer {
    return FfiConverterTypeConcordiumZKProofVersion.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Labels for different types of context information that can be provided in verifiable
 * presentation requests and proofs.
 */

public enum ContextLabel: Equatable, Hashable {
    
    /**
     * A nonce which should be at least of lenth bytes32.
     */
    case nonce
    /**
     * Payment hash (Concordium transaction hash).
     */
    case paymentHash
    /**
     * Concordium block hash.
     */
    case blockHash
    /**
     * Identifier for some connection (e.g. wallet-connect topic).
     */
    case connectionId
    /**
     * Identifier for some resource (e.g. Website URL or fingerprint of TLS certificate).
     */
    case resourceId
    /**
     * String value for general purposes.
     */
    case contextString





}

#if compiler(>=6)
extension ContextLabel: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContextLabel: FfiConverterRustBuffer {
    typealias SwiftType = ContextLabel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContextLabel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nonce
        
        case 2: return .paymentHash
        
        case 3: return .blockHash
        
        case 4: return .connectionId
        
        case 5: return .resourceId
        
        case 6: return .contextString
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ContextLabel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nonce:
            writeInt(&buf, Int32(1))
        
        
        case .paymentHash:
            writeInt(&buf, Int32(2))
        
        
        case .blockHash:
            writeInt(&buf, Int32(3))
        
        
        case .connectionId:
            writeInt(&buf, Int32(4))
        
        
        case .resourceId:
            writeInt(&buf, Int32(5))
        
        
        case .contextString:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContextLabel_lift(_ buf: RustBuffer) throws -> ContextLabel {
    return try FfiConverterTypeContextLabel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContextLabel_lower(_ value: ContextLabel) -> RustBuffer {
    return FfiConverterTypeContextLabel.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Verifiable credential that contains subject claims and proofs of the claims.
 */

public enum CredentialV1: Equatable, Hashable {
    
    case account(account: AccountBasedCredentialV1
    )
    case identity(identity: IdentityBasedCredentialV1
    )





}

#if compiler(>=6)
extension CredentialV1: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialV1: FfiConverterRustBuffer {
    typealias SwiftType = CredentialV1

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialV1 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(account: try FfiConverterTypeAccountBasedCredentialV1.read(from: &buf)
        )
        
        case 2: return .identity(identity: try FfiConverterTypeIdentityBasedCredentialV1.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialV1, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(account):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountBasedCredentialV1.write(account, into: &buf)
            
        
        case let .identity(identity):
            writeInt(&buf, Int32(2))
            FfiConverterTypeIdentityBasedCredentialV1.write(identity, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialV1_lift(_ buf: RustBuffer) throws -> CredentialV1 {
    return try FfiConverterTypeCredentialV1.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialV1_lower(_ value: CredentialV1) -> RustBuffer {
    return FfiConverterTypeCredentialV1.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum IdentifierType: Equatable, Hashable {
    
    /**
     * Reference to an account via an address.
     */
    case account(addressBase58: String
    )
    /**
     * Reference to a specific credential via its ID.
     */
    case credential(credId: Bytes
    )
    /**
     * Reference to a specific smart contract instance.
     */
    case contractData(address: ContractAddress, entrypoint: String, parameter: Bytes
    )
    /**
     * Reference to a specific Ed25519 public key.
     */
    case publicKey(key: Data
    )
    /**
     * Reference to a specific identity provider.
     */
    case idp(idpIdentity: UInt32
    )
    /**
     * Encrypted, ephemeral identifier for an identity credential. It is the encryption of IdCredPub.
     */
    case encryptedIdentityCredentialId(credId: Data
    )





}

#if compiler(>=6)
extension IdentifierType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentifierType: FfiConverterRustBuffer {
    typealias SwiftType = IdentifierType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentifierType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(addressBase58: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .credential(credId: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 3: return .contractData(address: try FfiConverterTypeContractAddress.read(from: &buf), entrypoint: try FfiConverterString.read(from: &buf), parameter: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 4: return .publicKey(key: try FfiConverterData.read(from: &buf)
        )
        
        case 5: return .idp(idpIdentity: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 6: return .encryptedIdentityCredentialId(credId: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: IdentifierType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(addressBase58):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(addressBase58, into: &buf)
            
        
        case let .credential(credId):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBytes.write(credId, into: &buf)
            
        
        case let .contractData(address,entrypoint,parameter):
            writeInt(&buf, Int32(3))
            FfiConverterTypeContractAddress.write(address, into: &buf)
            FfiConverterString.write(entrypoint, into: &buf)
            FfiConverterTypeBytes.write(parameter, into: &buf)
            
        
        case let .publicKey(key):
            writeInt(&buf, Int32(4))
            FfiConverterData.write(key, into: &buf)
            
        
        case let .idp(idpIdentity):
            writeInt(&buf, Int32(5))
            FfiConverterUInt32.write(idpIdentity, into: &buf)
            
        
        case let .encryptedIdentityCredentialId(credId):
            writeInt(&buf, Int32(6))
            FfiConverterData.write(credId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifierType_lift(_ buf: RustBuffer) throws -> IdentifierType {
    return try FfiConverterTypeIdentifierType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifierType_lower(_ value: IdentifierType) -> RustBuffer {
    return FfiConverterTypeIdentifierType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Identity based credential types.
 */

public enum IdentityCredentialType: Equatable, Hashable {
    
    case identityCredential
    case accountCredential





}

#if compiler(>=6)
extension IdentityCredentialType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityCredentialType: FfiConverterRustBuffer {
    typealias SwiftType = IdentityCredentialType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityCredentialType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .identityCredential
        
        case 2: return .accountCredential
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: IdentityCredentialType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .identityCredential:
            writeInt(&buf, Int32(1))
        
        
        case .accountCredential:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityCredentialType_lift(_ buf: RustBuffer) throws -> IdentityCredentialType {
    return try FfiConverterTypeIdentityCredentialType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityCredentialType_lower(_ value: IdentityCredentialType) -> RustBuffer {
    return FfiConverterTypeIdentityCredentialType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A statically labeled and statically typed context value.
 */

public enum LabeledContextProperty: Equatable, Hashable {
    
    /**
     * Cryptographic nonce context which should be of length 32 bytes. Should be randomly generated.
     */
    case nonce(nonce: Bytes
    )
    /**
     * Payment hash context (Concordium transaction hash).
     */
    case paymentHash(paymentHash: Bytes
    )
    /**
     * Concordium block hash context.
     */
    case blockHash(blockHash: Bytes
    )
    /**
     * Identifier for some connection (e.g. wallet-connect topic).
     */
    case connectionId(connectionId: String
    )
    /**
     * Identifier for some resource (e.g. Website URL or fingerprint of TLS certificate).
     */
    case resourceId(resouceId: String
    )
    /**
     * String value for general purposes.
     */
    case contextString(contextString: String
    )





}

#if compiler(>=6)
extension LabeledContextProperty: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLabeledContextProperty: FfiConverterRustBuffer {
    typealias SwiftType = LabeledContextProperty

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LabeledContextProperty {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nonce(nonce: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 2: return .paymentHash(paymentHash: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 3: return .blockHash(blockHash: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 4: return .connectionId(connectionId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .resourceId(resouceId: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .contextString(contextString: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LabeledContextProperty, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .nonce(nonce):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBytes.write(nonce, into: &buf)
            
        
        case let .paymentHash(paymentHash):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBytes.write(paymentHash, into: &buf)
            
        
        case let .blockHash(blockHash):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBytes.write(blockHash, into: &buf)
            
        
        case let .connectionId(connectionId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(connectionId, into: &buf)
            
        
        case let .resourceId(resouceId):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(resouceId, into: &buf)
            
        
        case let .contextString(contextString):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(contextString, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabeledContextProperty_lift(_ buf: RustBuffer) throws -> LabeledContextProperty {
    return try FfiConverterTypeLabeledContextProperty.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabeledContextProperty_lower(_ value: LabeledContextProperty) -> RustBuffer {
    return FfiConverterTypeLabeledContextProperty.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the different contract module schema versions
 */

public enum ModuleSchemaVersion: Equatable, Hashable {
    
    case v0
    case v1
    case v2
    case v3





}

#if compiler(>=6)
extension ModuleSchemaVersion: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModuleSchemaVersion: FfiConverterRustBuffer {
    typealias SwiftType = ModuleSchemaVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModuleSchemaVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v0
        
        case 2: return .v1
        
        case 3: return .v2
        
        case 4: return .v3
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ModuleSchemaVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v0:
            writeInt(&buf, Int32(1))
        
        
        case .v1:
            writeInt(&buf, Int32(2))
        
        
        case .v2:
            writeInt(&buf, Int32(3))
        
        
        case .v3:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModuleSchemaVersion_lift(_ buf: RustBuffer) throws -> ModuleSchemaVersion {
    return try FfiConverterTypeModuleSchemaVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModuleSchemaVersion_lower(_ value: ModuleSchemaVersion) -> RustBuffer {
    return FfiConverterTypeModuleSchemaVersion.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network: Equatable, Hashable {
    
    case testnet
    case mainnet





}

#if compiler(>=6)
extension Network: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .testnet
        
        case 2: return .mainnet
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .testnet:
            writeInt(&buf, Int32(1))
        
        
        case .mainnet:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The additional private inputs (mostly secrets), needed to prove the claims
 * in a RequestV1.
 */

public enum OwnedCredentialProofPrivateInputs: Equatable, Hashable {
    
    case account(account: OwnedAccountCredentialProofPrivateInputs
    )
    case identity(identity: OwnedIdentityCredentialProofPrivateInputs
    )





}

#if compiler(>=6)
extension OwnedCredentialProofPrivateInputs: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOwnedCredentialProofPrivateInputs: FfiConverterRustBuffer {
    typealias SwiftType = OwnedCredentialProofPrivateInputs

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OwnedCredentialProofPrivateInputs {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(account: try FfiConverterTypeOwnedAccountCredentialProofPrivateInputs.read(from: &buf)
        )
        
        case 2: return .identity(identity: try FfiConverterTypeOwnedIdentityCredentialProofPrivateInputs.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OwnedCredentialProofPrivateInputs, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(account):
            writeInt(&buf, Int32(1))
            FfiConverterTypeOwnedAccountCredentialProofPrivateInputs.write(account, into: &buf)
            
        
        case let .identity(identity):
            writeInt(&buf, Int32(2))
            FfiConverterTypeOwnedIdentityCredentialProofPrivateInputs.write(identity, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOwnedCredentialProofPrivateInputs_lift(_ buf: RustBuffer) throws -> OwnedCredentialProofPrivateInputs {
    return try FfiConverterTypeOwnedCredentialProofPrivateInputs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOwnedCredentialProofPrivateInputs_lower(_ value: OwnedCredentialProofPrivateInputs) -> RustBuffer {
    return FfiConverterTypeOwnedCredentialProofPrivateInputs.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Statement that is requested to be proven.
 */

public enum RequestedStatement: Equatable, Hashable {
    
    case revealAttribute(statement: RevealAttributeIdentityStatement
    )
    case attributeInRange(statement: AttributeInRangeIdentityStatementV1
    )
    case attributeInSet(statement: AttributeInSetIdentityStatementV1
    )
    case attributeNotInSet(statement: AttributeNotInSetIdentityStatementV1
    )





}

#if compiler(>=6)
extension RequestedStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestedStatement: FfiConverterRustBuffer {
    typealias SwiftType = RequestedStatement

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedStatement {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .revealAttribute(statement: try FfiConverterTypeRevealAttributeIdentityStatement.read(from: &buf)
        )
        
        case 2: return .attributeInRange(statement: try FfiConverterTypeAttributeInRangeIdentityStatementV1.read(from: &buf)
        )
        
        case 3: return .attributeInSet(statement: try FfiConverterTypeAttributeInSetIdentityStatementV1.read(from: &buf)
        )
        
        case 4: return .attributeNotInSet(statement: try FfiConverterTypeAttributeNotInSetIdentityStatementV1.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestedStatement, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .revealAttribute(statement):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRevealAttributeIdentityStatement.write(statement, into: &buf)
            
        
        case let .attributeInRange(statement):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAttributeInRangeIdentityStatementV1.write(statement, into: &buf)
            
        
        case let .attributeInSet(statement):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAttributeInSetIdentityStatementV1.write(statement, into: &buf)
            
        
        case let .attributeNotInSet(statement):
            writeInt(&buf, Int32(4))
            FfiConverterTypeAttributeNotInSetIdentityStatementV1.write(statement, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedStatement_lift(_ buf: RustBuffer) throws -> RequestedStatement {
    return try FfiConverterTypeRequestedStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedStatement_lower(_ value: RequestedStatement) -> RustBuffer {
    return FfiConverterTypeRequestedStatement.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The subject claims being requested proven.
 */

public enum RequestedSubjectClaims: Equatable, Hashable {
    
    case identity(identity: RequestedIdentitySubjectClaims
    )





}

#if compiler(>=6)
extension RequestedSubjectClaims: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestedSubjectClaims: FfiConverterRustBuffer {
    typealias SwiftType = RequestedSubjectClaims

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedSubjectClaims {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .identity(identity: try FfiConverterTypeRequestedIdentitySubjectClaims.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestedSubjectClaims, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .identity(identity):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRequestedIdentitySubjectClaims.write(identity, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedSubjectClaims_lift(_ buf: RustBuffer) throws -> RequestedSubjectClaims {
    return try FfiConverterTypeRequestedSubjectClaims.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedSubjectClaims_lower(_ value: RequestedSubjectClaims) -> RustBuffer {
    return FfiConverterTypeRequestedSubjectClaims.lower(value)
}



/**
 * Describes errors happening while interacting with contract schemas
 */
public enum SchemaError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    /**
     * Failed to convert value with schema
     */
    case Convert(message: String)
    
    /**
     * Failed parse the module schema
     */
    case ParseSchema(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension SchemaError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSchemaError: FfiConverterRustBuffer {
    typealias SwiftType = SchemaError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SchemaError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Convert(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .ParseSchema(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SchemaError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Convert(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .ParseSchema(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSchemaError_lift(_ buf: RustBuffer) throws -> SchemaError {
    return try FfiConverterTypeSchemaError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSchemaError_lower(_ value: SchemaError) -> RustBuffer {
    return FfiConverterTypeSchemaError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Claims about a subject.
 * To prove the claims and create a credential, the corresponding private input [`CredentialProofPrivateInputs`] is needed.
 */

public enum SubjectClaims: Equatable, Hashable {
    
    case account(account: AccountBasedSubjectClaims
    )
    case identity(identity: IdentityBasedSubjectClaims
    )





}

#if compiler(>=6)
extension SubjectClaims: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubjectClaims: FfiConverterRustBuffer {
    typealias SwiftType = SubjectClaims

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubjectClaims {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(account: try FfiConverterTypeAccountBasedSubjectClaims.read(from: &buf)
        )
        
        case 2: return .identity(identity: try FfiConverterTypeIdentityBasedSubjectClaims.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SubjectClaims, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(account):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountBasedSubjectClaims.write(account, into: &buf)
            
        
        case let .identity(identity):
            writeInt(&buf, Int32(2))
            FfiConverterTypeIdentityBasedSubjectClaims.write(identity, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubjectClaims_lift(_ buf: RustBuffer) throws -> SubjectClaims {
    return try FfiConverterTypeSubjectClaims.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubjectClaims_lower(_ value: SubjectClaims) -> RustBuffer {
    return FfiConverterTypeSubjectClaims.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The additional inputs, additional to the `VerifiablePresentationRequest` that are needed to
 * produce a `VerifablePresentation`.
 */

public enum VerifiableCredentialCommitmentInputs: Equatable, Hashable {
    
    /**
     * Inputs are for an identity credential issued by an identity provider.
     */
    case account(issuer: UInt32, values: [AttributeTag: String], randomness: [AttributeTag: Bytes]
    )
    /**
     * Inputs are for a credential issued by Web3ID issuer.
     */
    case web3Issuer(signature: Bytes, signer: Data, values: [String: Web3IdAttribute], randomness: [String: Bytes]
    )





}

#if compiler(>=6)
extension VerifiableCredentialCommitmentInputs: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerifiableCredentialCommitmentInputs: FfiConverterRustBuffer {
    typealias SwiftType = VerifiableCredentialCommitmentInputs

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiableCredentialCommitmentInputs {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(issuer: try FfiConverterUInt32.read(from: &buf), values: try FfiConverterDictionaryTypeAttributeTagString.read(from: &buf), randomness: try FfiConverterDictionaryTypeAttributeTagTypeBytes.read(from: &buf)
        )
        
        case 2: return .web3Issuer(signature: try FfiConverterTypeBytes.read(from: &buf), signer: try FfiConverterData.read(from: &buf), values: try FfiConverterDictionaryStringTypeWeb3IdAttribute.read(from: &buf), randomness: try FfiConverterDictionaryStringTypeBytes.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerifiableCredentialCommitmentInputs, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(issuer,values,randomness):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(issuer, into: &buf)
            FfiConverterDictionaryTypeAttributeTagString.write(values, into: &buf)
            FfiConverterDictionaryTypeAttributeTagTypeBytes.write(randomness, into: &buf)
            
        
        case let .web3Issuer(signature,signer,values,randomness):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBytes.write(signature, into: &buf)
            FfiConverterData.write(signer, into: &buf)
            FfiConverterDictionaryStringTypeWeb3IdAttribute.write(values, into: &buf)
            FfiConverterDictionaryStringTypeBytes.write(randomness, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiableCredentialCommitmentInputs_lift(_ buf: RustBuffer) throws -> VerifiableCredentialCommitmentInputs {
    return try FfiConverterTypeVerifiableCredentialCommitmentInputs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiableCredentialCommitmentInputs_lower(_ value: VerifiableCredentialCommitmentInputs) -> RustBuffer {
    return FfiConverterTypeVerifiableCredentialCommitmentInputs.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A proof corresponding to one `VerifiableCredentialStatement`. This contains almost
 * all the information needed to verify it, except the issuer's public key in
 * case of the `Web3Id` proof, and the public commitments in case of the
 * `Account` proof.
 */

public enum VerifiableCredentialProof: Equatable, Hashable {
    
    case account(created: Date, network: Network, credId: Bytes, issuer: UInt32, proofs: [AccountStatementWithProof]
    )
    case web3Id(created: Date, holderId: Bytes, network: Network, contract: ContractAddress, credType: [String], commitments: SignedCommitments, proofs: [Web3IdStatementWithProof]
    )





}

#if compiler(>=6)
extension VerifiableCredentialProof: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerifiableCredentialProof: FfiConverterRustBuffer {
    typealias SwiftType = VerifiableCredentialProof

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiableCredentialProof {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(created: try FfiConverterTimestamp.read(from: &buf), network: try FfiConverterTypeNetwork.read(from: &buf), credId: try FfiConverterTypeBytes.read(from: &buf), issuer: try FfiConverterUInt32.read(from: &buf), proofs: try FfiConverterSequenceTypeAccountStatementWithProof.read(from: &buf)
        )
        
        case 2: return .web3Id(created: try FfiConverterTimestamp.read(from: &buf), holderId: try FfiConverterTypeBytes.read(from: &buf), network: try FfiConverterTypeNetwork.read(from: &buf), contract: try FfiConverterTypeContractAddress.read(from: &buf), credType: try FfiConverterSequenceString.read(from: &buf), commitments: try FfiConverterTypeSignedCommitments.read(from: &buf), proofs: try FfiConverterSequenceTypeWeb3IdStatementWithProof.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerifiableCredentialProof, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(created,network,credId,issuer,proofs):
            writeInt(&buf, Int32(1))
            FfiConverterTimestamp.write(created, into: &buf)
            FfiConverterTypeNetwork.write(network, into: &buf)
            FfiConverterTypeBytes.write(credId, into: &buf)
            FfiConverterUInt32.write(issuer, into: &buf)
            FfiConverterSequenceTypeAccountStatementWithProof.write(proofs, into: &buf)
            
        
        case let .web3Id(created,holderId,network,contract,credType,commitments,proofs):
            writeInt(&buf, Int32(2))
            FfiConverterTimestamp.write(created, into: &buf)
            FfiConverterTypeBytes.write(holderId, into: &buf)
            FfiConverterTypeNetwork.write(network, into: &buf)
            FfiConverterTypeContractAddress.write(contract, into: &buf)
            FfiConverterSequenceString.write(credType, into: &buf)
            FfiConverterTypeSignedCommitments.write(commitments, into: &buf)
            FfiConverterSequenceTypeWeb3IdStatementWithProof.write(proofs, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiableCredentialProof_lift(_ buf: RustBuffer) throws -> VerifiableCredentialProof {
    return try FfiConverterTypeVerifiableCredentialProof.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiableCredentialProof_lower(_ value: VerifiableCredentialProof) -> RustBuffer {
    return FfiConverterTypeVerifiableCredentialProof.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A statement about a single credential, either an identity credential or a
 * Web3 credential.
 */

public enum VerifiableCredentialStatement: Equatable, Hashable {
    
    /**
     * Statement about a credential derived from an identity issued by an
     * identity provider.
     */
    case account(network: Network, credId: Bytes, statement: [AtomicIdentityStatement]
    )
    /**
     * Statement about a credential issued by a Web3 identity provider, a smart
     * contract.
     */
    case web3Id(credType: [String], network: Network, contract: ContractAddress, holderId: Bytes, statement: [AtomicWeb3IdStatement]
    )





}

#if compiler(>=6)
extension VerifiableCredentialStatement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerifiableCredentialStatement: FfiConverterRustBuffer {
    typealias SwiftType = VerifiableCredentialStatement

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiableCredentialStatement {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(network: try FfiConverterTypeNetwork.read(from: &buf), credId: try FfiConverterTypeBytes.read(from: &buf), statement: try FfiConverterSequenceTypeAtomicIdentityStatement.read(from: &buf)
        )
        
        case 2: return .web3Id(credType: try FfiConverterSequenceString.read(from: &buf), network: try FfiConverterTypeNetwork.read(from: &buf), contract: try FfiConverterTypeContractAddress.read(from: &buf), holderId: try FfiConverterTypeBytes.read(from: &buf), statement: try FfiConverterSequenceTypeAtomicWeb3IdStatement.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerifiableCredentialStatement, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(network,credId,statement):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNetwork.write(network, into: &buf)
            FfiConverterTypeBytes.write(credId, into: &buf)
            FfiConverterSequenceTypeAtomicIdentityStatement.write(statement, into: &buf)
            
        
        case let .web3Id(credType,network,contract,holderId,statement):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceString.write(credType, into: &buf)
            FfiConverterTypeNetwork.write(network, into: &buf)
            FfiConverterTypeContractAddress.write(contract, into: &buf)
            FfiConverterTypeBytes.write(holderId, into: &buf)
            FfiConverterSequenceTypeAtomicWeb3IdStatement.write(statement, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiableCredentialStatement_lift(_ buf: RustBuffer) throws -> VerifiableCredentialStatement {
    return try FfiConverterTypeVerifiableCredentialStatement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiableCredentialStatement_lower(_ value: VerifiableCredentialStatement) -> RustBuffer {
    return FfiConverterTypeVerifiableCredentialStatement.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A value of an attribute. This is the low-level representation. The
 * different variants are present to enable different representations in JSON,
 * and different embeddings as field elements when constructing and verifying
 * proofs.
 */

public enum Web3IdAttribute: Equatable, Hashable {
    
    case string(value: String
    )
    case numeric(value: UInt64
    )
    case timestamp(value: Date
    )





}

#if compiler(>=6)
extension Web3IdAttribute: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWeb3IdAttribute: FfiConverterRustBuffer {
    typealias SwiftType = Web3IdAttribute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Web3IdAttribute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .string(value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .numeric(value: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .timestamp(value: try FfiConverterTimestamp.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Web3IdAttribute, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .string(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .numeric(value):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(value, into: &buf)
            
        
        case let .timestamp(value):
            writeInt(&buf, Int32(3))
            FfiConverterTimestamp.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWeb3IdAttribute_lift(_ buf: RustBuffer) throws -> Web3IdAttribute {
    return try FfiConverterTypeWeb3IdAttribute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWeb3IdAttribute_lower(_ value: Web3IdAttribute) -> RustBuffer {
    return FfiConverterTypeWeb3IdAttribute.lower(value)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeModuleSchemaVersion: FfiConverterRustBuffer {
    typealias SwiftType = ModuleSchemaVersion?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeModuleSchemaVersion.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeModuleSchemaVersion.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAccountStatementWithProof: FfiConverterRustBuffer {
    typealias SwiftType = [AccountStatementWithProof]

    public static func write(_ value: [AccountStatementWithProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountStatementWithProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountStatementWithProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountStatementWithProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAccountStatementWithProof.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeContextProperty: FfiConverterRustBuffer {
    typealias SwiftType = [ContextProperty]

    public static func write(_ value: [ContextProperty], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContextProperty.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ContextProperty] {
        let len: Int32 = try readInt(&buf)
        var seq = [ContextProperty]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeContextProperty.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIdentityProviderDid: FfiConverterRustBuffer {
    typealias SwiftType = [IdentityProviderDid]

    public static func write(_ value: [IdentityProviderDid], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdentityProviderDid.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentityProviderDid] {
        let len: Int32 = try readInt(&buf)
        var seq = [IdentityProviderDid]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIdentityProviderDid.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWeb3IdStatementWithProof: FfiConverterRustBuffer {
    typealias SwiftType = [Web3IdStatementWithProof]

    public static func write(_ value: [Web3IdStatementWithProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWeb3IdStatementWithProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Web3IdStatementWithProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [Web3IdStatementWithProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWeb3IdStatementWithProof.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAtomicIdentityProof: FfiConverterRustBuffer {
    typealias SwiftType = [AtomicIdentityProof]

    public static func write(_ value: [AtomicIdentityProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAtomicIdentityProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AtomicIdentityProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [AtomicIdentityProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAtomicIdentityProof.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAtomicIdentityStatement: FfiConverterRustBuffer {
    typealias SwiftType = [AtomicIdentityStatement]

    public static func write(_ value: [AtomicIdentityStatement], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAtomicIdentityStatement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AtomicIdentityStatement] {
        let len: Int32 = try readInt(&buf)
        var seq = [AtomicIdentityStatement]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAtomicIdentityStatement.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAtomicStatementV1: FfiConverterRustBuffer {
    typealias SwiftType = [AtomicStatementV1]

    public static func write(_ value: [AtomicStatementV1], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAtomicStatementV1.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AtomicStatementV1] {
        let len: Int32 = try readInt(&buf)
        var seq = [AtomicStatementV1]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAtomicStatementV1.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAtomicWeb3IdStatement: FfiConverterRustBuffer {
    typealias SwiftType = [AtomicWeb3IdStatement]

    public static func write(_ value: [AtomicWeb3IdStatement], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAtomicWeb3IdStatement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AtomicWeb3IdStatement] {
        let len: Int32 = try readInt(&buf)
        var seq = [AtomicWeb3IdStatement]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAtomicWeb3IdStatement.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAttributeTag: FfiConverterRustBuffer {
    typealias SwiftType = [AttributeTag]

    public static func write(_ value: [AttributeTag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttributeTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttributeTag] {
        let len: Int32 = try readInt(&buf)
        var seq = [AttributeTag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAttributeTag.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeContextLabel: FfiConverterRustBuffer {
    typealias SwiftType = [ContextLabel]

    public static func write(_ value: [ContextLabel], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContextLabel.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ContextLabel] {
        let len: Int32 = try readInt(&buf)
        var seq = [ContextLabel]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeContextLabel.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCredentialV1: FfiConverterRustBuffer {
    typealias SwiftType = [CredentialV1]

    public static func write(_ value: [CredentialV1], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCredentialV1.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CredentialV1] {
        let len: Int32 = try readInt(&buf)
        var seq = [CredentialV1]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCredentialV1.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIdentityCredentialType: FfiConverterRustBuffer {
    typealias SwiftType = [IdentityCredentialType]

    public static func write(_ value: [IdentityCredentialType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdentityCredentialType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentityCredentialType] {
        let len: Int32 = try readInt(&buf)
        var seq = [IdentityCredentialType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIdentityCredentialType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLabeledContextProperty: FfiConverterRustBuffer {
    typealias SwiftType = [LabeledContextProperty]

    public static func write(_ value: [LabeledContextProperty], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLabeledContextProperty.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LabeledContextProperty] {
        let len: Int32 = try readInt(&buf)
        var seq = [LabeledContextProperty]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLabeledContextProperty.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeOwnedCredentialProofPrivateInputs: FfiConverterRustBuffer {
    typealias SwiftType = [OwnedCredentialProofPrivateInputs]

    public static func write(_ value: [OwnedCredentialProofPrivateInputs], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOwnedCredentialProofPrivateInputs.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OwnedCredentialProofPrivateInputs] {
        let len: Int32 = try readInt(&buf)
        var seq = [OwnedCredentialProofPrivateInputs]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOwnedCredentialProofPrivateInputs.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRequestedStatement: FfiConverterRustBuffer {
    typealias SwiftType = [RequestedStatement]

    public static func write(_ value: [RequestedStatement], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequestedStatement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RequestedStatement] {
        let len: Int32 = try readInt(&buf)
        var seq = [RequestedStatement]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequestedStatement.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRequestedSubjectClaims: FfiConverterRustBuffer {
    typealias SwiftType = [RequestedSubjectClaims]

    public static func write(_ value: [RequestedSubjectClaims], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequestedSubjectClaims.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RequestedSubjectClaims] {
        let len: Int32 = try readInt(&buf)
        var seq = [RequestedSubjectClaims]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequestedSubjectClaims.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSubjectClaims: FfiConverterRustBuffer {
    typealias SwiftType = [SubjectClaims]

    public static func write(_ value: [SubjectClaims], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSubjectClaims.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SubjectClaims] {
        let len: Int32 = try readInt(&buf)
        var seq = [SubjectClaims]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSubjectClaims.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeVerifiableCredentialCommitmentInputs: FfiConverterRustBuffer {
    typealias SwiftType = [VerifiableCredentialCommitmentInputs]

    public static func write(_ value: [VerifiableCredentialCommitmentInputs], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVerifiableCredentialCommitmentInputs.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VerifiableCredentialCommitmentInputs] {
        let len: Int32 = try readInt(&buf)
        var seq = [VerifiableCredentialCommitmentInputs]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVerifiableCredentialCommitmentInputs.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeVerifiableCredentialProof: FfiConverterRustBuffer {
    typealias SwiftType = [VerifiableCredentialProof]

    public static func write(_ value: [VerifiableCredentialProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVerifiableCredentialProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VerifiableCredentialProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [VerifiableCredentialProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVerifiableCredentialProof.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeVerifiableCredentialStatement: FfiConverterRustBuffer {
    typealias SwiftType = [VerifiableCredentialStatement]

    public static func write(_ value: [VerifiableCredentialStatement], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVerifiableCredentialStatement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VerifiableCredentialStatement] {
        let len: Int32 = try readInt(&buf)
        var seq = [VerifiableCredentialStatement]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVerifiableCredentialStatement.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWeb3IdAttribute: FfiConverterRustBuffer {
    typealias SwiftType = [Web3IdAttribute]

    public static func write(_ value: [Web3IdAttribute], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWeb3IdAttribute.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Web3IdAttribute] {
        let len: Int32 = try readInt(&buf)
        var seq = [Web3IdAttribute]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWeb3IdAttribute.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBytes: FfiConverterRustBuffer {
    typealias SwiftType = [Bytes]

    public static func write(_ value: [Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBytes.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bytes] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bytes]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBytes.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryUInt8TypeCredentialDeploymentInfo: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: CredentialDeploymentInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterTypeCredentialDeploymentInfo.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: CredentialDeploymentInfo] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: CredentialDeploymentInfo]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterTypeCredentialDeploymentInfo.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryUInt8TypeVerifyKey: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: VerifyKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterTypeVerifyKey.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: VerifyKey] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: VerifyKey]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterTypeVerifyKey.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryUInt8TypeBytes: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterTypeBytes.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: Bytes] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: Bytes]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterTypeBytes.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: AnonymityRevokerInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeAnonymityRevokerInfo.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: AnonymityRevokerInfo] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: AnonymityRevokerInfo]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeAnonymityRevokerInfo.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryUInt32TypeArData: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: ArData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeArData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: ArData] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: ArData]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeArData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryUInt32TypeChainArData: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: ChainArData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeChainArData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: ChainArData] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: ChainArData]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeChainArData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeWeb3IdAttribute: FfiConverterRustBuffer {
    public static func write(_ value: [String: Web3IdAttribute], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeWeb3IdAttribute.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Web3IdAttribute] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Web3IdAttribute]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeWeb3IdAttribute.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeBytes: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeBytes.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bytes] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bytes]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeBytes.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeAttributeTagString: FfiConverterRustBuffer {
    public static func write(_ value: [AttributeTag: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAttributeTag.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttributeTag: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [AttributeTag: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAttributeTag.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeAttributeTagTypeWeb3IdAttribute: FfiConverterRustBuffer {
    public static func write(_ value: [AttributeTag: Web3IdAttribute], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAttributeTag.write(key, into: &buf)
            FfiConverterTypeWeb3IdAttribute.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttributeTag: Web3IdAttribute] {
        let len: Int32 = try readInt(&buf)
        var dict = [AttributeTag: Web3IdAttribute]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAttributeTag.read(from: &buf)
            let value = try FfiConverterTypeWeb3IdAttribute.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeAttributeTagTypeBytes: FfiConverterRustBuffer {
    public static func write(_ value: [AttributeTag: Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAttributeTag.write(key, into: &buf)
            FfiConverterTypeBytes.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttributeTag: Bytes] {
        let len: Int32 = try readInt(&buf)
        var dict = [AttributeTag: Bytes]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAttributeTag.read(from: &buf)
            let value = try FfiConverterTypeBytes.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bytes = Data

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBytes: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bytes {
        return try FfiConverterData.read(from: &buf)
    }

    public static func write(_ value: Bytes, into buf: inout [UInt8]) {
        return FfiConverterData.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bytes {
        return try FfiConverterData.lift(value)
    }

    public static func lower(_ value: Bytes) -> RustBuffer {
        return FfiConverterData.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBytes_lift(_ value: RustBuffer) throws -> Bytes {
    return try FfiConverterTypeBytes.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBytes_lower(_ value: Bytes) -> RustBuffer {
    return FfiConverterTypeBytes.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias MicroCcdAmount = UInt64

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMicroCCDAmount: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MicroCcdAmount {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: MicroCcdAmount, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> MicroCcdAmount {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: MicroCcdAmount) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMicroCCDAmount_lift(_ value: UInt64) throws -> MicroCcdAmount {
    return try FfiConverterTypeMicroCCDAmount.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMicroCCDAmount_lower(_ value: MicroCcdAmount) -> UInt64 {
    return FfiConverterTypeMicroCCDAmount.lower(value)
}

/**
 * Construct an account credential from the information contained in the provided parameters.
 */
public func accountCredential(params: AccountCredentialParameters)throws  -> AccountCredentialWithRandomness  {
    return try  FfiConverterTypeAccountCredentialWithRandomness_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential(
        FfiConverterTypeAccountCredentialParameters_lower(params),$0
    )
})
}
/**
 * Compute the attribute commitment randomness for the provided seed, identity indexes, credential counter, and attribute number.
 */
public func accountCredentialAttributeCommitmentRandomness(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8, attribute: UInt8)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_attribute_commitment_randomness(
        FfiConverterTypeBytes_lower(seed),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),
        FfiConverterUInt8.lower(attribute),$0
    )
})
}
/**
 * Compute the hash of a new credential deployment to be signed by the account key derived for the credential.
 */
public func accountCredentialDeploymentHash(credential: AccountCredential, expiryUnixSecs: UInt64)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_deployment_hash(
        FfiConverterTypeAccountCredential_lower(credential),
        FfiConverterUInt64.lower(expiryUnixSecs),$0
    )
})
}
/**
 * Serializes the credential deployment payload for submission as a "raw" payload to a node.
 */
public func accountCredentialDeploymentSignedPayload(credential: SignedAccountCredential)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_deployment_signed_payload(
        FfiConverterTypeSignedAccountCredential_lower(credential),$0
    )
})
}
/**
 * Compute the credential ID for the provided seed, identity indexes, credential counter, and the chain's commitment key.
 */
public func accountCredentialId(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8, commitmentKey: Bytes)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_id(
        FfiConverterTypeBytes_lower(seed),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),
        FfiConverterTypeBytes_lower(commitmentKey),$0
    )
})
}
/**
 * Compute the account credential public key for the provided seed, identity indexes, and credential counter.
 */
public func accountCredentialPublicKey(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_public_key(
        FfiConverterTypeBytes_lower(seed),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),$0
    )
})
}
/**
 * Compute the account credential signing key for the provided seed, identity indexes, and credential counter.
 */
public func accountCredentialSigningKey(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_signing_key(
        FfiConverterTypeBytes_lower(seed),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),$0
    )
})
}
/**
 * Attempt to combine two encrypted amounts
 */
public func combineEncryptedAmounts(left: Bytes, right: Bytes)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_combine_encrypted_amounts(
        FfiConverterTypeBytes_lower(left),
        FfiConverterTypeBytes_lower(right),$0
    )
})
}
/**
 * Compute the anchor hash for VerificationRequestData
 */
public func computeAnchorHash(verificationRequestData: VerificationRequestData)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_compute_anchor_hash(
        FfiConverterTypeVerificationRequestData_lower(verificationRequestData),$0
    )
})
}
/**
 * Create a verifiable presentation from a `VerifiablePresentationRequest`, the associated
 * commitment inputs and the cryptographic parameters of the chain.
 */
public func createVerifiablePresentation(request: VerifiablePresentationRequest, global: GlobalContext, commitmentInputs: [VerifiableCredentialCommitmentInputs])throws  -> VerifiablePresentation  {
    return try  FfiConverterTypeVerifiablePresentation_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_create_verifiable_presentation(
        FfiConverterTypeVerifiablePresentationRequest_lower(request),
        FfiConverterTypeGlobalContext_lower(global),
        FfiConverterSequenceTypeVerifiableCredentialCommitmentInputs.lower(commitmentInputs),$0
    )
})
}
/**
 * Create PresentationV1 for the given statement
 */
public func createVerifiablePresentationV1(request: RequestV1, global: GlobalContext, inputs: [OwnedCredentialProofPrivateInputs])throws  -> PresentationV1  {
    return try  FfiConverterTypePresentationV1_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_create_verifiable_presentation_v1(
        FfiConverterTypeRequestV1_lower(request),
        FfiConverterTypeGlobalContext_lower(global),
        FfiConverterSequenceTypeOwnedCredentialProofPrivateInputs.lower(inputs),$0
    )
})
}
/**
 * Attempt to decryp the encrypted amount with the given encryption key
 */
public func decryptAmount(encryptedAmount: Bytes, encryptionSecretKey: Bytes)throws  -> MicroCcdAmount  {
    return try  FfiConverterTypeMicroCCDAmount_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_decrypt_amount(
        FfiConverterTypeBytes_lower(encryptedAmount),
        FfiConverterTypeBytes_lower(encryptionSecretKey),$0
    )
})
}
/**
 * Attempt to deserialize SecToPubTransferData from the supplied bytes. This will fail if the number of bytes does not exactly match the expected number.
 */
public func deserializeSecToPubTransferData(bytes: Data)throws  -> SecToPubTransferDataDeserializeResult  {
    return try  FfiConverterTypeSecToPubTransferDataDeserializeResult_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_deserialize_sec_to_pub_transfer_data(
        FfiConverterData.lower(bytes),$0
    )
})
}
/**
 * Deserialize the provided value into the JSON representation of a type corresponding to the provided `schema`
 */
public func deserializeTypeValue(value: Data, schema: TypeSchema)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeSchemaError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_deserialize_type_value(
        FfiConverterData.lower(value),
        FfiConverterTypeTypeSchema_lower(schema),$0
    )
})
}
/**
 * Attempt to deserialize UpdateCredentialsPayloadDeserializeResult from the supplied bytes. This will fail if the number of bytes does not exactly match the expected number.
 */
public func deserializeUpdateCredentialsPayload(bytes: Data)throws  -> UpdateCredentialsPayloadDeserializeResult  {
    return try  FfiConverterTypeUpdateCredentialsPayloadDeserializeResult_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_deserialize_update_credentials_payload(
        FfiConverterData.lower(bytes),$0
    )
})
}
/**
 * Format the given `Method` as a DID string
 */
public func didMethodAsString(did: Did)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_did_method_as_string(
        FfiConverterTypeDID_lower(did),$0
    )
})
}
/**
 * Returns the schema template for the given `TypeSchema`
 */
public func displayTypeSchemaTemplate(schema: TypeSchema)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeSchemaError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_display_type_schema_template(
        FfiConverterTypeTypeSchema_lower(schema),$0
    )
})
}
/**
 * Create a set of baker keys
 */
public func generateBakerKeys() -> BakerKeyPairs  {
    return try!  FfiConverterTypeBakerKeyPairs_lift(try! rustCall() {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_generate_baker_keys($0
    )
})
}
/**
 * Attempt to create the encryption keys associated with an account at the given credential index
 */
public func getEncryptionKeys(globalContext: GlobalContext, prfKey: Bytes, credentialIndex: UInt8)throws  -> EncryptionKeys  {
    return try  FfiConverterTypeEncryptionKeys_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_encryption_keys(
        FfiConverterTypeGlobalContext_lower(globalContext),
        FfiConverterTypeBytes_lower(prfKey),
        FfiConverterUInt8.lower(credentialIndex),$0
    )
})
}
/**
 * Get the `TypeSchema` for events emitted by a contract
 */
public func getEventSchema(schema: ModuleSchema, contractName: String)throws  -> TypeSchema  {
    return try  FfiConverterTypeTypeSchema_lift(try rustCallWithError(FfiConverterTypeSchemaError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_event_schema(
        FfiConverterTypeModuleSchema_lower(schema),
        FfiConverterString.lower(contractName),$0
    )
})
}
/**
 * Get the `TypeSchema` for an error of the init function of a contract
 */
public func getInitErrorSchema(schema: ModuleSchema, contractName: String)throws  -> TypeSchema  {
    return try  FfiConverterTypeTypeSchema_lift(try rustCallWithError(FfiConverterTypeSchemaError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_init_error_schema(
        FfiConverterTypeModuleSchema_lower(schema),
        FfiConverterString.lower(contractName),$0
    )
})
}
/**
 * Get the `TypeSchema` for a parameter of the init function of a contract
 */
public func getInitParameterSchema(schema: ModuleSchema, contractName: String)throws  -> TypeSchema  {
    return try  FfiConverterTypeTypeSchema_lift(try rustCallWithError(FfiConverterTypeSchemaError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_init_parameter_schema(
        FfiConverterTypeModuleSchema_lower(schema),
        FfiConverterString.lower(contractName),$0
    )
})
}
/**
 * Get the `TypeSchema` for an error of a given receive function
 */
public func getReceiveErrorSchema(schema: ModuleSchema, contractName: String, functionName: String)throws  -> TypeSchema  {
    return try  FfiConverterTypeTypeSchema_lift(try rustCallWithError(FfiConverterTypeSchemaError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_receive_error_schema(
        FfiConverterTypeModuleSchema_lower(schema),
        FfiConverterString.lower(contractName),
        FfiConverterString.lower(functionName),$0
    )
})
}
/**
 * Get the `TypeSchema` for a parameter of a given receive function
 */
public func getReceiveParameterSchema(schema: ModuleSchema, contractName: String, functionName: String)throws  -> TypeSchema  {
    return try  FfiConverterTypeTypeSchema_lift(try rustCallWithError(FfiConverterTypeSchemaError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_receive_parameter_schema(
        FfiConverterTypeModuleSchema_lower(schema),
        FfiConverterString.lower(contractName),
        FfiConverterString.lower(functionName),$0
    )
})
}
/**
 * Get the `TypeSchema` for a return value of a given receive function
 */
public func getReceiveReturnValueSchema(schema: ModuleSchema, contractName: String, functionName: String)throws  -> TypeSchema  {
    return try  FfiConverterTypeTypeSchema_lift(try rustCallWithError(FfiConverterTypeSchemaError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_receive_return_value_schema(
        FfiConverterTypeModuleSchema_lower(schema),
        FfiConverterString.lower(contractName),
        FfiConverterString.lower(functionName),$0
    )
})
}
/**
 * Compute the signature blinding randomness for the provided seed and identity indexes.
 */
public func identityAttributesSignatureBlindingRandomness(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_attributes_signature_blinding_randomness(
        FfiConverterTypeBytes_lower(seed),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),$0
    )
})
}
/**
 * Compute the IdCredSec for the provided seed and identity indexes.
 */
public func identityCredSec(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_cred_sec(
        FfiConverterTypeBytes_lower(seed),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),$0
    )
})
}
/**
 * Compute an identity issuance request for the identity contained in the provided parameters.
 * The result is a versioned `PreIdentityObject` encoded as JSON,
 * which is the format expected by the identity provider's issuance endpoint.
 */
public func identityIssuanceRequestJson(params: IdentityIssuanceRequestParameters)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_issuance_request_json(
        FfiConverterTypeIdentityIssuanceRequestParameters_lower(params),$0
    )
})
}
/**
 * Compute the PRF-key for the provided seed and identity indexes.
 */
public func identityPrfKey(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_prf_key(
        FfiConverterTypeBytes_lower(seed),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),$0
    )
})
}
/**
 * Construct an identity recovery request for the identity contained in the provided parameters.
 * The result encoded as JSON in the format expected by the identity provider's recovery endpoint.
 */
public func identityRecoveryRequestJson(params: IdentityRecoveryRequestParameters)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_recovery_request_json(
        FfiConverterTypeIdentityRecoveryRequestParameters_lower(params),$0
    )
})
}
/**
 * Attempt to create a BakerKeysPayload for the account and associated baker keys
 */
public func makeConfigureBakerKeysPayload(accountBase58: String, bakerKeys: BakerKeyPairs)throws  -> BakerKeysPayload  {
    return try  FfiConverterTypeBakerKeysPayload_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_make_configure_baker_keys_payload(
        FfiConverterString.lower(accountBase58),
        FfiConverterTypeBakerKeyPairs_lower(bakerKeys),$0
    )
})
}
/**
 * Parse the `Method` from the given string
 */
public func parseDidMethod(value: String)throws  -> Did  {
    return try  FfiConverterTypeDID_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_parse_did_method(
        FfiConverterString.lower(value),$0
    )
})
}
/**
 * Prove the supplied statement in the context of a given identity and credential
 */
public func proveIdentityStatement(seed: Bytes, net: Network, globalContext: GlobalContext, ipIndex: UInt32, identityIndex: UInt32, credentialIndex: UInt8, identityObject: IdentityObject, statement: IdentityStatement, challenge: Bytes)throws  -> VersionedIdentityProof  {
    return try  FfiConverterTypeVersionedIdentityProof_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_prove_identity_statement(
        FfiConverterTypeBytes_lower(seed),
        FfiConverterTypeNetwork_lower(net),
        FfiConverterTypeGlobalContext_lower(globalContext),
        FfiConverterUInt32.lower(ipIndex),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialIndex),
        FfiConverterTypeIdentityObject_lower(identityObject),
        FfiConverterTypeIdentityStatement_lower(statement),
        FfiConverterTypeBytes_lower(challenge),$0
    )
})
}
/**
 * Construct the payload for a TransferToPublic transaction. The `to_transfer` amount is specififed in microCCD.
 */
public func secToPubTransferData(ctx: GlobalContext, senderSecretKey: Bytes, inputAmount: InputEncryptedAmount, toTransfer: MicroCcdAmount)throws  -> SecToPubTransferData  {
    return try  FfiConverterTypeSecToPubTransferData_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_sec_to_pub_transfer_data(
        FfiConverterTypeGlobalContext_lower(ctx),
        FfiConverterTypeBytes_lower(senderSecretKey),
        FfiConverterTypeInputEncryptedAmount_lower(inputAmount),
        FfiConverterTypeMicroCCDAmount_lower(toTransfer),$0
    )
})
}
/**
 * Attempt to serialize CredentialDeploymentInfo into bytes. This will fail if any of the raw hex representations do not match the corresponding types in concordium-base
 */
public func serializeCredentialDeploymentInfo(credInfo: CredentialDeploymentInfo)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_serialize_credential_deployment_info(
        FfiConverterTypeCredentialDeploymentInfo_lower(credInfo),$0
    )
})
}
/**
 * Serialize the provided value from the JSON representation of a type corresponding to the provided `schema`
 */
public func serializeTypeValue(json: String, schema: TypeSchema)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSchemaError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_serialize_type_value(
        FfiConverterString.lower(json),
        FfiConverterTypeTypeSchema_lower(schema),$0
    )
})
}
/**
 * Compute the encoded verifiable credential backup encryption key for the provided seed.
 */
public func verifiableCredentialBackupEncryptionKey(seed: Bytes, network: Network)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_backup_encryption_key(
        FfiConverterTypeBytes_lower(seed),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
/**
 * Compute the public key for the provided seed, issuer indexes, and verifiable credential index.
 */
public func verifiableCredentialPublicKey(seed: Bytes, network: Network, issuerIndex: UInt64, issuerSubindex: UInt64, verifiableCredentialIndex: UInt32)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_public_key(
        FfiConverterTypeBytes_lower(seed),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterUInt64.lower(issuerIndex),
        FfiConverterUInt64.lower(issuerSubindex),
        FfiConverterUInt32.lower(verifiableCredentialIndex),$0
    )
})
}
/**
 * Compute the signing key for the provided seed, issuer indexes, and verifiable credential index.
 */
public func verifiableCredentialSigningKey(seed: Bytes, network: Network, issuerIndex: UInt64, issuerSubindex: UInt64, verifiableCredentialIndex: UInt32)throws  -> Bytes  {
    return try  FfiConverterTypeBytes_lift(try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError_lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_signing_key(
        FfiConverterTypeBytes_lower(seed),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterUInt64.lower(issuerIndex),
        FfiConverterUInt64.lower(issuerSubindex),
        FfiConverterUInt32.lower(verifiableCredentialIndex),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 30
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_concordium_wallet_crypto_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential() != 60596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_attribute_commitment_randomness() != 4427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_deployment_hash() != 36255) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_deployment_signed_payload() != 45685) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_id() != 3565) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_public_key() != 47246) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_signing_key() != 31350) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_combine_encrypted_amounts() != 63097) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_compute_anchor_hash() != 49580) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_create_verifiable_presentation() != 16440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_create_verifiable_presentation_v1() != 64726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_decrypt_amount() != 26331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_deserialize_sec_to_pub_transfer_data() != 15687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_deserialize_type_value() != 39476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_deserialize_update_credentials_payload() != 65247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_did_method_as_string() != 44533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_display_type_schema_template() != 53699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_generate_baker_keys() != 22656) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_encryption_keys() != 16571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_event_schema() != 34116) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_init_error_schema() != 41457) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_init_parameter_schema() != 54176) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_receive_error_schema() != 54098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_receive_parameter_schema() != 54281) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_receive_return_value_schema() != 56848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_attributes_signature_blinding_randomness() != 9248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_cred_sec() != 23778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_issuance_request_json() != 28061) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_prf_key() != 49972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_recovery_request_json() != 33579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_make_configure_baker_keys_payload() != 25683) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_parse_did_method() != 35114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_prove_identity_statement() != 12735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_sec_to_pub_transfer_data() != 45879) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_serialize_credential_deployment_info() != 61448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_serialize_type_value() != 39554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_backup_encryption_key() != 65529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_public_key() != 1842) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_signing_key() != 44677) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureConcordiumWalletCryptoUniffiInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all