// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(cryptoFFI)
import cryptoFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_concordium_wallet_crypto_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_concordium_wallet_crypto_uniffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

fileprivate struct FfiConverterTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Date {
        let seconds: Int64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        if seconds >= 0 {
            let delta = Double(seconds) + (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        } else {
            let delta = Double(seconds) - (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        }
    }

    public static func write(_ value: Date, into buf: inout [UInt8]) {
        var delta = value.timeIntervalSince1970
        var sign: Int64 = 1
        if delta < 0 {
            // The nanoseconds portion of the epoch offset must always be
            // positive, to simplify the calculation we will use the absolute
            // value of the offset.
            sign = -1
            delta = -delta
        }
        if delta.rounded(.down) > Double(Int64.max) {
            fatalError("Timestamp overflow, exceeds max bounds supported by Uniffi")
        }
        let seconds = Int64(delta)
        let nanoseconds = UInt32((delta - Double(seconds)) * 1.0e9)
        writeInt(&buf, sign * seconds)
        writeInt(&buf, nanoseconds)
    }
}


/**
 * An account credential containing proofs without signatures.
 * To deploy a credential, an object of this type is
 * hashed using `account_credential_deployment_hash`
 * which is signed using the key derived for the credential.
 * The results are collected into a `SignedAccountCredential`
 * and serialized using `account_credential_deployment_signed_payload`.
 * The result of this call can be submitted to the chain.
 */
public struct AccountCredential {
    /**
     * List of anonymity revokers which can revoke the identity.
     * The order is important since it is the same order as that signed by the identity provider,
     * and permuting the list will invalidate the signature from the identity provider.
     */
    public var arData: [UInt32: ChainArData]
    /**
     * Credential registration ID of the credential.
     */
    public var credId: Bytes
    /**
     * Credential keys (i.e. account holder keys).
     */
    public var credentialPublicKeys: CredentialPublicKeys
    /**
     * Identity of the identity provider who signed the identity object
     * from which this credential is derived.
     */
    public var ipIdentity: UInt32
    /**
     * Policy of this credential object.
     */
    public var policy: Policy
    public var proofs: Proofs
    /**
     * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
     */
    public var revocationThreshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * List of anonymity revokers which can revoke the identity.
         * The order is important since it is the same order as that signed by the identity provider,
         * and permuting the list will invalidate the signature from the identity provider.
         */
        arData: [UInt32: ChainArData], 
        /**
         * Credential registration ID of the credential.
         */
        credId: Bytes, 
        /**
         * Credential keys (i.e. account holder keys).
         */
        credentialPublicKeys: CredentialPublicKeys, 
        /**
         * Identity of the identity provider who signed the identity object
         * from which this credential is derived.
         */
        ipIdentity: UInt32, 
        /**
         * Policy of this credential object.
         */
        policy: Policy, 
        proofs: Proofs, 
        /**
         * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
         */
        revocationThreshold: UInt8) {
        self.arData = arData
        self.credId = credId
        self.credentialPublicKeys = credentialPublicKeys
        self.ipIdentity = ipIdentity
        self.policy = policy
        self.proofs = proofs
        self.revocationThreshold = revocationThreshold
    }
}


extension AccountCredential: Equatable, Hashable {
    public static func ==(lhs: AccountCredential, rhs: AccountCredential) -> Bool {
        if lhs.arData != rhs.arData {
            return false
        }
        if lhs.credId != rhs.credId {
            return false
        }
        if lhs.credentialPublicKeys != rhs.credentialPublicKeys {
            return false
        }
        if lhs.ipIdentity != rhs.ipIdentity {
            return false
        }
        if lhs.policy != rhs.policy {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        if lhs.revocationThreshold != rhs.revocationThreshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(arData)
        hasher.combine(credId)
        hasher.combine(credentialPublicKeys)
        hasher.combine(ipIdentity)
        hasher.combine(policy)
        hasher.combine(proofs)
        hasher.combine(revocationThreshold)
    }
}


public struct FfiConverterTypeAccountCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredential {
        return
            try AccountCredential(
                arData: FfiConverterDictionaryUInt32TypeChainArData.read(from: &buf), 
                credId: FfiConverterTypeBytes.read(from: &buf), 
                credentialPublicKeys: FfiConverterTypeCredentialPublicKeys.read(from: &buf), 
                ipIdentity: FfiConverterUInt32.read(from: &buf), 
                policy: FfiConverterTypePolicy.read(from: &buf), 
                proofs: FfiConverterTypeProofs.read(from: &buf), 
                revocationThreshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: AccountCredential, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt32TypeChainArData.write(value.arData, into: &buf)
        FfiConverterTypeBytes.write(value.credId, into: &buf)
        FfiConverterTypeCredentialPublicKeys.write(value.credentialPublicKeys, into: &buf)
        FfiConverterUInt32.write(value.ipIdentity, into: &buf)
        FfiConverterTypePolicy.write(value.policy, into: &buf)
        FfiConverterTypeProofs.write(value.proofs, into: &buf)
        FfiConverterUInt8.write(value.revocationThreshold, into: &buf)
    }
}


public func FfiConverterTypeAccountCredential_lift(_ buf: RustBuffer) throws -> AccountCredential {
    return try FfiConverterTypeAccountCredential.lift(buf)
}

public func FfiConverterTypeAccountCredential_lower(_ value: AccountCredential) -> RustBuffer {
    return FfiConverterTypeAccountCredential.lower(value)
}


/**
 * Parameter object for `account_credential`.
 */
public struct AccountCredentialParameters {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var arsInfos: [UInt32: AnonymityRevokerInfo]
    public var idObject: IdentityObject
    public var revealedAttributes: [AttributeTag]
    public var credNumber: UInt8
    public var idCredSec: Bytes
    public var prfKey: Bytes
    public var blindingRandomness: Bytes
    public var attributeRandomness: [AttributeTag: Bytes]
    public var credentialPublicKeys: CredentialPublicKeys

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        ipInfo: IdentityProviderInfo, 
        globalContext: GlobalContext, 
        arsInfos: [UInt32: AnonymityRevokerInfo], 
        idObject: IdentityObject, 
        revealedAttributes: [AttributeTag], 
        credNumber: UInt8, 
        idCredSec: Bytes, 
        prfKey: Bytes, 
        blindingRandomness: Bytes, 
        attributeRandomness: [AttributeTag: Bytes], 
        credentialPublicKeys: CredentialPublicKeys) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.arsInfos = arsInfos
        self.idObject = idObject
        self.revealedAttributes = revealedAttributes
        self.credNumber = credNumber
        self.idCredSec = idCredSec
        self.prfKey = prfKey
        self.blindingRandomness = blindingRandomness
        self.attributeRandomness = attributeRandomness
        self.credentialPublicKeys = credentialPublicKeys
    }
}


extension AccountCredentialParameters: Equatable, Hashable {
    public static func ==(lhs: AccountCredentialParameters, rhs: AccountCredentialParameters) -> Bool {
        if lhs.ipInfo != rhs.ipInfo {
            return false
        }
        if lhs.globalContext != rhs.globalContext {
            return false
        }
        if lhs.arsInfos != rhs.arsInfos {
            return false
        }
        if lhs.idObject != rhs.idObject {
            return false
        }
        if lhs.revealedAttributes != rhs.revealedAttributes {
            return false
        }
        if lhs.credNumber != rhs.credNumber {
            return false
        }
        if lhs.idCredSec != rhs.idCredSec {
            return false
        }
        if lhs.prfKey != rhs.prfKey {
            return false
        }
        if lhs.blindingRandomness != rhs.blindingRandomness {
            return false
        }
        if lhs.attributeRandomness != rhs.attributeRandomness {
            return false
        }
        if lhs.credentialPublicKeys != rhs.credentialPublicKeys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ipInfo)
        hasher.combine(globalContext)
        hasher.combine(arsInfos)
        hasher.combine(idObject)
        hasher.combine(revealedAttributes)
        hasher.combine(credNumber)
        hasher.combine(idCredSec)
        hasher.combine(prfKey)
        hasher.combine(blindingRandomness)
        hasher.combine(attributeRandomness)
        hasher.combine(credentialPublicKeys)
    }
}


public struct FfiConverterTypeAccountCredentialParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredentialParameters {
        return
            try AccountCredentialParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf), 
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf), 
                arsInfos: FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.read(from: &buf), 
                idObject: FfiConverterTypeIdentityObject.read(from: &buf), 
                revealedAttributes: FfiConverterSequenceTypeAttributeTag.read(from: &buf), 
                credNumber: FfiConverterUInt8.read(from: &buf), 
                idCredSec: FfiConverterTypeBytes.read(from: &buf), 
                prfKey: FfiConverterTypeBytes.read(from: &buf), 
                blindingRandomness: FfiConverterTypeBytes.read(from: &buf), 
                attributeRandomness: FfiConverterDictionaryTypeAttributeTagTypeBytes.read(from: &buf), 
                credentialPublicKeys: FfiConverterTypeCredentialPublicKeys.read(from: &buf)
        )
    }

    public static func write(_ value: AccountCredentialParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.write(value.arsInfos, into: &buf)
        FfiConverterTypeIdentityObject.write(value.idObject, into: &buf)
        FfiConverterSequenceTypeAttributeTag.write(value.revealedAttributes, into: &buf)
        FfiConverterUInt8.write(value.credNumber, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSec, into: &buf)
        FfiConverterTypeBytes.write(value.prfKey, into: &buf)
        FfiConverterTypeBytes.write(value.blindingRandomness, into: &buf)
        FfiConverterDictionaryTypeAttributeTagTypeBytes.write(value.attributeRandomness, into: &buf)
        FfiConverterTypeCredentialPublicKeys.write(value.credentialPublicKeys, into: &buf)
    }
}


public func FfiConverterTypeAccountCredentialParameters_lift(_ buf: RustBuffer) throws -> AccountCredentialParameters {
    return try FfiConverterTypeAccountCredentialParameters.lift(buf)
}

public func FfiConverterTypeAccountCredentialParameters_lower(_ value: AccountCredentialParameters) -> RustBuffer {
    return FfiConverterTypeAccountCredentialParameters.lower(value)
}


/**
 * The result of a new credential being created using the function `account_credential`.
 */
public struct AccountCredentialWithRandomness {
    public var credential: AccountCredential
    public var randomness: Randomness

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        credential: AccountCredential, 
        randomness: Randomness) {
        self.credential = credential
        self.randomness = randomness
    }
}


extension AccountCredentialWithRandomness: Equatable, Hashable {
    public static func ==(lhs: AccountCredentialWithRandomness, rhs: AccountCredentialWithRandomness) -> Bool {
        if lhs.credential != rhs.credential {
            return false
        }
        if lhs.randomness != rhs.randomness {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(credential)
        hasher.combine(randomness)
    }
}


public struct FfiConverterTypeAccountCredentialWithRandomness: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountCredentialWithRandomness {
        return
            try AccountCredentialWithRandomness(
                credential: FfiConverterTypeAccountCredential.read(from: &buf), 
                randomness: FfiConverterTypeRandomness.read(from: &buf)
        )
    }

    public static func write(_ value: AccountCredentialWithRandomness, into buf: inout [UInt8]) {
        FfiConverterTypeAccountCredential.write(value.credential, into: &buf)
        FfiConverterTypeRandomness.write(value.randomness, into: &buf)
    }
}


public func FfiConverterTypeAccountCredentialWithRandomness_lift(_ buf: RustBuffer) throws -> AccountCredentialWithRandomness {
    return try FfiConverterTypeAccountCredentialWithRandomness.lift(buf)
}

public func FfiConverterTypeAccountCredentialWithRandomness_lower(_ value: AccountCredentialWithRandomness) -> RustBuffer {
    return FfiConverterTypeAccountCredentialWithRandomness.lower(value)
}


/**
 * A pair of a statement and a proof for an account credential statement.
 */
public struct AccountStatementWithProof {
    public var statement: AtomicIdentityStatement
    public var proof: AtomicIdentityProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        statement: AtomicIdentityStatement, 
        proof: AtomicIdentityProof) {
        self.statement = statement
        self.proof = proof
    }
}


extension AccountStatementWithProof: Equatable, Hashable {
    public static func ==(lhs: AccountStatementWithProof, rhs: AccountStatementWithProof) -> Bool {
        if lhs.statement != rhs.statement {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(statement)
        hasher.combine(proof)
    }
}


public struct FfiConverterTypeAccountStatementWithProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountStatementWithProof {
        return
            try AccountStatementWithProof(
                statement: FfiConverterTypeAtomicIdentityStatement.read(from: &buf), 
                proof: FfiConverterTypeAtomicIdentityProof.read(from: &buf)
        )
    }

    public static func write(_ value: AccountStatementWithProof, into buf: inout [UInt8]) {
        FfiConverterTypeAtomicIdentityStatement.write(value.statement, into: &buf)
        FfiConverterTypeAtomicIdentityProof.write(value.proof, into: &buf)
    }
}


public func FfiConverterTypeAccountStatementWithProof_lift(_ buf: RustBuffer) throws -> AccountStatementWithProof {
    return try FfiConverterTypeAccountStatementWithProof.lift(buf)
}

public func FfiConverterTypeAccountStatementWithProof_lower(_ value: AccountStatementWithProof) -> RustBuffer {
    return FfiConverterTypeAccountStatementWithProof.lower(value)
}


/**
 * Information on an anonymity revoker held by the identity provider.
 */
public struct AnonymityRevokerInfo {
    /**
     * Unique identifier of the anonymity revoker.
     */
    public var identity: UInt32
    /**
     * Description of the anonymity revoker (e.g. name, contact number).
     */
    public var description: Description
    /**
     * Elgamal encryption key of the anonymity revoker.
     */
    public var publicKey: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier of the anonymity revoker.
         */
        identity: UInt32, 
        /**
         * Description of the anonymity revoker (e.g. name, contact number).
         */
        description: Description, 
        /**
         * Elgamal encryption key of the anonymity revoker.
         */
        publicKey: Bytes) {
        self.identity = identity
        self.description = description
        self.publicKey = publicKey
    }
}


extension AnonymityRevokerInfo: Equatable, Hashable {
    public static func ==(lhs: AnonymityRevokerInfo, rhs: AnonymityRevokerInfo) -> Bool {
        if lhs.identity != rhs.identity {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identity)
        hasher.combine(description)
        hasher.combine(publicKey)
    }
}


public struct FfiConverterTypeAnonymityRevokerInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnonymityRevokerInfo {
        return
            try AnonymityRevokerInfo(
                identity: FfiConverterUInt32.read(from: &buf), 
                description: FfiConverterTypeDescription.read(from: &buf), 
                publicKey: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: AnonymityRevokerInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.identity, into: &buf)
        FfiConverterTypeDescription.write(value.description, into: &buf)
        FfiConverterTypeBytes.write(value.publicKey, into: &buf)
    }
}


public func FfiConverterTypeAnonymityRevokerInfo_lift(_ buf: RustBuffer) throws -> AnonymityRevokerInfo {
    return try FfiConverterTypeAnonymityRevokerInfo.lift(buf)
}

public func FfiConverterTypeAnonymityRevokerInfo_lower(_ value: AnonymityRevokerInfo) -> RustBuffer {
    return FfiConverterTypeAnonymityRevokerInfo.lower(value)
}


/**
 * The data relating to a single anonymity revoker
 * sent by the account holder to the identity provider.
 * Typically the account holder will send a vector of these.
 */
public struct ArData {
    /**
     * Encryption in chunks (in little endian) of the PRF key share.
     */
    public var encPrfKeyShare: Bytes
    /**
     * Response in the proof that the computed commitment to the share
     * contains the same value as the encryption.
     * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
     */
    public var proofComEncEq: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Encryption in chunks (in little endian) of the PRF key share.
         */
        encPrfKeyShare: Bytes, 
        /**
         * Response in the proof that the computed commitment to the share
         * contains the same value as the encryption.
         * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
         */
        proofComEncEq: Bytes) {
        self.encPrfKeyShare = encPrfKeyShare
        self.proofComEncEq = proofComEncEq
    }
}


extension ArData: Equatable, Hashable {
    public static func ==(lhs: ArData, rhs: ArData) -> Bool {
        if lhs.encPrfKeyShare != rhs.encPrfKeyShare {
            return false
        }
        if lhs.proofComEncEq != rhs.proofComEncEq {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encPrfKeyShare)
        hasher.combine(proofComEncEq)
    }
}


public struct FfiConverterTypeArData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArData {
        return
            try ArData(
                encPrfKeyShare: FfiConverterTypeBytes.read(from: &buf), 
                proofComEncEq: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: ArData, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.encPrfKeyShare, into: &buf)
        FfiConverterTypeBytes.write(value.proofComEncEq, into: &buf)
    }
}


public func FfiConverterTypeArData_lift(_ buf: RustBuffer) throws -> ArData {
    return try FfiConverterTypeArData.lift(buf)
}

public func FfiConverterTypeArData_lower(_ value: ArData) -> RustBuffer {
    return FfiConverterTypeArData.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * in a range. The statement is that the attribute value lies in `[lower,
 * upper)` in the scalar field.
 */
public struct AttributeInRangeIdentityStatement {
    /**
     * The attribute that the verifier wants the user to prove is in a range.
     */
    public var attributeTag: AttributeTag
    /**
     * The lower bound on the range.
     */
    public var lower: String
    /**
     * The upper bound of the range.
     */
    public var upper: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to prove is in a range.
         */
        attributeTag: AttributeTag, 
        /**
         * The lower bound on the range.
         */
        lower: String, 
        /**
         * The upper bound of the range.
         */
        upper: String) {
        self.attributeTag = attributeTag
        self.lower = lower
        self.upper = upper
    }
}


extension AttributeInRangeIdentityStatement: Equatable, Hashable {
    public static func ==(lhs: AttributeInRangeIdentityStatement, rhs: AttributeInRangeIdentityStatement) -> Bool {
        if lhs.attributeTag != rhs.attributeTag {
            return false
        }
        if lhs.lower != rhs.lower {
            return false
        }
        if lhs.upper != rhs.upper {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributeTag)
        hasher.combine(lower)
        hasher.combine(upper)
    }
}


public struct FfiConverterTypeAttributeInRangeIdentityStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeInRangeIdentityStatement {
        return
            try AttributeInRangeIdentityStatement(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf), 
                lower: FfiConverterString.read(from: &buf), 
                upper: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeInRangeIdentityStatement, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
        FfiConverterString.write(value.lower, into: &buf)
        FfiConverterString.write(value.upper, into: &buf)
    }
}


public func FfiConverterTypeAttributeInRangeIdentityStatement_lift(_ buf: RustBuffer) throws -> AttributeInRangeIdentityStatement {
    return try FfiConverterTypeAttributeInRangeIdentityStatement.lift(buf)
}

public func FfiConverterTypeAttributeInRangeIdentityStatement_lower(_ value: AttributeInRangeIdentityStatement) -> RustBuffer {
    return FfiConverterTypeAttributeInRangeIdentityStatement.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * in a range. The statement is that the attribute value lies in `[lower,
 * upper)` in the scalar field.
 */
public struct AttributeInRangeWeb3IdStatement {
    /**
     * The attribute that the verifier wants the user to prove is in a range.
     */
    public var attributeTag: String
    /**
     * The lower bound on the range.
     */
    public var lower: Web3IdAttribute
    /**
     * The upper bound of the range.
     */
    public var upper: Web3IdAttribute

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to prove is in a range.
         */
        attributeTag: String, 
        /**
         * The lower bound on the range.
         */
        lower: Web3IdAttribute, 
        /**
         * The upper bound of the range.
         */
        upper: Web3IdAttribute) {
        self.attributeTag = attributeTag
        self.lower = lower
        self.upper = upper
    }
}


extension AttributeInRangeWeb3IdStatement: Equatable, Hashable {
    public static func ==(lhs: AttributeInRangeWeb3IdStatement, rhs: AttributeInRangeWeb3IdStatement) -> Bool {
        if lhs.attributeTag != rhs.attributeTag {
            return false
        }
        if lhs.lower != rhs.lower {
            return false
        }
        if lhs.upper != rhs.upper {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributeTag)
        hasher.combine(lower)
        hasher.combine(upper)
    }
}


public struct FfiConverterTypeAttributeInRangeWeb3IdStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeInRangeWeb3IdStatement {
        return
            try AttributeInRangeWeb3IdStatement(
                attributeTag: FfiConverterString.read(from: &buf), 
                lower: FfiConverterTypeWeb3IdAttribute.read(from: &buf), 
                upper: FfiConverterTypeWeb3IdAttribute.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeInRangeWeb3IdStatement, into buf: inout [UInt8]) {
        FfiConverterString.write(value.attributeTag, into: &buf)
        FfiConverterTypeWeb3IdAttribute.write(value.lower, into: &buf)
        FfiConverterTypeWeb3IdAttribute.write(value.upper, into: &buf)
    }
}


public func FfiConverterTypeAttributeInRangeWeb3IdStatement_lift(_ buf: RustBuffer) throws -> AttributeInRangeWeb3IdStatement {
    return try FfiConverterTypeAttributeInRangeWeb3IdStatement.lift(buf)
}

public func FfiConverterTypeAttributeInRangeWeb3IdStatement_lower(_ value: AttributeInRangeWeb3IdStatement) -> RustBuffer {
    return FfiConverterTypeAttributeInRangeWeb3IdStatement.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * in a set of attributes.
 */
public struct AttributeInSetIdentityStatement {
    /**
     * The attribute that the verifier wants the user prove lies in a set.
     */
    public var attributeTag: AttributeTag
    /**
     * The set that the attribute should lie in.
     */
    public var set: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user prove lies in a set.
         */
        attributeTag: AttributeTag, 
        /**
         * The set that the attribute should lie in.
         */
        set: [String]) {
        self.attributeTag = attributeTag
        self.set = set
    }
}


extension AttributeInSetIdentityStatement: Equatable, Hashable {
    public static func ==(lhs: AttributeInSetIdentityStatement, rhs: AttributeInSetIdentityStatement) -> Bool {
        if lhs.attributeTag != rhs.attributeTag {
            return false
        }
        if lhs.set != rhs.set {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributeTag)
        hasher.combine(set)
    }
}


public struct FfiConverterTypeAttributeInSetIdentityStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeInSetIdentityStatement {
        return
            try AttributeInSetIdentityStatement(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf), 
                set: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeInSetIdentityStatement, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
        FfiConverterSequenceString.write(value.set, into: &buf)
    }
}


public func FfiConverterTypeAttributeInSetIdentityStatement_lift(_ buf: RustBuffer) throws -> AttributeInSetIdentityStatement {
    return try FfiConverterTypeAttributeInSetIdentityStatement.lift(buf)
}

public func FfiConverterTypeAttributeInSetIdentityStatement_lower(_ value: AttributeInSetIdentityStatement) -> RustBuffer {
    return FfiConverterTypeAttributeInSetIdentityStatement.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * in a set of attributes.
 */
public struct AttributeInSetWeb3IdStatement {
    /**
     * The attribute that the verifier wants the user prove lies in a set.
     */
    public var attributeTag: String
    /**
     * The set that the attribute should lie in.
     */
    public var set: [Web3IdAttribute]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user prove lies in a set.
         */
        attributeTag: String, 
        /**
         * The set that the attribute should lie in.
         */
        set: [Web3IdAttribute]) {
        self.attributeTag = attributeTag
        self.set = set
    }
}


extension AttributeInSetWeb3IdStatement: Equatable, Hashable {
    public static func ==(lhs: AttributeInSetWeb3IdStatement, rhs: AttributeInSetWeb3IdStatement) -> Bool {
        if lhs.attributeTag != rhs.attributeTag {
            return false
        }
        if lhs.set != rhs.set {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributeTag)
        hasher.combine(set)
    }
}


public struct FfiConverterTypeAttributeInSetWeb3IdStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeInSetWeb3IdStatement {
        return
            try AttributeInSetWeb3IdStatement(
                attributeTag: FfiConverterString.read(from: &buf), 
                set: FfiConverterSequenceTypeWeb3IdAttribute.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeInSetWeb3IdStatement, into buf: inout [UInt8]) {
        FfiConverterString.write(value.attributeTag, into: &buf)
        FfiConverterSequenceTypeWeb3IdAttribute.write(value.set, into: &buf)
    }
}


public func FfiConverterTypeAttributeInSetWeb3IdStatement_lift(_ buf: RustBuffer) throws -> AttributeInSetWeb3IdStatement {
    return try FfiConverterTypeAttributeInSetWeb3IdStatement.lift(buf)
}

public func FfiConverterTypeAttributeInSetWeb3IdStatement_lower(_ value: AttributeInSetWeb3IdStatement) -> RustBuffer {
    return FfiConverterTypeAttributeInSetWeb3IdStatement.lower(value)
}


/**
 * An attribute list that is part of a normal credential.
 * It consists of some mandatory attributes and some user selected attributes.
 */
public struct AttributeList {
    /**
     * The latest month and year where the credential is still valid.
     */
    public var validToYearMonth: String
    /**
     * The year and month when the identity object from which the credential is derived was created.
     * This deliberately has low granularity since if it was, e.g., a unix timestamp in seconds,
     * then the identity provider could link accounts on the chain to identities they have issued.
     */
    public var createdAtYearMonth: String
    /**
     * Maximum number of accounts that can be created from the owning identity object.
     */
    public var maxAccounts: UInt8
    /**
     * The attributes map.
     */
    public var chosenAttributes: [AttributeTag: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The latest month and year where the credential is still valid.
         */
        validToYearMonth: String, 
        /**
         * The year and month when the identity object from which the credential is derived was created.
         * This deliberately has low granularity since if it was, e.g., a unix timestamp in seconds,
         * then the identity provider could link accounts on the chain to identities they have issued.
         */
        createdAtYearMonth: String, 
        /**
         * Maximum number of accounts that can be created from the owning identity object.
         */
        maxAccounts: UInt8, 
        /**
         * The attributes map.
         */
        chosenAttributes: [AttributeTag: String]) {
        self.validToYearMonth = validToYearMonth
        self.createdAtYearMonth = createdAtYearMonth
        self.maxAccounts = maxAccounts
        self.chosenAttributes = chosenAttributes
    }
}


extension AttributeList: Equatable, Hashable {
    public static func ==(lhs: AttributeList, rhs: AttributeList) -> Bool {
        if lhs.validToYearMonth != rhs.validToYearMonth {
            return false
        }
        if lhs.createdAtYearMonth != rhs.createdAtYearMonth {
            return false
        }
        if lhs.maxAccounts != rhs.maxAccounts {
            return false
        }
        if lhs.chosenAttributes != rhs.chosenAttributes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validToYearMonth)
        hasher.combine(createdAtYearMonth)
        hasher.combine(maxAccounts)
        hasher.combine(chosenAttributes)
    }
}


public struct FfiConverterTypeAttributeList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeList {
        return
            try AttributeList(
                validToYearMonth: FfiConverterString.read(from: &buf), 
                createdAtYearMonth: FfiConverterString.read(from: &buf), 
                maxAccounts: FfiConverterUInt8.read(from: &buf), 
                chosenAttributes: FfiConverterDictionaryTypeAttributeTagString.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeList, into buf: inout [UInt8]) {
        FfiConverterString.write(value.validToYearMonth, into: &buf)
        FfiConverterString.write(value.createdAtYearMonth, into: &buf)
        FfiConverterUInt8.write(value.maxAccounts, into: &buf)
        FfiConverterDictionaryTypeAttributeTagString.write(value.chosenAttributes, into: &buf)
    }
}


public func FfiConverterTypeAttributeList_lift(_ buf: RustBuffer) throws -> AttributeList {
    return try FfiConverterTypeAttributeList.lift(buf)
}

public func FfiConverterTypeAttributeList_lower(_ value: AttributeList) -> RustBuffer {
    return FfiConverterTypeAttributeList.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * not in a set of attributes.
 */
public struct AttributeNotInSetIdentityStatement {
    /**
     * The attribute that the verifier wants the user to prove does not lie in
     * a set.
     */
    public var attributeTag: AttributeTag
    /**
     * The set that the attribute should not lie in.
     */
    public var set: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to prove does not lie in
         * a set.
         */
        attributeTag: AttributeTag, 
        /**
         * The set that the attribute should not lie in.
         */
        set: [String]) {
        self.attributeTag = attributeTag
        self.set = set
    }
}


extension AttributeNotInSetIdentityStatement: Equatable, Hashable {
    public static func ==(lhs: AttributeNotInSetIdentityStatement, rhs: AttributeNotInSetIdentityStatement) -> Bool {
        if lhs.attributeTag != rhs.attributeTag {
            return false
        }
        if lhs.set != rhs.set {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributeTag)
        hasher.combine(set)
    }
}


public struct FfiConverterTypeAttributeNotInSetIdentityStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeNotInSetIdentityStatement {
        return
            try AttributeNotInSetIdentityStatement(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf), 
                set: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeNotInSetIdentityStatement, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
        FfiConverterSequenceString.write(value.set, into: &buf)
    }
}


public func FfiConverterTypeAttributeNotInSetIdentityStatement_lift(_ buf: RustBuffer) throws -> AttributeNotInSetIdentityStatement {
    return try FfiConverterTypeAttributeNotInSetIdentityStatement.lift(buf)
}

public func FfiConverterTypeAttributeNotInSetIdentityStatement_lower(_ value: AttributeNotInSetIdentityStatement) -> RustBuffer {
    return FfiConverterTypeAttributeNotInSetIdentityStatement.lower(value)
}


/**
 * For the case where the verifier wants the user to prove that an attribute is
 * not in a set of attributes.
 */
public struct AttributeNotInSetWeb3IdStatement {
    /**
     * The attribute that the verifier wants the user to prove does not lie in
     * a set.
     */
    public var attributeTag: String
    /**
     * The set that the attribute should not lie in.
     */
    public var set: [Web3IdAttribute]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to prove does not lie in
         * a set.
         */
        attributeTag: String, 
        /**
         * The set that the attribute should not lie in.
         */
        set: [Web3IdAttribute]) {
        self.attributeTag = attributeTag
        self.set = set
    }
}


extension AttributeNotInSetWeb3IdStatement: Equatable, Hashable {
    public static func ==(lhs: AttributeNotInSetWeb3IdStatement, rhs: AttributeNotInSetWeb3IdStatement) -> Bool {
        if lhs.attributeTag != rhs.attributeTag {
            return false
        }
        if lhs.set != rhs.set {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributeTag)
        hasher.combine(set)
    }
}


public struct FfiConverterTypeAttributeNotInSetWeb3IdStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeNotInSetWeb3IdStatement {
        return
            try AttributeNotInSetWeb3IdStatement(
                attributeTag: FfiConverterString.read(from: &buf), 
                set: FfiConverterSequenceTypeWeb3IdAttribute.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeNotInSetWeb3IdStatement, into buf: inout [UInt8]) {
        FfiConverterString.write(value.attributeTag, into: &buf)
        FfiConverterSequenceTypeWeb3IdAttribute.write(value.set, into: &buf)
    }
}


public func FfiConverterTypeAttributeNotInSetWeb3IdStatement_lift(_ buf: RustBuffer) throws -> AttributeNotInSetWeb3IdStatement {
    return try FfiConverterTypeAttributeNotInSetWeb3IdStatement.lift(buf)
}

public func FfiConverterTypeAttributeNotInSetWeb3IdStatement_lower(_ value: AttributeNotInSetWeb3IdStatement) -> RustBuffer {
    return FfiConverterTypeAttributeNotInSetWeb3IdStatement.lower(value)
}


public struct BakerKeyPairs {
    public var signatureSign: Bytes
    public var signatureVerify: Bytes
    public var electionSign: Bytes
    public var electionVerify: Bytes
    public var aggregationSign: Bytes
    public var aggregationVerify: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        signatureSign: Bytes, 
        signatureVerify: Bytes, 
        electionSign: Bytes, 
        electionVerify: Bytes, 
        aggregationSign: Bytes, 
        aggregationVerify: Bytes) {
        self.signatureSign = signatureSign
        self.signatureVerify = signatureVerify
        self.electionSign = electionSign
        self.electionVerify = electionVerify
        self.aggregationSign = aggregationSign
        self.aggregationVerify = aggregationVerify
    }
}


extension BakerKeyPairs: Equatable, Hashable {
    public static func ==(lhs: BakerKeyPairs, rhs: BakerKeyPairs) -> Bool {
        if lhs.signatureSign != rhs.signatureSign {
            return false
        }
        if lhs.signatureVerify != rhs.signatureVerify {
            return false
        }
        if lhs.electionSign != rhs.electionSign {
            return false
        }
        if lhs.electionVerify != rhs.electionVerify {
            return false
        }
        if lhs.aggregationSign != rhs.aggregationSign {
            return false
        }
        if lhs.aggregationVerify != rhs.aggregationVerify {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signatureSign)
        hasher.combine(signatureVerify)
        hasher.combine(electionSign)
        hasher.combine(electionVerify)
        hasher.combine(aggregationSign)
        hasher.combine(aggregationVerify)
    }
}


public struct FfiConverterTypeBakerKeyPairs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BakerKeyPairs {
        return
            try BakerKeyPairs(
                signatureSign: FfiConverterTypeBytes.read(from: &buf), 
                signatureVerify: FfiConverterTypeBytes.read(from: &buf), 
                electionSign: FfiConverterTypeBytes.read(from: &buf), 
                electionVerify: FfiConverterTypeBytes.read(from: &buf), 
                aggregationSign: FfiConverterTypeBytes.read(from: &buf), 
                aggregationVerify: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: BakerKeyPairs, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.signatureSign, into: &buf)
        FfiConverterTypeBytes.write(value.signatureVerify, into: &buf)
        FfiConverterTypeBytes.write(value.electionSign, into: &buf)
        FfiConverterTypeBytes.write(value.electionVerify, into: &buf)
        FfiConverterTypeBytes.write(value.aggregationSign, into: &buf)
        FfiConverterTypeBytes.write(value.aggregationVerify, into: &buf)
    }
}


public func FfiConverterTypeBakerKeyPairs_lift(_ buf: RustBuffer) throws -> BakerKeyPairs {
    return try FfiConverterTypeBakerKeyPairs.lift(buf)
}

public func FfiConverterTypeBakerKeyPairs_lower(_ value: BakerKeyPairs) -> RustBuffer {
    return FfiConverterTypeBakerKeyPairs.lower(value)
}


public struct BakerKeysPayload {
    public var signatureVerifyKey: Bytes
    public var electionVerifyKey: Bytes
    public var aggregationVerifyKey: Bytes
    public var proofSig: Bytes
    public var proofElection: Bytes
    public var proofAggregation: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        signatureVerifyKey: Bytes, 
        electionVerifyKey: Bytes, 
        aggregationVerifyKey: Bytes, 
        proofSig: Bytes, 
        proofElection: Bytes, 
        proofAggregation: Bytes) {
        self.signatureVerifyKey = signatureVerifyKey
        self.electionVerifyKey = electionVerifyKey
        self.aggregationVerifyKey = aggregationVerifyKey
        self.proofSig = proofSig
        self.proofElection = proofElection
        self.proofAggregation = proofAggregation
    }
}


extension BakerKeysPayload: Equatable, Hashable {
    public static func ==(lhs: BakerKeysPayload, rhs: BakerKeysPayload) -> Bool {
        if lhs.signatureVerifyKey != rhs.signatureVerifyKey {
            return false
        }
        if lhs.electionVerifyKey != rhs.electionVerifyKey {
            return false
        }
        if lhs.aggregationVerifyKey != rhs.aggregationVerifyKey {
            return false
        }
        if lhs.proofSig != rhs.proofSig {
            return false
        }
        if lhs.proofElection != rhs.proofElection {
            return false
        }
        if lhs.proofAggregation != rhs.proofAggregation {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signatureVerifyKey)
        hasher.combine(electionVerifyKey)
        hasher.combine(aggregationVerifyKey)
        hasher.combine(proofSig)
        hasher.combine(proofElection)
        hasher.combine(proofAggregation)
    }
}


public struct FfiConverterTypeBakerKeysPayload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BakerKeysPayload {
        return
            try BakerKeysPayload(
                signatureVerifyKey: FfiConverterTypeBytes.read(from: &buf), 
                electionVerifyKey: FfiConverterTypeBytes.read(from: &buf), 
                aggregationVerifyKey: FfiConverterTypeBytes.read(from: &buf), 
                proofSig: FfiConverterTypeBytes.read(from: &buf), 
                proofElection: FfiConverterTypeBytes.read(from: &buf), 
                proofAggregation: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: BakerKeysPayload, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.signatureVerifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.electionVerifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.aggregationVerifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.proofSig, into: &buf)
        FfiConverterTypeBytes.write(value.proofElection, into: &buf)
        FfiConverterTypeBytes.write(value.proofAggregation, into: &buf)
    }
}


public func FfiConverterTypeBakerKeysPayload_lift(_ buf: RustBuffer) throws -> BakerKeysPayload {
    return try FfiConverterTypeBakerKeysPayload.lift(buf)
}

public func FfiConverterTypeBakerKeysPayload_lower(_ value: BakerKeysPayload) -> RustBuffer {
    return FfiConverterTypeBakerKeysPayload.lower(value)
}


/**
 * Data relating to a single anonymity revoker constructed by the account holder.
 * Typically a vector of these will be sent to the chain.
 */
public struct ChainArData {
    public var encIdCredPubShare: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        encIdCredPubShare: Bytes) {
        self.encIdCredPubShare = encIdCredPubShare
    }
}


extension ChainArData: Equatable, Hashable {
    public static func ==(lhs: ChainArData, rhs: ChainArData) -> Bool {
        if lhs.encIdCredPubShare != rhs.encIdCredPubShare {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encIdCredPubShare)
    }
}


public struct FfiConverterTypeChainArData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainArData {
        return
            try ChainArData(
                encIdCredPubShare: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: ChainArData, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.encIdCredPubShare, into: &buf)
    }
}


public func FfiConverterTypeChainArData_lift(_ buf: RustBuffer) throws -> ChainArData {
    return try FfiConverterTypeChainArData.lift(buf)
}

public func FfiConverterTypeChainArData_lower(_ value: ChainArData) -> RustBuffer {
    return FfiConverterTypeChainArData.lower(value)
}


/**
 * Choice of anonymity revocation parameters.
 */
public struct ChoiceArParameters {
    public var arIdentities: [UInt32]
    public var threshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        arIdentities: [UInt32], 
        threshold: UInt8) {
        self.arIdentities = arIdentities
        self.threshold = threshold
    }
}


extension ChoiceArParameters: Equatable, Hashable {
    public static func ==(lhs: ChoiceArParameters, rhs: ChoiceArParameters) -> Bool {
        if lhs.arIdentities != rhs.arIdentities {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(arIdentities)
        hasher.combine(threshold)
    }
}


public struct FfiConverterTypeChoiceArParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChoiceArParameters {
        return
            try ChoiceArParameters(
                arIdentities: FfiConverterSequenceUInt32.read(from: &buf), 
                threshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ChoiceArParameters, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt32.write(value.arIdentities, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
    }
}


public func FfiConverterTypeChoiceArParameters_lift(_ buf: RustBuffer) throws -> ChoiceArParameters {
    return try FfiConverterTypeChoiceArParameters.lift(buf)
}

public func FfiConverterTypeChoiceArParameters_lower(_ value: ChoiceArParameters) -> RustBuffer {
    return FfiConverterTypeChoiceArParameters.lower(value)
}


/**
 * Represents an address of a smart contract
 */
public struct ContractAddress {
    public var index: UInt64
    public var subindex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        index: UInt64, 
        subindex: UInt64) {
        self.index = index
        self.subindex = subindex
    }
}


extension ContractAddress: Equatable, Hashable {
    public static func ==(lhs: ContractAddress, rhs: ContractAddress) -> Bool {
        if lhs.index != rhs.index {
            return false
        }
        if lhs.subindex != rhs.subindex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(index)
        hasher.combine(subindex)
    }
}


public struct FfiConverterTypeContractAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContractAddress {
        return
            try ContractAddress(
                index: FfiConverterUInt64.read(from: &buf), 
                subindex: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ContractAddress, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.index, into: &buf)
        FfiConverterUInt64.write(value.subindex, into: &buf)
    }
}


public func FfiConverterTypeContractAddress_lift(_ buf: RustBuffer) throws -> ContractAddress {
    return try FfiConverterTypeContractAddress.lift(buf)
}

public func FfiConverterTypeContractAddress_lower(_ value: ContractAddress) -> RustBuffer {
    return FfiConverterTypeContractAddress.lower(value)
}


/**
 * A credential with attributes, public keys, and proofs that it is
 * well-formed.
 */
public struct CredentialDeploymentInfo {
    /**
     * List of anonymity revokers which can revoke the identity.
     * The order is important since it is the same order as that signed by the identity provider,
     * and permuting the list will invalidate the signature from the identity provider.
     */
    public var arData: [UInt32: ChainArData]
    /**
     * Credential registration ID of the credential.
     * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base.
     */
    public var credId: Bytes
    /**
     * Credential keys (i.e. account holder keys).
     */
    public var credentialPublicKeys: CredentialPublicKeys
    /**
     * Identity of the identity provider who signed the identity object
     * from which this credential is derived.
     */
    public var ipIdentity: UInt32
    /**
     * Policy of this credential object.
     */
    public var policy: Policy
    /**
     * The proofs of ownership.
     * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base
     */
    public var proofs: Bytes
    /**
     * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
     */
    public var revocationThreshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * List of anonymity revokers which can revoke the identity.
         * The order is important since it is the same order as that signed by the identity provider,
         * and permuting the list will invalidate the signature from the identity provider.
         */
        arData: [UInt32: ChainArData], 
        /**
         * Credential registration ID of the credential.
         * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base.
         */
        credId: Bytes, 
        /**
         * Credential keys (i.e. account holder keys).
         */
        credentialPublicKeys: CredentialPublicKeys, 
        /**
         * Identity of the identity provider who signed the identity object
         * from which this credential is derived.
         */
        ipIdentity: UInt32, 
        /**
         * Policy of this credential object.
         */
        policy: Policy, 
        /**
         * The proofs of ownership.
         * Serialized according to the corresponding `serde::Serialize` implementation in concordium-base
         */
        proofs: Bytes, 
        /**
         * Anonymity revocation threshold. Must be less than the number of entries in `ar_data`.
         */
        revocationThreshold: UInt8) {
        self.arData = arData
        self.credId = credId
        self.credentialPublicKeys = credentialPublicKeys
        self.ipIdentity = ipIdentity
        self.policy = policy
        self.proofs = proofs
        self.revocationThreshold = revocationThreshold
    }
}


extension CredentialDeploymentInfo: Equatable, Hashable {
    public static func ==(lhs: CredentialDeploymentInfo, rhs: CredentialDeploymentInfo) -> Bool {
        if lhs.arData != rhs.arData {
            return false
        }
        if lhs.credId != rhs.credId {
            return false
        }
        if lhs.credentialPublicKeys != rhs.credentialPublicKeys {
            return false
        }
        if lhs.ipIdentity != rhs.ipIdentity {
            return false
        }
        if lhs.policy != rhs.policy {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        if lhs.revocationThreshold != rhs.revocationThreshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(arData)
        hasher.combine(credId)
        hasher.combine(credentialPublicKeys)
        hasher.combine(ipIdentity)
        hasher.combine(policy)
        hasher.combine(proofs)
        hasher.combine(revocationThreshold)
    }
}


public struct FfiConverterTypeCredentialDeploymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialDeploymentInfo {
        return
            try CredentialDeploymentInfo(
                arData: FfiConverterDictionaryUInt32TypeChainArData.read(from: &buf), 
                credId: FfiConverterTypeBytes.read(from: &buf), 
                credentialPublicKeys: FfiConverterTypeCredentialPublicKeys.read(from: &buf), 
                ipIdentity: FfiConverterUInt32.read(from: &buf), 
                policy: FfiConverterTypePolicy.read(from: &buf), 
                proofs: FfiConverterTypeBytes.read(from: &buf), 
                revocationThreshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialDeploymentInfo, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt32TypeChainArData.write(value.arData, into: &buf)
        FfiConverterTypeBytes.write(value.credId, into: &buf)
        FfiConverterTypeCredentialPublicKeys.write(value.credentialPublicKeys, into: &buf)
        FfiConverterUInt32.write(value.ipIdentity, into: &buf)
        FfiConverterTypePolicy.write(value.policy, into: &buf)
        FfiConverterTypeBytes.write(value.proofs, into: &buf)
        FfiConverterUInt8.write(value.revocationThreshold, into: &buf)
    }
}


public func FfiConverterTypeCredentialDeploymentInfo_lift(_ buf: RustBuffer) throws -> CredentialDeploymentInfo {
    return try FfiConverterTypeCredentialDeploymentInfo.lift(buf)
}

public func FfiConverterTypeCredentialDeploymentInfo_lower(_ value: CredentialDeploymentInfo) -> RustBuffer {
    return FfiConverterTypeCredentialDeploymentInfo.lower(value)
}


/**
 * Public credential keys currently on the account.
 * The threshold determines the number of required signatures on a transaction for it to be valid.
 */
public struct CredentialPublicKeys {
    public var keys: [UInt8: VerifyKey]
    public var threshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        keys: [UInt8: VerifyKey], 
        threshold: UInt8) {
        self.keys = keys
        self.threshold = threshold
    }
}


extension CredentialPublicKeys: Equatable, Hashable {
    public static func ==(lhs: CredentialPublicKeys, rhs: CredentialPublicKeys) -> Bool {
        if lhs.keys != rhs.keys {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keys)
        hasher.combine(threshold)
    }
}


public struct FfiConverterTypeCredentialPublicKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialPublicKeys {
        return
            try CredentialPublicKeys(
                keys: FfiConverterDictionaryUInt8TypeVerifyKey.read(from: &buf), 
                threshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialPublicKeys, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt8TypeVerifyKey.write(value.keys, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
    }
}


public func FfiConverterTypeCredentialPublicKeys_lift(_ buf: RustBuffer) throws -> CredentialPublicKeys {
    return try FfiConverterTypeCredentialPublicKeys.lift(buf)
}

public func FfiConverterTypeCredentialPublicKeys_lower(_ value: CredentialPublicKeys) -> RustBuffer {
    return FfiConverterTypeCredentialPublicKeys.lower(value)
}


public struct Did {
    /**
     * The network part of the method.
     */
    public var network: Network
    /**
     * The remaining identifier.
     */
    public var idType: IdentifierType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The network part of the method.
         */
        network: Network, 
        /**
         * The remaining identifier.
         */
        idType: IdentifierType) {
        self.network = network
        self.idType = idType
    }
}


extension Did: Equatable, Hashable {
    public static func ==(lhs: Did, rhs: Did) -> Bool {
        if lhs.network != rhs.network {
            return false
        }
        if lhs.idType != rhs.idType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(network)
        hasher.combine(idType)
    }
}


public struct FfiConverterTypeDID: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Did {
        return
            try Did(
                network: FfiConverterTypeNetwork.read(from: &buf), 
                idType: FfiConverterTypeIdentifierType.read(from: &buf)
        )
    }

    public static func write(_ value: Did, into buf: inout [UInt8]) {
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterTypeIdentifierType.write(value.idType, into: &buf)
    }
}


public func FfiConverterTypeDID_lift(_ buf: RustBuffer) throws -> Did {
    return try FfiConverterTypeDID.lift(buf)
}

public func FfiConverterTypeDID_lower(_ value: Did) -> RustBuffer {
    return FfiConverterTypeDID.lower(value)
}


/**
 * Metadata of an identity provider or anonymity revoker
 * to be visible on the chain.
 */
public struct Description {
    public var name: String
    public var url: String
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        name: String, 
        url: String, 
        description: String) {
        self.name = name
        self.url = url
        self.description = description
    }
}


extension Description: Equatable, Hashable {
    public static func ==(lhs: Description, rhs: Description) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(url)
        hasher.combine(description)
    }
}


public struct FfiConverterTypeDescription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Description {
        return
            try Description(
                name: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Description, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}


public func FfiConverterTypeDescription_lift(_ buf: RustBuffer) throws -> Description {
    return try FfiConverterTypeDescription.lift(buf)
}

public func FfiConverterTypeDescription_lower(_ value: Description) -> RustBuffer {
    return FfiConverterTypeDescription.lower(value)
}


/**
 * Encryption keypair for an account, used to handle the encrypted amount associated with a specific account.
 */
public struct EncryptionKeys {
    /**
     * The secret key serialized as bytes.
     */
    public var secret: Bytes
    /**
     * The public key serialized as bytes.
     */
    public var `public`: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The secret key serialized as bytes.
         */
        secret: Bytes, 
        /**
         * The public key serialized as bytes.
         */
        `public`: Bytes) {
        self.secret = secret
        self.`public` = `public`
    }
}


extension EncryptionKeys: Equatable, Hashable {
    public static func ==(lhs: EncryptionKeys, rhs: EncryptionKeys) -> Bool {
        if lhs.secret != rhs.secret {
            return false
        }
        if lhs.`public` != rhs.`public` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secret)
        hasher.combine(`public`)
    }
}


public struct FfiConverterTypeEncryptionKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionKeys {
        return
            try EncryptionKeys(
                secret: FfiConverterTypeBytes.read(from: &buf), 
                public: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: EncryptionKeys, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.secret, into: &buf)
        FfiConverterTypeBytes.write(value.`public`, into: &buf)
    }
}


public func FfiConverterTypeEncryptionKeys_lift(_ buf: RustBuffer) throws -> EncryptionKeys {
    return try FfiConverterTypeEncryptionKeys.lift(buf)
}

public func FfiConverterTypeEncryptionKeys_lower(_ value: EncryptionKeys) -> RustBuffer {
    return FfiConverterTypeEncryptionKeys.lower(value)
}


/**
 * A set of cryptographic parameters that are particular to the chain and
 * shared by everybody that interacts with the chain.
 */
public struct GlobalContext {
    /**
     * Shared commitment key known to the chain and the account holder (i.e. it's public).
     * The account holder uses this commitment key to generate commitments to values in the attribute list.
     */
    public var onChainCommitmentKey: Bytes
    /**
     * Generators for the bulletproofs.
     */
    public var bulletproofGenerators: Bytes
    /**
     * Free-form string used to distinguish between different chains even if they share other parameters.
     */
    public var genesisString: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Shared commitment key known to the chain and the account holder (i.e. it's public).
         * The account holder uses this commitment key to generate commitments to values in the attribute list.
         */
        onChainCommitmentKey: Bytes, 
        /**
         * Generators for the bulletproofs.
         */
        bulletproofGenerators: Bytes, 
        /**
         * Free-form string used to distinguish between different chains even if they share other parameters.
         */
        genesisString: String) {
        self.onChainCommitmentKey = onChainCommitmentKey
        self.bulletproofGenerators = bulletproofGenerators
        self.genesisString = genesisString
    }
}


extension GlobalContext: Equatable, Hashable {
    public static func ==(lhs: GlobalContext, rhs: GlobalContext) -> Bool {
        if lhs.onChainCommitmentKey != rhs.onChainCommitmentKey {
            return false
        }
        if lhs.bulletproofGenerators != rhs.bulletproofGenerators {
            return false
        }
        if lhs.genesisString != rhs.genesisString {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(onChainCommitmentKey)
        hasher.combine(bulletproofGenerators)
        hasher.combine(genesisString)
    }
}


public struct FfiConverterTypeGlobalContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalContext {
        return
            try GlobalContext(
                onChainCommitmentKey: FfiConverterTypeBytes.read(from: &buf), 
                bulletproofGenerators: FfiConverterTypeBytes.read(from: &buf), 
                genesisString: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GlobalContext, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.onChainCommitmentKey, into: &buf)
        FfiConverterTypeBytes.write(value.bulletproofGenerators, into: &buf)
        FfiConverterString.write(value.genesisString, into: &buf)
    }
}


public func FfiConverterTypeGlobalContext_lift(_ buf: RustBuffer) throws -> GlobalContext {
    return try FfiConverterTypeGlobalContext.lift(buf)
}

public func FfiConverterTypeGlobalContext_lower(_ value: GlobalContext) -> RustBuffer {
    return FfiConverterTypeGlobalContext.lower(value)
}


/**
 * Parameter object for `identity_issuance_request_json`.
 */
public struct IdentityIssuanceRequestParameters {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var arsInfos: [UInt32: AnonymityRevokerInfo]
    public var arThreshold: UInt8
    public var prfKey: Bytes
    public var idCredSec: Bytes
    public var blindingRandomness: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        ipInfo: IdentityProviderInfo, 
        globalContext: GlobalContext, 
        arsInfos: [UInt32: AnonymityRevokerInfo], 
        arThreshold: UInt8, 
        prfKey: Bytes, 
        idCredSec: Bytes, 
        blindingRandomness: Bytes) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.arsInfos = arsInfos
        self.arThreshold = arThreshold
        self.prfKey = prfKey
        self.idCredSec = idCredSec
        self.blindingRandomness = blindingRandomness
    }
}


extension IdentityIssuanceRequestParameters: Equatable, Hashable {
    public static func ==(lhs: IdentityIssuanceRequestParameters, rhs: IdentityIssuanceRequestParameters) -> Bool {
        if lhs.ipInfo != rhs.ipInfo {
            return false
        }
        if lhs.globalContext != rhs.globalContext {
            return false
        }
        if lhs.arsInfos != rhs.arsInfos {
            return false
        }
        if lhs.arThreshold != rhs.arThreshold {
            return false
        }
        if lhs.prfKey != rhs.prfKey {
            return false
        }
        if lhs.idCredSec != rhs.idCredSec {
            return false
        }
        if lhs.blindingRandomness != rhs.blindingRandomness {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ipInfo)
        hasher.combine(globalContext)
        hasher.combine(arsInfos)
        hasher.combine(arThreshold)
        hasher.combine(prfKey)
        hasher.combine(idCredSec)
        hasher.combine(blindingRandomness)
    }
}


public struct FfiConverterTypeIdentityIssuanceRequestParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityIssuanceRequestParameters {
        return
            try IdentityIssuanceRequestParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf), 
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf), 
                arsInfos: FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.read(from: &buf), 
                arThreshold: FfiConverterUInt8.read(from: &buf), 
                prfKey: FfiConverterTypeBytes.read(from: &buf), 
                idCredSec: FfiConverterTypeBytes.read(from: &buf), 
                blindingRandomness: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityIssuanceRequestParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo.write(value.arsInfos, into: &buf)
        FfiConverterUInt8.write(value.arThreshold, into: &buf)
        FfiConverterTypeBytes.write(value.prfKey, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSec, into: &buf)
        FfiConverterTypeBytes.write(value.blindingRandomness, into: &buf)
    }
}


public func FfiConverterTypeIdentityIssuanceRequestParameters_lift(_ buf: RustBuffer) throws -> IdentityIssuanceRequestParameters {
    return try FfiConverterTypeIdentityIssuanceRequestParameters.lift(buf)
}

public func FfiConverterTypeIdentityIssuanceRequestParameters_lower(_ value: IdentityIssuanceRequestParameters) -> RustBuffer {
    return FfiConverterTypeIdentityIssuanceRequestParameters.lower(value)
}


/**
 * The data we get back from the identity provider in the version 1 flow.
 */
public struct IdentityObject {
    public var preIdentityObject: PreIdentityObject
    /**
     * Chosen attribute list.
     */
    public var attributeList: AttributeList
    public var signature: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        preIdentityObject: PreIdentityObject, 
        /**
         * Chosen attribute list.
         */
        attributeList: AttributeList, 
        signature: Bytes) {
        self.preIdentityObject = preIdentityObject
        self.attributeList = attributeList
        self.signature = signature
    }
}


extension IdentityObject: Equatable, Hashable {
    public static func ==(lhs: IdentityObject, rhs: IdentityObject) -> Bool {
        if lhs.preIdentityObject != rhs.preIdentityObject {
            return false
        }
        if lhs.attributeList != rhs.attributeList {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preIdentityObject)
        hasher.combine(attributeList)
        hasher.combine(signature)
    }
}


public struct FfiConverterTypeIdentityObject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityObject {
        return
            try IdentityObject(
                preIdentityObject: FfiConverterTypePreIdentityObject.read(from: &buf), 
                attributeList: FfiConverterTypeAttributeList.read(from: &buf), 
                signature: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityObject, into buf: inout [UInt8]) {
        FfiConverterTypePreIdentityObject.write(value.preIdentityObject, into: &buf)
        FfiConverterTypeAttributeList.write(value.attributeList, into: &buf)
        FfiConverterTypeBytes.write(value.signature, into: &buf)
    }
}


public func FfiConverterTypeIdentityObject_lift(_ buf: RustBuffer) throws -> IdentityObject {
    return try FfiConverterTypeIdentityObject.lift(buf)
}

public func FfiConverterTypeIdentityObject_lower(_ value: IdentityObject) -> RustBuffer {
    return FfiConverterTypeIdentityObject.lower(value)
}


/**
 * A proof of a statement, composed of one or more atomic proofs.
 */
public struct IdentityProof {
    public var proofs: [AtomicIdentityProof]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        proofs: [AtomicIdentityProof]) {
        self.proofs = proofs
    }
}


extension IdentityProof: Equatable, Hashable {
    public static func ==(lhs: IdentityProof, rhs: IdentityProof) -> Bool {
        if lhs.proofs != rhs.proofs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(proofs)
    }
}


public struct FfiConverterTypeIdentityProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityProof {
        return
            try IdentityProof(
                proofs: FfiConverterSequenceTypeAtomicIdentityProof.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityProof, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAtomicIdentityProof.write(value.proofs, into: &buf)
    }
}


public func FfiConverterTypeIdentityProof_lift(_ buf: RustBuffer) throws -> IdentityProof {
    return try FfiConverterTypeIdentityProof.lift(buf)
}

public func FfiConverterTypeIdentityProof_lower(_ value: IdentityProof) -> RustBuffer {
    return FfiConverterTypeIdentityProof.lower(value)
}


/**
 * Public information about an identity provider.
 */
public struct IdentityProviderInfo {
    /**
     * Unique identifier of the identity provider.
     */
    public var identity: UInt32
    /**
     * Free form description, e.g., how to contact them off-chain.
     */
    public var description: Description
    /**
     * PS public key of the identity provider.
     */
    public var verifyKey: Bytes
    /**
     * Ed public key of the identity provider.
     */
    public var cdiVerifyKey: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier of the identity provider.
         */
        identity: UInt32, 
        /**
         * Free form description, e.g., how to contact them off-chain.
         */
        description: Description, 
        /**
         * PS public key of the identity provider.
         */
        verifyKey: Bytes, 
        /**
         * Ed public key of the identity provider.
         */
        cdiVerifyKey: Bytes) {
        self.identity = identity
        self.description = description
        self.verifyKey = verifyKey
        self.cdiVerifyKey = cdiVerifyKey
    }
}


extension IdentityProviderInfo: Equatable, Hashable {
    public static func ==(lhs: IdentityProviderInfo, rhs: IdentityProviderInfo) -> Bool {
        if lhs.identity != rhs.identity {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.verifyKey != rhs.verifyKey {
            return false
        }
        if lhs.cdiVerifyKey != rhs.cdiVerifyKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identity)
        hasher.combine(description)
        hasher.combine(verifyKey)
        hasher.combine(cdiVerifyKey)
    }
}


public struct FfiConverterTypeIdentityProviderInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityProviderInfo {
        return
            try IdentityProviderInfo(
                identity: FfiConverterUInt32.read(from: &buf), 
                description: FfiConverterTypeDescription.read(from: &buf), 
                verifyKey: FfiConverterTypeBytes.read(from: &buf), 
                cdiVerifyKey: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityProviderInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.identity, into: &buf)
        FfiConverterTypeDescription.write(value.description, into: &buf)
        FfiConverterTypeBytes.write(value.verifyKey, into: &buf)
        FfiConverterTypeBytes.write(value.cdiVerifyKey, into: &buf)
    }
}


public func FfiConverterTypeIdentityProviderInfo_lift(_ buf: RustBuffer) throws -> IdentityProviderInfo {
    return try FfiConverterTypeIdentityProviderInfo.lift(buf)
}

public func FfiConverterTypeIdentityProviderInfo_lower(_ value: IdentityProviderInfo) -> RustBuffer {
    return FfiConverterTypeIdentityProviderInfo.lower(value)
}


/**
 * Parameter object for `identity_recovery_request_json`.
 */
public struct IdentityRecoveryRequestParameters {
    public var ipInfo: IdentityProviderInfo
    public var globalContext: GlobalContext
    public var timestamp: UInt64
    public var idCredSec: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        ipInfo: IdentityProviderInfo, 
        globalContext: GlobalContext, 
        timestamp: UInt64, 
        idCredSec: Bytes) {
        self.ipInfo = ipInfo
        self.globalContext = globalContext
        self.timestamp = timestamp
        self.idCredSec = idCredSec
    }
}


extension IdentityRecoveryRequestParameters: Equatable, Hashable {
    public static func ==(lhs: IdentityRecoveryRequestParameters, rhs: IdentityRecoveryRequestParameters) -> Bool {
        if lhs.ipInfo != rhs.ipInfo {
            return false
        }
        if lhs.globalContext != rhs.globalContext {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.idCredSec != rhs.idCredSec {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ipInfo)
        hasher.combine(globalContext)
        hasher.combine(timestamp)
        hasher.combine(idCredSec)
    }
}


public struct FfiConverterTypeIdentityRecoveryRequestParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityRecoveryRequestParameters {
        return
            try IdentityRecoveryRequestParameters(
                ipInfo: FfiConverterTypeIdentityProviderInfo.read(from: &buf), 
                globalContext: FfiConverterTypeGlobalContext.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf), 
                idCredSec: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityRecoveryRequestParameters, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityProviderInfo.write(value.ipInfo, into: &buf)
        FfiConverterTypeGlobalContext.write(value.globalContext, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSec, into: &buf)
    }
}


public func FfiConverterTypeIdentityRecoveryRequestParameters_lift(_ buf: RustBuffer) throws -> IdentityRecoveryRequestParameters {
    return try FfiConverterTypeIdentityRecoveryRequestParameters.lift(buf)
}

public func FfiConverterTypeIdentityRecoveryRequestParameters_lower(_ value: IdentityRecoveryRequestParameters) -> RustBuffer {
    return FfiConverterTypeIdentityRecoveryRequestParameters.lower(value)
}


/**
 * A statement is a list of atomic statements.
 */
public struct IdentityStatement {
    public var statements: [AtomicIdentityStatement]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        statements: [AtomicIdentityStatement]) {
        self.statements = statements
    }
}


extension IdentityStatement: Equatable, Hashable {
    public static func ==(lhs: IdentityStatement, rhs: IdentityStatement) -> Bool {
        if lhs.statements != rhs.statements {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(statements)
    }
}


public struct FfiConverterTypeIdentityStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityStatement {
        return
            try IdentityStatement(
                statements: FfiConverterSequenceTypeAtomicIdentityStatement.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityStatement, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAtomicIdentityStatement.write(value.statements, into: &buf)
    }
}


public func FfiConverterTypeIdentityStatement_lift(_ buf: RustBuffer) throws -> IdentityStatement {
    return try FfiConverterTypeIdentityStatement.lift(buf)
}

public func FfiConverterTypeIdentityStatement_lower(_ value: IdentityStatement) -> RustBuffer {
    return FfiConverterTypeIdentityStatement.lower(value)
}


/**
 * An encrypted amount input to transfer from
 */
public struct InputEncryptedAmount {
    /**
     * The aggregated encrypted amount.
     */
    public var aggEncryptedAmount: Bytes
    /**
     * The plaintext corresponding to the aggregated encrypted amount.
     */
    public var aggAmount: UInt64
    /**
     * Index such that the `agg_amount` is the sum of all encrypted amounts on an account with indices strictly below `agg_index`.
     */
    public var aggIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The aggregated encrypted amount.
         */
        aggEncryptedAmount: Bytes, 
        /**
         * The plaintext corresponding to the aggregated encrypted amount.
         */
        aggAmount: UInt64, 
        /**
         * Index such that the `agg_amount` is the sum of all encrypted amounts on an account with indices strictly below `agg_index`.
         */
        aggIndex: UInt64) {
        self.aggEncryptedAmount = aggEncryptedAmount
        self.aggAmount = aggAmount
        self.aggIndex = aggIndex
    }
}


extension InputEncryptedAmount: Equatable, Hashable {
    public static func ==(lhs: InputEncryptedAmount, rhs: InputEncryptedAmount) -> Bool {
        if lhs.aggEncryptedAmount != rhs.aggEncryptedAmount {
            return false
        }
        if lhs.aggAmount != rhs.aggAmount {
            return false
        }
        if lhs.aggIndex != rhs.aggIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(aggEncryptedAmount)
        hasher.combine(aggAmount)
        hasher.combine(aggIndex)
    }
}


public struct FfiConverterTypeInputEncryptedAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InputEncryptedAmount {
        return
            try InputEncryptedAmount(
                aggEncryptedAmount: FfiConverterTypeBytes.read(from: &buf), 
                aggAmount: FfiConverterUInt64.read(from: &buf), 
                aggIndex: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: InputEncryptedAmount, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.aggEncryptedAmount, into: &buf)
        FfiConverterUInt64.write(value.aggAmount, into: &buf)
        FfiConverterUInt64.write(value.aggIndex, into: &buf)
    }
}


public func FfiConverterTypeInputEncryptedAmount_lift(_ buf: RustBuffer) throws -> InputEncryptedAmount {
    return try FfiConverterTypeInputEncryptedAmount.lift(buf)
}

public func FfiConverterTypeInputEncryptedAmount_lower(_ value: InputEncryptedAmount) -> RustBuffer {
    return FfiConverterTypeInputEncryptedAmount.lower(value)
}


/**
 * A proof that establishes that the owner of the credential has indeed created
 * the presentation. At present this is a list of signatures.
 */
public struct LinkingProof {
    public var created: Date
    public var proofValue: [Bytes]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        created: Date, 
        proofValue: [Bytes]) {
        self.created = created
        self.proofValue = proofValue
    }
}


extension LinkingProof: Equatable, Hashable {
    public static func ==(lhs: LinkingProof, rhs: LinkingProof) -> Bool {
        if lhs.created != rhs.created {
            return false
        }
        if lhs.proofValue != rhs.proofValue {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(created)
        hasher.combine(proofValue)
    }
}


public struct FfiConverterTypeLinkingProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkingProof {
        return
            try LinkingProof(
                created: FfiConverterTimestamp.read(from: &buf), 
                proofValue: FfiConverterSequenceTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: LinkingProof, into buf: inout [UInt8]) {
        FfiConverterTimestamp.write(value.created, into: &buf)
        FfiConverterSequenceTypeBytes.write(value.proofValue, into: &buf)
    }
}


public func FfiConverterTypeLinkingProof_lift(_ buf: RustBuffer) throws -> LinkingProof {
    return try FfiConverterTypeLinkingProof.lift(buf)
}

public func FfiConverterTypeLinkingProof_lower(_ value: LinkingProof) -> RustBuffer {
    return FfiConverterTypeLinkingProof.lower(value)
}


/**
 * Represents a contract module schema of a specific version.
 */
public struct ModuleSchema {
    /**
     * The module schema serialized as bytes.
     */
    public var value: Data
    /**
     * The module schema version. This is optional, as this can also be included in the serialized schema value.
     * If the version is neither present in the serialized schema, nor defined explicitly, an error will be returned upon use.
     */
    public var version: ModuleSchemaVersion?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The module schema serialized as bytes.
         */
        value: Data, 
        /**
         * The module schema version. This is optional, as this can also be included in the serialized schema value.
         * If the version is neither present in the serialized schema, nor defined explicitly, an error will be returned upon use.
         */
        version: ModuleSchemaVersion?) {
        self.value = value
        self.version = version
    }
}


extension ModuleSchema: Equatable, Hashable {
    public static func ==(lhs: ModuleSchema, rhs: ModuleSchema) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(version)
    }
}


public struct FfiConverterTypeModuleSchema: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModuleSchema {
        return
            try ModuleSchema(
                value: FfiConverterData.read(from: &buf), 
                version: FfiConverterOptionTypeModuleSchemaVersion.read(from: &buf)
        )
    }

    public static func write(_ value: ModuleSchema, into buf: inout [UInt8]) {
        FfiConverterData.write(value.value, into: &buf)
        FfiConverterOptionTypeModuleSchemaVersion.write(value.version, into: &buf)
    }
}


public func FfiConverterTypeModuleSchema_lift(_ buf: RustBuffer) throws -> ModuleSchema {
    return try FfiConverterTypeModuleSchema.lift(buf)
}

public func FfiConverterTypeModuleSchema_lower(_ value: ModuleSchema) -> RustBuffer {
    return FfiConverterTypeModuleSchema.lower(value)
}


/**
 * A policy is (currently) revealed values of attributes that are part of the identity object.
 * Policies are part of credentials.
 */
public struct Policy {
    public var createdAtYearMonth: String
    public var validToYearMonth: String
    public var revealedAttributes: [AttributeTag: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        createdAtYearMonth: String, 
        validToYearMonth: String, 
        revealedAttributes: [AttributeTag: String]) {
        self.createdAtYearMonth = createdAtYearMonth
        self.validToYearMonth = validToYearMonth
        self.revealedAttributes = revealedAttributes
    }
}


extension Policy: Equatable, Hashable {
    public static func ==(lhs: Policy, rhs: Policy) -> Bool {
        if lhs.createdAtYearMonth != rhs.createdAtYearMonth {
            return false
        }
        if lhs.validToYearMonth != rhs.validToYearMonth {
            return false
        }
        if lhs.revealedAttributes != rhs.revealedAttributes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdAtYearMonth)
        hasher.combine(validToYearMonth)
        hasher.combine(revealedAttributes)
    }
}


public struct FfiConverterTypePolicy: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Policy {
        return
            try Policy(
                createdAtYearMonth: FfiConverterString.read(from: &buf), 
                validToYearMonth: FfiConverterString.read(from: &buf), 
                revealedAttributes: FfiConverterDictionaryTypeAttributeTagString.read(from: &buf)
        )
    }

    public static func write(_ value: Policy, into buf: inout [UInt8]) {
        FfiConverterString.write(value.createdAtYearMonth, into: &buf)
        FfiConverterString.write(value.validToYearMonth, into: &buf)
        FfiConverterDictionaryTypeAttributeTagString.write(value.revealedAttributes, into: &buf)
    }
}


public func FfiConverterTypePolicy_lift(_ buf: RustBuffer) throws -> Policy {
    return try FfiConverterTypePolicy.lift(buf)
}

public func FfiConverterTypePolicy_lower(_ value: Policy) -> RustBuffer {
    return FfiConverterTypePolicy.lower(value)
}


/**
 * Information sent from the account holder to the identity provider.
 * This includes only the cryptographic parts; the attribute list is in a different object below.
 * This is for the flow where no initial account is involved.
 */
public struct PreIdentityObject {
    public var idCredPub: Bytes
    /**
     * Anonymity revocation data for the chosen anonymity revokers.
     */
    public var ipArData: [UInt32: ArData]
    /**
     * Choice of anonyimity revocation parameters.
     * Identity provider checks that the values make sense in the context of the public keys they are allowed to use.
     */
    public var choiceArData: ChoiceArParameters
    /**
     * Commitment to ID cred sec using the commitment key of the identity provider derived from the PS public key.
     * This is used to compute the message that the identity provider signs.
     */
    public var idCredSecCommitment: Bytes
    /**
     * Commitment to the PRF key in group G1.
     */
    public var prfKeyCommitmentWithIp: Bytes
    /**
     * Commitments to the coefficients of the polynomial used to share the PRF key.
     */
    public var prfKeySharingCoeffCommitments: [Bytes]
    /**
     * Proof that the data sent to the identity provider is well-formed.
     */
    public var proofsOfKnowledge: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        idCredPub: Bytes, 
        /**
         * Anonymity revocation data for the chosen anonymity revokers.
         */
        ipArData: [UInt32: ArData], 
        /**
         * Choice of anonyimity revocation parameters.
         * Identity provider checks that the values make sense in the context of the public keys they are allowed to use.
         */
        choiceArData: ChoiceArParameters, 
        /**
         * Commitment to ID cred sec using the commitment key of the identity provider derived from the PS public key.
         * This is used to compute the message that the identity provider signs.
         */
        idCredSecCommitment: Bytes, 
        /**
         * Commitment to the PRF key in group G1.
         */
        prfKeyCommitmentWithIp: Bytes, 
        /**
         * Commitments to the coefficients of the polynomial used to share the PRF key.
         */
        prfKeySharingCoeffCommitments: [Bytes], 
        /**
         * Proof that the data sent to the identity provider is well-formed.
         */
        proofsOfKnowledge: Bytes) {
        self.idCredPub = idCredPub
        self.ipArData = ipArData
        self.choiceArData = choiceArData
        self.idCredSecCommitment = idCredSecCommitment
        self.prfKeyCommitmentWithIp = prfKeyCommitmentWithIp
        self.prfKeySharingCoeffCommitments = prfKeySharingCoeffCommitments
        self.proofsOfKnowledge = proofsOfKnowledge
    }
}


extension PreIdentityObject: Equatable, Hashable {
    public static func ==(lhs: PreIdentityObject, rhs: PreIdentityObject) -> Bool {
        if lhs.idCredPub != rhs.idCredPub {
            return false
        }
        if lhs.ipArData != rhs.ipArData {
            return false
        }
        if lhs.choiceArData != rhs.choiceArData {
            return false
        }
        if lhs.idCredSecCommitment != rhs.idCredSecCommitment {
            return false
        }
        if lhs.prfKeyCommitmentWithIp != rhs.prfKeyCommitmentWithIp {
            return false
        }
        if lhs.prfKeySharingCoeffCommitments != rhs.prfKeySharingCoeffCommitments {
            return false
        }
        if lhs.proofsOfKnowledge != rhs.proofsOfKnowledge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(idCredPub)
        hasher.combine(ipArData)
        hasher.combine(choiceArData)
        hasher.combine(idCredSecCommitment)
        hasher.combine(prfKeyCommitmentWithIp)
        hasher.combine(prfKeySharingCoeffCommitments)
        hasher.combine(proofsOfKnowledge)
    }
}


public struct FfiConverterTypePreIdentityObject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreIdentityObject {
        return
            try PreIdentityObject(
                idCredPub: FfiConverterTypeBytes.read(from: &buf), 
                ipArData: FfiConverterDictionaryUInt32TypeArData.read(from: &buf), 
                choiceArData: FfiConverterTypeChoiceArParameters.read(from: &buf), 
                idCredSecCommitment: FfiConverterTypeBytes.read(from: &buf), 
                prfKeyCommitmentWithIp: FfiConverterTypeBytes.read(from: &buf), 
                prfKeySharingCoeffCommitments: FfiConverterSequenceTypeBytes.read(from: &buf), 
                proofsOfKnowledge: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: PreIdentityObject, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.idCredPub, into: &buf)
        FfiConverterDictionaryUInt32TypeArData.write(value.ipArData, into: &buf)
        FfiConverterTypeChoiceArParameters.write(value.choiceArData, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSecCommitment, into: &buf)
        FfiConverterTypeBytes.write(value.prfKeyCommitmentWithIp, into: &buf)
        FfiConverterSequenceTypeBytes.write(value.prfKeySharingCoeffCommitments, into: &buf)
        FfiConverterTypeBytes.write(value.proofsOfKnowledge, into: &buf)
    }
}


public func FfiConverterTypePreIdentityObject_lift(_ buf: RustBuffer) throws -> PreIdentityObject {
    return try FfiConverterTypePreIdentityObject.lift(buf)
}

public func FfiConverterTypePreIdentityObject_lower(_ value: PreIdentityObject) -> RustBuffer {
    return FfiConverterTypePreIdentityObject.lower(value)
}


/**
 * All proofs required to prove ownership of an identity in a credential deployment.
 */
public struct Proofs {
    /**
     * Challenge used for all of the proofs.
     */
    public var challenge: Bytes
    /**
     * List of commitments to the attributes.
     */
    public var commitments: Bytes
    /**
     * Proof that credential counter is at most equal to the maximum allowed number of account.
     */
    public var credCounterLessThanMaxAccounts: Bytes
    /**
     * Responses in the proof that the computed commitment to the share
     * contains the same value as the encryption.
     * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
     */
    public var proofIdCredPub: [String: Bytes]
    /**
     * Responses in the proof of knowledge of signature of the identity provider.
     */
    public var proofIpSig: Bytes
    /**
     * Proof that registration ID is valid and computed from the PRF key signed by the identity provider.
     */
    public var proofRegId: Bytes
    /**
     * (Blinded) signature derived from the signature on the pre-identity object by the identity provider.
     */
    public var signature: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Challenge used for all of the proofs.
         */
        challenge: Bytes, 
        /**
         * List of commitments to the attributes.
         */
        commitments: Bytes, 
        /**
         * Proof that credential counter is at most equal to the maximum allowed number of account.
         */
        credCounterLessThanMaxAccounts: Bytes, 
        /**
         * Responses in the proof that the computed commitment to the share
         * contains the same value as the encryption.
         * The commitment to the share is not sent but computed from the commitments to the sharing coefficients.
         */
        proofIdCredPub: [String: Bytes], 
        /**
         * Responses in the proof of knowledge of signature of the identity provider.
         */
        proofIpSig: Bytes, 
        /**
         * Proof that registration ID is valid and computed from the PRF key signed by the identity provider.
         */
        proofRegId: Bytes, 
        /**
         * (Blinded) signature derived from the signature on the pre-identity object by the identity provider.
         */
        signature: Bytes) {
        self.challenge = challenge
        self.commitments = commitments
        self.credCounterLessThanMaxAccounts = credCounterLessThanMaxAccounts
        self.proofIdCredPub = proofIdCredPub
        self.proofIpSig = proofIpSig
        self.proofRegId = proofRegId
        self.signature = signature
    }
}


extension Proofs: Equatable, Hashable {
    public static func ==(lhs: Proofs, rhs: Proofs) -> Bool {
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.commitments != rhs.commitments {
            return false
        }
        if lhs.credCounterLessThanMaxAccounts != rhs.credCounterLessThanMaxAccounts {
            return false
        }
        if lhs.proofIdCredPub != rhs.proofIdCredPub {
            return false
        }
        if lhs.proofIpSig != rhs.proofIpSig {
            return false
        }
        if lhs.proofRegId != rhs.proofRegId {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challenge)
        hasher.combine(commitments)
        hasher.combine(credCounterLessThanMaxAccounts)
        hasher.combine(proofIdCredPub)
        hasher.combine(proofIpSig)
        hasher.combine(proofRegId)
        hasher.combine(signature)
    }
}


public struct FfiConverterTypeProofs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Proofs {
        return
            try Proofs(
                challenge: FfiConverterTypeBytes.read(from: &buf), 
                commitments: FfiConverterTypeBytes.read(from: &buf), 
                credCounterLessThanMaxAccounts: FfiConverterTypeBytes.read(from: &buf), 
                proofIdCredPub: FfiConverterDictionaryStringTypeBytes.read(from: &buf), 
                proofIpSig: FfiConverterTypeBytes.read(from: &buf), 
                proofRegId: FfiConverterTypeBytes.read(from: &buf), 
                signature: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Proofs, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.challenge, into: &buf)
        FfiConverterTypeBytes.write(value.commitments, into: &buf)
        FfiConverterTypeBytes.write(value.credCounterLessThanMaxAccounts, into: &buf)
        FfiConverterDictionaryStringTypeBytes.write(value.proofIdCredPub, into: &buf)
        FfiConverterTypeBytes.write(value.proofIpSig, into: &buf)
        FfiConverterTypeBytes.write(value.proofRegId, into: &buf)
        FfiConverterTypeBytes.write(value.signature, into: &buf)
    }
}


public func FfiConverterTypeProofs_lift(_ buf: RustBuffer) throws -> Proofs {
    return try FfiConverterTypeProofs.lift(buf)
}

public func FfiConverterTypeProofs_lower(_ value: Proofs) -> RustBuffer {
    return FfiConverterTypeProofs.lower(value)
}


/**
 * Randomness that is generated to commit to attributes when creating a credential.
 * This randomness is needed to do something with those commitments later,
 * for example reveal the committed value or prove a property of the value.
 */
public struct Randomness {
    /**
     * Randomness used to commit to any user-chosen attributes, such as country of nationality.
     */
    public var attributesRand: [AttributeTag: Bytes]
    /**
     * Randomness of the commitment to the credential nonce.
     * This nonce is the number that is used to ensure that only a limited number of credentials
     * can be created from a given identity object.
     */
    public var credCounterRand: Bytes
    /**
     * Randomness of the commitment to idCredSec.
     */
    public var idCredSecRand: Bytes
    /**
     * Randomness of the commitment to the maximum number of accounts that may be created from the identity object.
     */
    public var maxAccountsRand: Bytes
    /**
     * Randomness of the commitment to the PRF key.
     */
    public var prfRand: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Randomness used to commit to any user-chosen attributes, such as country of nationality.
         */
        attributesRand: [AttributeTag: Bytes], 
        /**
         * Randomness of the commitment to the credential nonce.
         * This nonce is the number that is used to ensure that only a limited number of credentials
         * can be created from a given identity object.
         */
        credCounterRand: Bytes, 
        /**
         * Randomness of the commitment to idCredSec.
         */
        idCredSecRand: Bytes, 
        /**
         * Randomness of the commitment to the maximum number of accounts that may be created from the identity object.
         */
        maxAccountsRand: Bytes, 
        /**
         * Randomness of the commitment to the PRF key.
         */
        prfRand: Bytes) {
        self.attributesRand = attributesRand
        self.credCounterRand = credCounterRand
        self.idCredSecRand = idCredSecRand
        self.maxAccountsRand = maxAccountsRand
        self.prfRand = prfRand
    }
}


extension Randomness: Equatable, Hashable {
    public static func ==(lhs: Randomness, rhs: Randomness) -> Bool {
        if lhs.attributesRand != rhs.attributesRand {
            return false
        }
        if lhs.credCounterRand != rhs.credCounterRand {
            return false
        }
        if lhs.idCredSecRand != rhs.idCredSecRand {
            return false
        }
        if lhs.maxAccountsRand != rhs.maxAccountsRand {
            return false
        }
        if lhs.prfRand != rhs.prfRand {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributesRand)
        hasher.combine(credCounterRand)
        hasher.combine(idCredSecRand)
        hasher.combine(maxAccountsRand)
        hasher.combine(prfRand)
    }
}


public struct FfiConverterTypeRandomness: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Randomness {
        return
            try Randomness(
                attributesRand: FfiConverterDictionaryTypeAttributeTagTypeBytes.read(from: &buf), 
                credCounterRand: FfiConverterTypeBytes.read(from: &buf), 
                idCredSecRand: FfiConverterTypeBytes.read(from: &buf), 
                maxAccountsRand: FfiConverterTypeBytes.read(from: &buf), 
                prfRand: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Randomness, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeAttributeTagTypeBytes.write(value.attributesRand, into: &buf)
        FfiConverterTypeBytes.write(value.credCounterRand, into: &buf)
        FfiConverterTypeBytes.write(value.idCredSecRand, into: &buf)
        FfiConverterTypeBytes.write(value.maxAccountsRand, into: &buf)
        FfiConverterTypeBytes.write(value.prfRand, into: &buf)
    }
}


public func FfiConverterTypeRandomness_lift(_ buf: RustBuffer) throws -> Randomness {
    return try FfiConverterTypeRandomness.lift(buf)
}

public func FfiConverterTypeRandomness_lower(_ value: Randomness) -> RustBuffer {
    return FfiConverterTypeRandomness.lower(value)
}


/**
 * For the case where the verifier wants the user to show the value of an
 * attribute and prove that it is indeed the value inside the on-chain
 * commitment. Since the verifier does not know the attribute value before
 * seeing the proof, the value is not present here.
 */
public struct RevealAttributeIdentityStatement {
    /**
     * The attribute that the verifier wants the user to reveal.
     */
    public var attributeTag: AttributeTag

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to reveal.
         */
        attributeTag: AttributeTag) {
        self.attributeTag = attributeTag
    }
}


extension RevealAttributeIdentityStatement: Equatable, Hashable {
    public static func ==(lhs: RevealAttributeIdentityStatement, rhs: RevealAttributeIdentityStatement) -> Bool {
        if lhs.attributeTag != rhs.attributeTag {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributeTag)
    }
}


public struct FfiConverterTypeRevealAttributeIdentityStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RevealAttributeIdentityStatement {
        return
            try RevealAttributeIdentityStatement(
                attributeTag: FfiConverterTypeAttributeTag.read(from: &buf)
        )
    }

    public static func write(_ value: RevealAttributeIdentityStatement, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeTag.write(value.attributeTag, into: &buf)
    }
}


public func FfiConverterTypeRevealAttributeIdentityStatement_lift(_ buf: RustBuffer) throws -> RevealAttributeIdentityStatement {
    return try FfiConverterTypeRevealAttributeIdentityStatement.lift(buf)
}

public func FfiConverterTypeRevealAttributeIdentityStatement_lower(_ value: RevealAttributeIdentityStatement) -> RustBuffer {
    return FfiConverterTypeRevealAttributeIdentityStatement.lower(value)
}


/**
 * For the case where the verifier wants the user to show the value of an
 * attribute and prove that it is indeed the value inside the on-chain
 * commitment. Since the verifier does not know the attribute value before
 * seeing the proof, the value is not present here.
 */
public struct RevealAttributeWeb3IdStatement {
    /**
     * The attribute that the verifier wants the user to reveal.
     */
    public var attributeTag: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The attribute that the verifier wants the user to reveal.
         */
        attributeTag: String) {
        self.attributeTag = attributeTag
    }
}


extension RevealAttributeWeb3IdStatement: Equatable, Hashable {
    public static func ==(lhs: RevealAttributeWeb3IdStatement, rhs: RevealAttributeWeb3IdStatement) -> Bool {
        if lhs.attributeTag != rhs.attributeTag {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributeTag)
    }
}


public struct FfiConverterTypeRevealAttributeWeb3IdStatement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RevealAttributeWeb3IdStatement {
        return
            try RevealAttributeWeb3IdStatement(
                attributeTag: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RevealAttributeWeb3IdStatement, into buf: inout [UInt8]) {
        FfiConverterString.write(value.attributeTag, into: &buf)
    }
}


public func FfiConverterTypeRevealAttributeWeb3IdStatement_lift(_ buf: RustBuffer) throws -> RevealAttributeWeb3IdStatement {
    return try FfiConverterTypeRevealAttributeWeb3IdStatement.lift(buf)
}

public func FfiConverterTypeRevealAttributeWeb3IdStatement_lower(_ value: RevealAttributeWeb3IdStatement) -> RustBuffer {
    return FfiConverterTypeRevealAttributeWeb3IdStatement.lower(value)
}


/**
 * The payload data for a TransferToPublic transaction
 */
public struct SecToPubTransferData {
    /**
     * The serialized remaining amount after deducting the amount to transfer
     * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::EncryptedAmount`]
     */
    public var remainingAmount: Bytes
    /**
     * The amount to transfer in microCCD.
     */
    public var transferAmount: MicroCCDAmount
    /**
     * The transfer index of the transfer
     */
    public var index: UInt64
    /**
     * The serialized proof that the transfer is correct.
     * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::SecToPubAmountTransferProof`]
     */
    public var proof: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The serialized remaining amount after deducting the amount to transfer
         * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::EncryptedAmount`]
         */
        remainingAmount: Bytes, 
        /**
         * The amount to transfer in microCCD.
         */
        transferAmount: MicroCCDAmount, 
        /**
         * The transfer index of the transfer
         */
        index: UInt64, 
        /**
         * The serialized proof that the transfer is correct.
         * Serialized according to the [`Serial`] implementation of [`concordium_base::encrypted_transfers::types::SecToPubAmountTransferProof`]
         */
        proof: Bytes) {
        self.remainingAmount = remainingAmount
        self.transferAmount = transferAmount
        self.index = index
        self.proof = proof
    }
}


extension SecToPubTransferData: Equatable, Hashable {
    public static func ==(lhs: SecToPubTransferData, rhs: SecToPubTransferData) -> Bool {
        if lhs.remainingAmount != rhs.remainingAmount {
            return false
        }
        if lhs.transferAmount != rhs.transferAmount {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(remainingAmount)
        hasher.combine(transferAmount)
        hasher.combine(index)
        hasher.combine(proof)
    }
}


public struct FfiConverterTypeSecToPubTransferData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecToPubTransferData {
        return
            try SecToPubTransferData(
                remainingAmount: FfiConverterTypeBytes.read(from: &buf), 
                transferAmount: FfiConverterTypeMicroCCDAmount.read(from: &buf), 
                index: FfiConverterUInt64.read(from: &buf), 
                proof: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: SecToPubTransferData, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.remainingAmount, into: &buf)
        FfiConverterTypeMicroCCDAmount.write(value.transferAmount, into: &buf)
        FfiConverterUInt64.write(value.index, into: &buf)
        FfiConverterTypeBytes.write(value.proof, into: &buf)
    }
}


public func FfiConverterTypeSecToPubTransferData_lift(_ buf: RustBuffer) throws -> SecToPubTransferData {
    return try FfiConverterTypeSecToPubTransferData.lift(buf)
}

public func FfiConverterTypeSecToPubTransferData_lower(_ value: SecToPubTransferData) -> RustBuffer {
    return FfiConverterTypeSecToPubTransferData.lower(value)
}


public struct SecToPubTransferDataDeserializeResult {
    public var value: SecToPubTransferData
    public var bytesRead: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        value: SecToPubTransferData, 
        bytesRead: UInt64) {
        self.value = value
        self.bytesRead = bytesRead
    }
}


extension SecToPubTransferDataDeserializeResult: Equatable, Hashable {
    public static func ==(lhs: SecToPubTransferDataDeserializeResult, rhs: SecToPubTransferDataDeserializeResult) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.bytesRead != rhs.bytesRead {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(bytesRead)
    }
}


public struct FfiConverterTypeSecToPubTransferDataDeserializeResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecToPubTransferDataDeserializeResult {
        return
            try SecToPubTransferDataDeserializeResult(
                value: FfiConverterTypeSecToPubTransferData.read(from: &buf), 
                bytesRead: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SecToPubTransferDataDeserializeResult, into buf: inout [UInt8]) {
        FfiConverterTypeSecToPubTransferData.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.bytesRead, into: &buf)
    }
}


public func FfiConverterTypeSecToPubTransferDataDeserializeResult_lift(_ buf: RustBuffer) throws -> SecToPubTransferDataDeserializeResult {
    return try FfiConverterTypeSecToPubTransferDataDeserializeResult.lift(buf)
}

public func FfiConverterTypeSecToPubTransferDataDeserializeResult_lower(_ value: SecToPubTransferDataDeserializeResult) -> RustBuffer {
    return FfiConverterTypeSecToPubTransferDataDeserializeResult.lower(value)
}


/**
 * The credential deployment context required to serialize a credential deployment for submission to the chain.
 */
public struct SignedAccountCredential {
    public var credential: AccountCredential
    public var signatures: [UInt8: Bytes]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        credential: AccountCredential, 
        signatures: [UInt8: Bytes]) {
        self.credential = credential
        self.signatures = signatures
    }
}


extension SignedAccountCredential: Equatable, Hashable {
    public static func ==(lhs: SignedAccountCredential, rhs: SignedAccountCredential) -> Bool {
        if lhs.credential != rhs.credential {
            return false
        }
        if lhs.signatures != rhs.signatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(credential)
        hasher.combine(signatures)
    }
}


public struct FfiConverterTypeSignedAccountCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedAccountCredential {
        return
            try SignedAccountCredential(
                credential: FfiConverterTypeAccountCredential.read(from: &buf), 
                signatures: FfiConverterDictionaryUInt8TypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: SignedAccountCredential, into buf: inout [UInt8]) {
        FfiConverterTypeAccountCredential.write(value.credential, into: &buf)
        FfiConverterDictionaryUInt8TypeBytes.write(value.signatures, into: &buf)
    }
}


public func FfiConverterTypeSignedAccountCredential_lift(_ buf: RustBuffer) throws -> SignedAccountCredential {
    return try FfiConverterTypeSignedAccountCredential.lift(buf)
}

public func FfiConverterTypeSignedAccountCredential_lower(_ value: SignedAccountCredential) -> RustBuffer {
    return FfiConverterTypeSignedAccountCredential.lower(value)
}


/**
 * Commitments signed by the issuer.
 */
public struct SignedCommitments {
    public var signature: Bytes
    public var commitments: [String: Bytes]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        signature: Bytes, 
        commitments: [String: Bytes]) {
        self.signature = signature
        self.commitments = commitments
    }
}


extension SignedCommitments: Equatable, Hashable {
    public static func ==(lhs: SignedCommitments, rhs: SignedCommitments) -> Bool {
        if lhs.signature != rhs.signature {
            return false
        }
        if lhs.commitments != rhs.commitments {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signature)
        hasher.combine(commitments)
    }
}


public struct FfiConverterTypeSignedCommitments: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedCommitments {
        return
            try SignedCommitments(
                signature: FfiConverterTypeBytes.read(from: &buf), 
                commitments: FfiConverterDictionaryStringTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: SignedCommitments, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.signature, into: &buf)
        FfiConverterDictionaryStringTypeBytes.write(value.commitments, into: &buf)
    }
}


public func FfiConverterTypeSignedCommitments_lift(_ buf: RustBuffer) throws -> SignedCommitments {
    return try FfiConverterTypeSignedCommitments.lift(buf)
}

public func FfiConverterTypeSignedCommitments_lower(_ value: SignedCommitments) -> RustBuffer {
    return FfiConverterTypeSignedCommitments.lower(value)
}


/**
 * Represents a schema for a specific type used in a contract.
 */
public struct TypeSchema {
    /**
     * The type schema serialized as bytes.
     */
    public var value: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The type schema serialized as bytes.
         */
        value: Data) {
        self.value = value
    }
}


extension TypeSchema: Equatable, Hashable {
    public static func ==(lhs: TypeSchema, rhs: TypeSchema) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


public struct FfiConverterTypeTypeSchema: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypeSchema {
        return
            try TypeSchema(
                value: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: TypeSchema, into buf: inout [UInt8]) {
        FfiConverterData.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeTypeSchema_lift(_ buf: RustBuffer) throws -> TypeSchema {
    return try FfiConverterTypeTypeSchema.lift(buf)
}

public func FfiConverterTypeTypeSchema_lower(_ value: TypeSchema) -> RustBuffer {
    return FfiConverterTypeTypeSchema.lower(value)
}


public struct UpdateCredentialsPayload {
    /**
     * Credential infos and the respective indices to insert them at
     */
    public var newCredInfos: [UInt8: CredentialDeploymentInfo]
    /**
     * List of credentials to remove
     */
    public var removeCredIds: [Bytes]
    /**
     * The new threshold of the account
     */
    public var newThreshold: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Credential infos and the respective indices to insert them at
         */
        newCredInfos: [UInt8: CredentialDeploymentInfo], 
        /**
         * List of credentials to remove
         */
        removeCredIds: [Bytes], 
        /**
         * The new threshold of the account
         */
        newThreshold: UInt8) {
        self.newCredInfos = newCredInfos
        self.removeCredIds = removeCredIds
        self.newThreshold = newThreshold
    }
}


extension UpdateCredentialsPayload: Equatable, Hashable {
    public static func ==(lhs: UpdateCredentialsPayload, rhs: UpdateCredentialsPayload) -> Bool {
        if lhs.newCredInfos != rhs.newCredInfos {
            return false
        }
        if lhs.removeCredIds != rhs.removeCredIds {
            return false
        }
        if lhs.newThreshold != rhs.newThreshold {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(newCredInfos)
        hasher.combine(removeCredIds)
        hasher.combine(newThreshold)
    }
}


public struct FfiConverterTypeUpdateCredentialsPayload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateCredentialsPayload {
        return
            try UpdateCredentialsPayload(
                newCredInfos: FfiConverterDictionaryUInt8TypeCredentialDeploymentInfo.read(from: &buf), 
                removeCredIds: FfiConverterSequenceTypeBytes.read(from: &buf), 
                newThreshold: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateCredentialsPayload, into buf: inout [UInt8]) {
        FfiConverterDictionaryUInt8TypeCredentialDeploymentInfo.write(value.newCredInfos, into: &buf)
        FfiConverterSequenceTypeBytes.write(value.removeCredIds, into: &buf)
        FfiConverterUInt8.write(value.newThreshold, into: &buf)
    }
}


public func FfiConverterTypeUpdateCredentialsPayload_lift(_ buf: RustBuffer) throws -> UpdateCredentialsPayload {
    return try FfiConverterTypeUpdateCredentialsPayload.lift(buf)
}

public func FfiConverterTypeUpdateCredentialsPayload_lower(_ value: UpdateCredentialsPayload) -> RustBuffer {
    return FfiConverterTypeUpdateCredentialsPayload.lower(value)
}


public struct UpdateCredentialsPayloadDeserializeResult {
    public var value: UpdateCredentialsPayload
    public var bytesRead: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        value: UpdateCredentialsPayload, 
        bytesRead: UInt64) {
        self.value = value
        self.bytesRead = bytesRead
    }
}


extension UpdateCredentialsPayloadDeserializeResult: Equatable, Hashable {
    public static func ==(lhs: UpdateCredentialsPayloadDeserializeResult, rhs: UpdateCredentialsPayloadDeserializeResult) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.bytesRead != rhs.bytesRead {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(bytesRead)
    }
}


public struct FfiConverterTypeUpdateCredentialsPayloadDeserializeResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateCredentialsPayloadDeserializeResult {
        return
            try UpdateCredentialsPayloadDeserializeResult(
                value: FfiConverterTypeUpdateCredentialsPayload.read(from: &buf), 
                bytesRead: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateCredentialsPayloadDeserializeResult, into buf: inout [UInt8]) {
        FfiConverterTypeUpdateCredentialsPayload.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.bytesRead, into: &buf)
    }
}


public func FfiConverterTypeUpdateCredentialsPayloadDeserializeResult_lift(_ buf: RustBuffer) throws -> UpdateCredentialsPayloadDeserializeResult {
    return try FfiConverterTypeUpdateCredentialsPayloadDeserializeResult.lift(buf)
}

public func FfiConverterTypeUpdateCredentialsPayloadDeserializeResult_lower(_ value: UpdateCredentialsPayloadDeserializeResult) -> RustBuffer {
    return FfiConverterTypeUpdateCredentialsPayloadDeserializeResult.lower(value)
}


/**
 * A presentation is the response to a `VerifiableCredentialRequest`. It contains proofs for
 * statements, ownership proof for all Web3 credentials, and a context. The
 * only missing part to verify the proof are the public commitments.
 */
public struct VerifiablePresentation {
    public var presentationContext: Bytes
    public var verifiableCredential: [VerifiableCredentialProof]
    /**
     * Signatures from keys of Web3 credentials (not from ID credentials).
     * The order is the same as that in the `credential_proofs` field.
     */
    public var linkingProof: LinkingProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        presentationContext: Bytes, 
        verifiableCredential: [VerifiableCredentialProof], 
        /**
         * Signatures from keys of Web3 credentials (not from ID credentials).
         * The order is the same as that in the `credential_proofs` field.
         */
        linkingProof: LinkingProof) {
        self.presentationContext = presentationContext
        self.verifiableCredential = verifiableCredential
        self.linkingProof = linkingProof
    }
}


extension VerifiablePresentation: Equatable, Hashable {
    public static func ==(lhs: VerifiablePresentation, rhs: VerifiablePresentation) -> Bool {
        if lhs.presentationContext != rhs.presentationContext {
            return false
        }
        if lhs.verifiableCredential != rhs.verifiableCredential {
            return false
        }
        if lhs.linkingProof != rhs.linkingProof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(presentationContext)
        hasher.combine(verifiableCredential)
        hasher.combine(linkingProof)
    }
}


public struct FfiConverterTypeVerifiablePresentation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiablePresentation {
        return
            try VerifiablePresentation(
                presentationContext: FfiConverterTypeBytes.read(from: &buf), 
                verifiableCredential: FfiConverterSequenceTypeVerifiableCredentialProof.read(from: &buf), 
                linkingProof: FfiConverterTypeLinkingProof.read(from: &buf)
        )
    }

    public static func write(_ value: VerifiablePresentation, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.presentationContext, into: &buf)
        FfiConverterSequenceTypeVerifiableCredentialProof.write(value.verifiableCredential, into: &buf)
        FfiConverterTypeLinkingProof.write(value.linkingProof, into: &buf)
    }
}


public func FfiConverterTypeVerifiablePresentation_lift(_ buf: RustBuffer) throws -> VerifiablePresentation {
    return try FfiConverterTypeVerifiablePresentation.lift(buf)
}

public func FfiConverterTypeVerifiablePresentation_lower(_ value: VerifiablePresentation) -> RustBuffer {
    return FfiConverterTypeVerifiablePresentation.lower(value)
}


/**
 * A request for a proof. This is the statement and challenge. The secret data
 * comes separately.
 */
public struct VerifiablePresentationRequest {
    public var challenge: Bytes
    public var statements: [VerifiableCredentialStatement]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        challenge: Bytes, 
        statements: [VerifiableCredentialStatement]) {
        self.challenge = challenge
        self.statements = statements
    }
}


extension VerifiablePresentationRequest: Equatable, Hashable {
    public static func ==(lhs: VerifiablePresentationRequest, rhs: VerifiablePresentationRequest) -> Bool {
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.statements != rhs.statements {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challenge)
        hasher.combine(statements)
    }
}


public struct FfiConverterTypeVerifiablePresentationRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiablePresentationRequest {
        return
            try VerifiablePresentationRequest(
                challenge: FfiConverterTypeBytes.read(from: &buf), 
                statements: FfiConverterSequenceTypeVerifiableCredentialStatement.read(from: &buf)
        )
    }

    public static func write(_ value: VerifiablePresentationRequest, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.challenge, into: &buf)
        FfiConverterSequenceTypeVerifiableCredentialStatement.write(value.statements, into: &buf)
    }
}


public func FfiConverterTypeVerifiablePresentationRequest_lift(_ buf: RustBuffer) throws -> VerifiablePresentationRequest {
    return try FfiConverterTypeVerifiablePresentationRequest.lift(buf)
}

public func FfiConverterTypeVerifiablePresentationRequest_lower(_ value: VerifiablePresentationRequest) -> RustBuffer {
    return FfiConverterTypeVerifiablePresentationRequest.lower(value)
}


/**
 * Public AKA verification key for a given scheme.
 * Currently the only supported value of `scheme_id` is "Ed25519".
 */
public struct VerifyKey {
    public var schemeId: String
    public var key: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        schemeId: String, 
        key: Bytes) {
        self.schemeId = schemeId
        self.key = key
    }
}


extension VerifyKey: Equatable, Hashable {
    public static func ==(lhs: VerifyKey, rhs: VerifyKey) -> Bool {
        if lhs.schemeId != rhs.schemeId {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(schemeId)
        hasher.combine(key)
    }
}


public struct FfiConverterTypeVerifyKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifyKey {
        return
            try VerifyKey(
                schemeId: FfiConverterString.read(from: &buf), 
                key: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: VerifyKey, into buf: inout [UInt8]) {
        FfiConverterString.write(value.schemeId, into: &buf)
        FfiConverterTypeBytes.write(value.key, into: &buf)
    }
}


public func FfiConverterTypeVerifyKey_lift(_ buf: RustBuffer) throws -> VerifyKey {
    return try FfiConverterTypeVerifyKey.lift(buf)
}

public func FfiConverterTypeVerifyKey_lower(_ value: VerifyKey) -> RustBuffer {
    return FfiConverterTypeVerifyKey.lower(value)
}


/**
 * A versioned variant of `IdentityProof`
 */
public struct VersionedIdentityProof {
    /**
     * The version associated with the value
     */
    public var version: UInt32
    /**
     * The proof
     */
    public var value: IdentityProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The version associated with the value
         */
        version: UInt32, 
        /**
         * The proof
         */
        value: IdentityProof) {
        self.version = version
        self.value = value
    }
}


extension VersionedIdentityProof: Equatable, Hashable {
    public static func ==(lhs: VersionedIdentityProof, rhs: VersionedIdentityProof) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(value)
    }
}


public struct FfiConverterTypeVersionedIdentityProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VersionedIdentityProof {
        return
            try VersionedIdentityProof(
                version: FfiConverterUInt32.read(from: &buf), 
                value: FfiConverterTypeIdentityProof.read(from: &buf)
        )
    }

    public static func write(_ value: VersionedIdentityProof, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.version, into: &buf)
        FfiConverterTypeIdentityProof.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeVersionedIdentityProof_lift(_ buf: RustBuffer) throws -> VersionedIdentityProof {
    return try FfiConverterTypeVersionedIdentityProof.lift(buf)
}

public func FfiConverterTypeVersionedIdentityProof_lower(_ value: VersionedIdentityProof) -> RustBuffer {
    return FfiConverterTypeVersionedIdentityProof.lower(value)
}


/**
 * A full verifiable credential for Web3 ID credentials, including secrets.
 */
public struct Web3IdCredential {
    /**
     * The credential holder's public key.
     */
    public var holderId: Bytes
    /**
     * The network to which the credential applies.
     */
    public var network: Network
    /**
     * The address of the credential registry where the credential is tracked.
     */
    public var registry: ContractAddress
    /**
     * Credential type describing what kind of a credential it is.
     */
    public var credentialType: [String]
    /**
     * Link to the credential schema.
     */
    public var credentialSchema: String
    /**
     * The issuer's public key.
     */
    public var issuerKey: Bytes
    /**
     * Start of the validity of the credential.
     */
    public var validFrom: Date
    /**
     * After this date, the credential becomes expired. `None` corresponds to a
     * credential that cannot expire.
     */
    public var validUntil: Date?
    /**
     * The values of different attributes, indexed by attribute tags.
     */
    public var values: [String: Web3IdAttribute]
    /**
     * The randomness to go along with commitments in `values`. This has to
     * have the same keys as the `values` field, but it is more
     * convenient if it is a separate map itself.
     */
    public var randomness: [String: Bytes]
    /**
     * The signature on the holder's public key, the contract address of the
     * issuer, and the commitments from the issuer.
     */
    public var signature: Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The credential holder's public key.
         */
        holderId: Bytes, 
        /**
         * The network to which the credential applies.
         */
        network: Network, 
        /**
         * The address of the credential registry where the credential is tracked.
         */
        registry: ContractAddress, 
        /**
         * Credential type describing what kind of a credential it is.
         */
        credentialType: [String], 
        /**
         * Link to the credential schema.
         */
        credentialSchema: String, 
        /**
         * The issuer's public key.
         */
        issuerKey: Bytes, 
        /**
         * Start of the validity of the credential.
         */
        validFrom: Date, 
        /**
         * After this date, the credential becomes expired. `None` corresponds to a
         * credential that cannot expire.
         */
        validUntil: Date?, 
        /**
         * The values of different attributes, indexed by attribute tags.
         */
        values: [String: Web3IdAttribute], 
        /**
         * The randomness to go along with commitments in `values`. This has to
         * have the same keys as the `values` field, but it is more
         * convenient if it is a separate map itself.
         */
        randomness: [String: Bytes], 
        /**
         * The signature on the holder's public key, the contract address of the
         * issuer, and the commitments from the issuer.
         */
        signature: Bytes) {
        self.holderId = holderId
        self.network = network
        self.registry = registry
        self.credentialType = credentialType
        self.credentialSchema = credentialSchema
        self.issuerKey = issuerKey
        self.validFrom = validFrom
        self.validUntil = validUntil
        self.values = values
        self.randomness = randomness
        self.signature = signature
    }
}


extension Web3IdCredential: Equatable, Hashable {
    public static func ==(lhs: Web3IdCredential, rhs: Web3IdCredential) -> Bool {
        if lhs.holderId != rhs.holderId {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.registry != rhs.registry {
            return false
        }
        if lhs.credentialType != rhs.credentialType {
            return false
        }
        if lhs.credentialSchema != rhs.credentialSchema {
            return false
        }
        if lhs.issuerKey != rhs.issuerKey {
            return false
        }
        if lhs.validFrom != rhs.validFrom {
            return false
        }
        if lhs.validUntil != rhs.validUntil {
            return false
        }
        if lhs.values != rhs.values {
            return false
        }
        if lhs.randomness != rhs.randomness {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(holderId)
        hasher.combine(network)
        hasher.combine(registry)
        hasher.combine(credentialType)
        hasher.combine(credentialSchema)
        hasher.combine(issuerKey)
        hasher.combine(validFrom)
        hasher.combine(validUntil)
        hasher.combine(values)
        hasher.combine(randomness)
        hasher.combine(signature)
    }
}


public struct FfiConverterTypeWeb3IdCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Web3IdCredential {
        return
            try Web3IdCredential(
                holderId: FfiConverterTypeBytes.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                registry: FfiConverterTypeContractAddress.read(from: &buf), 
                credentialType: FfiConverterSequenceString.read(from: &buf), 
                credentialSchema: FfiConverterString.read(from: &buf), 
                issuerKey: FfiConverterTypeBytes.read(from: &buf), 
                validFrom: FfiConverterTimestamp.read(from: &buf), 
                validUntil: FfiConverterOptionTimestamp.read(from: &buf), 
                values: FfiConverterDictionaryStringTypeWeb3IdAttribute.read(from: &buf), 
                randomness: FfiConverterDictionaryStringTypeBytes.read(from: &buf), 
                signature: FfiConverterTypeBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Web3IdCredential, into buf: inout [UInt8]) {
        FfiConverterTypeBytes.write(value.holderId, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterTypeContractAddress.write(value.registry, into: &buf)
        FfiConverterSequenceString.write(value.credentialType, into: &buf)
        FfiConverterString.write(value.credentialSchema, into: &buf)
        FfiConverterTypeBytes.write(value.issuerKey, into: &buf)
        FfiConverterTimestamp.write(value.validFrom, into: &buf)
        FfiConverterOptionTimestamp.write(value.validUntil, into: &buf)
        FfiConverterDictionaryStringTypeWeb3IdAttribute.write(value.values, into: &buf)
        FfiConverterDictionaryStringTypeBytes.write(value.randomness, into: &buf)
        FfiConverterTypeBytes.write(value.signature, into: &buf)
    }
}


public func FfiConverterTypeWeb3IdCredential_lift(_ buf: RustBuffer) throws -> Web3IdCredential {
    return try FfiConverterTypeWeb3IdCredential.lift(buf)
}

public func FfiConverterTypeWeb3IdCredential_lower(_ value: Web3IdCredential) -> RustBuffer {
    return FfiConverterTypeWeb3IdCredential.lower(value)
}


/**
 * A pair of a statement and a proof for a Web3 ID credential statement.
 */
public struct Web3IdStatementWithProof {
    public var statement: AtomicWeb3IdStatement
    public var proof: AtomicWeb3IdProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        statement: AtomicWeb3IdStatement, 
        proof: AtomicWeb3IdProof) {
        self.statement = statement
        self.proof = proof
    }
}


extension Web3IdStatementWithProof: Equatable, Hashable {
    public static func ==(lhs: Web3IdStatementWithProof, rhs: Web3IdStatementWithProof) -> Bool {
        if lhs.statement != rhs.statement {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(statement)
        hasher.combine(proof)
    }
}


public struct FfiConverterTypeWeb3IdStatementWithProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Web3IdStatementWithProof {
        return
            try Web3IdStatementWithProof(
                statement: FfiConverterTypeAtomicWeb3IdStatement.read(from: &buf), 
                proof: FfiConverterTypeAtomicWeb3IdProof.read(from: &buf)
        )
    }

    public static func write(_ value: Web3IdStatementWithProof, into buf: inout [UInt8]) {
        FfiConverterTypeAtomicWeb3IdStatement.write(value.statement, into: &buf)
        FfiConverterTypeAtomicWeb3IdProof.write(value.proof, into: &buf)
    }
}


public func FfiConverterTypeWeb3IdStatementWithProof_lift(_ buf: RustBuffer) throws -> Web3IdStatementWithProof {
    return try FfiConverterTypeWeb3IdStatementWithProof.lift(buf)
}

public func FfiConverterTypeWeb3IdStatementWithProof_lower(_ value: Web3IdStatementWithProof) -> RustBuffer {
    return FfiConverterTypeWeb3IdStatementWithProof.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The different types of proofs, corresponding to the statements above.
 */
public enum AtomicIdentityProof {
    
    /**
     * Revealing an attribute and a proof that it equals the attribute value
     * inside the attribute commitment.
     */
    case revealAttribute(
        attribute: String, 
        proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is in a range.
     */
    case attributeInRange(
        proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is in a set.
     */
    case attributeInSet(
        proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is not in a set.
     */
    case attributeNotInSet(
        proof: Bytes
    )
}

public struct FfiConverterTypeAtomicIdentityProof: FfiConverterRustBuffer {
    typealias SwiftType = AtomicIdentityProof

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AtomicIdentityProof {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .revealAttribute(
            attribute: try FfiConverterString.read(from: &buf), 
            proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 2: return .attributeInRange(
            proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 3: return .attributeInSet(
            proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 4: return .attributeNotInSet(
            proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AtomicIdentityProof, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .revealAttribute(attribute,proof):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(attribute, into: &buf)
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeInRange(proof):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeInSet(proof):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeNotInSet(proof):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAtomicIdentityProof_lift(_ buf: RustBuffer) throws -> AtomicIdentityProof {
    return try FfiConverterTypeAtomicIdentityProof.lift(buf)
}

public func FfiConverterTypeAtomicIdentityProof_lower(_ value: AtomicIdentityProof) -> RustBuffer {
    return FfiConverterTypeAtomicIdentityProof.lower(value)
}


extension AtomicIdentityProof: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Statements are composed of one or more atomic statements.
 * This type defines the different types of atomic statements.
 */
public enum AtomicIdentityStatement {
    
    /**
     * The atomic statement stating that an attribute should be revealed.
     */
    case revealAttribute(
        statement: RevealAttributeIdentityStatement
    )
    /**
     * The atomic statement stating that an attribute is in a range.
     */
    case attributeInRange(
        statement: AttributeInRangeIdentityStatement
    )
    /**
     * The atomic statement stating that an attribute is in a set.
     */
    case attributeInSet(
        statement: AttributeInSetIdentityStatement
    )
    /**
     * The atomic statement stating that an attribute is not in a set.
     */
    case attributeNotInSet(
        statement: AttributeNotInSetIdentityStatement
    )
}

public struct FfiConverterTypeAtomicIdentityStatement: FfiConverterRustBuffer {
    typealias SwiftType = AtomicIdentityStatement

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AtomicIdentityStatement {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .revealAttribute(
            statement: try FfiConverterTypeRevealAttributeIdentityStatement.read(from: &buf)
        )
        
        case 2: return .attributeInRange(
            statement: try FfiConverterTypeAttributeInRangeIdentityStatement.read(from: &buf)
        )
        
        case 3: return .attributeInSet(
            statement: try FfiConverterTypeAttributeInSetIdentityStatement.read(from: &buf)
        )
        
        case 4: return .attributeNotInSet(
            statement: try FfiConverterTypeAttributeNotInSetIdentityStatement.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AtomicIdentityStatement, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .revealAttribute(statement):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRevealAttributeIdentityStatement.write(statement, into: &buf)
            
        
        case let .attributeInRange(statement):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAttributeInRangeIdentityStatement.write(statement, into: &buf)
            
        
        case let .attributeInSet(statement):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAttributeInSetIdentityStatement.write(statement, into: &buf)
            
        
        case let .attributeNotInSet(statement):
            writeInt(&buf, Int32(4))
            FfiConverterTypeAttributeNotInSetIdentityStatement.write(statement, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAtomicIdentityStatement_lift(_ buf: RustBuffer) throws -> AtomicIdentityStatement {
    return try FfiConverterTypeAtomicIdentityStatement.lift(buf)
}

public func FfiConverterTypeAtomicIdentityStatement_lower(_ value: AtomicIdentityStatement) -> RustBuffer {
    return FfiConverterTypeAtomicIdentityStatement.lower(value)
}


extension AtomicIdentityStatement: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The different types of proofs, corresponding to the statements above.
 */
public enum AtomicWeb3IdProof {
    
    /**
     * Revealing an attribute and a proof that it equals the attribute value
     * inside the attribute commitment.
     */
    case revealAttribute(
        attribute: Web3IdAttribute, 
        proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is in a range.
     */
    case attributeInRange(
        proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is in a set.
     */
    case attributeInSet(
        proof: Bytes
    )
    /**
     * The atomic proof stating that an attribute is not in a set.
     */
    case attributeNotInSet(
        proof: Bytes
    )
}

public struct FfiConverterTypeAtomicWeb3IdProof: FfiConverterRustBuffer {
    typealias SwiftType = AtomicWeb3IdProof

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AtomicWeb3IdProof {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .revealAttribute(
            attribute: try FfiConverterTypeWeb3IdAttribute.read(from: &buf), 
            proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 2: return .attributeInRange(
            proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 3: return .attributeInSet(
            proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 4: return .attributeNotInSet(
            proof: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AtomicWeb3IdProof, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .revealAttribute(attribute,proof):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWeb3IdAttribute.write(attribute, into: &buf)
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeInRange(proof):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeInSet(proof):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        
        case let .attributeNotInSet(proof):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBytes.write(proof, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAtomicWeb3IdProof_lift(_ buf: RustBuffer) throws -> AtomicWeb3IdProof {
    return try FfiConverterTypeAtomicWeb3IdProof.lift(buf)
}

public func FfiConverterTypeAtomicWeb3IdProof_lower(_ value: AtomicWeb3IdProof) -> RustBuffer {
    return FfiConverterTypeAtomicWeb3IdProof.lower(value)
}


extension AtomicWeb3IdProof: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Statements are composed of one or more atomic statements.
 * This type defines the different types of atomic statements.
 */
public enum AtomicWeb3IdStatement {
    
    /**
     * The atomic statement stating that an attribute should be revealed.
     */
    case revealAttribute(
        statement: RevealAttributeWeb3IdStatement
    )
    /**
     * The atomic statement stating that an attribute is in a range.
     */
    case attributeInRange(
        statement: AttributeInRangeWeb3IdStatement
    )
    /**
     * The atomic statement stating that an attribute is in a set.
     */
    case attributeInSet(
        statement: AttributeInSetWeb3IdStatement
    )
    /**
     * The atomic statement stating that an attribute is not in a set.
     */
    case attributeNotInSet(
        statement: AttributeNotInSetWeb3IdStatement
    )
}

public struct FfiConverterTypeAtomicWeb3IdStatement: FfiConverterRustBuffer {
    typealias SwiftType = AtomicWeb3IdStatement

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AtomicWeb3IdStatement {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .revealAttribute(
            statement: try FfiConverterTypeRevealAttributeWeb3IdStatement.read(from: &buf)
        )
        
        case 2: return .attributeInRange(
            statement: try FfiConverterTypeAttributeInRangeWeb3IdStatement.read(from: &buf)
        )
        
        case 3: return .attributeInSet(
            statement: try FfiConverterTypeAttributeInSetWeb3IdStatement.read(from: &buf)
        )
        
        case 4: return .attributeNotInSet(
            statement: try FfiConverterTypeAttributeNotInSetWeb3IdStatement.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AtomicWeb3IdStatement, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .revealAttribute(statement):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRevealAttributeWeb3IdStatement.write(statement, into: &buf)
            
        
        case let .attributeInRange(statement):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAttributeInRangeWeb3IdStatement.write(statement, into: &buf)
            
        
        case let .attributeInSet(statement):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAttributeInSetWeb3IdStatement.write(statement, into: &buf)
            
        
        case let .attributeNotInSet(statement):
            writeInt(&buf, Int32(4))
            FfiConverterTypeAttributeNotInSetWeb3IdStatement.write(statement, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAtomicWeb3IdStatement_lift(_ buf: RustBuffer) throws -> AtomicWeb3IdStatement {
    return try FfiConverterTypeAtomicWeb3IdStatement.lift(buf)
}

public func FfiConverterTypeAtomicWeb3IdStatement_lower(_ value: AtomicWeb3IdStatement) -> RustBuffer {
    return FfiConverterTypeAtomicWeb3IdStatement.lower(value)
}


extension AtomicWeb3IdStatement: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The supported set of attributes which are stored on identities and optionally revealed by accounts.
 * In some contexts (such as the gRPC API), attribute tags are represented by a byte (the raw type of this enum).
 * Where human readability is a concern, the string representation implemented by ``description`` is used.
 * Note that since ``AttributeList`` (which is a component of ``IdentityObject``) is defined in another library, it cannot use this type.
 * Instead, its field `chosenAttributes` is a map from the string representation of the tag to the value.
 * Use the appropriate initializer of this type to convert it.
 * All attribute values are strings of 31 bytes or less. The expected format of the values is documented
 * [here](https://docs.google.com/spreadsheets/d/1CxpFvtAoUcylHQyeBtRBaRt1zsibtpmQOVsk7bsHPGA/edit).
 */
public enum AttributeTag {
    
    /**
     * First name (format: string up to 31 bytes).
     */
    case firstName
    /**
     * Last name (format: string up to 31 bytes).
     */
    case lastName
    /**
     * Sex (format: ISO/IEC 5218).
     */
    case sex
    /**
     * Date of birth (format: ISO8601 YYYYMMDD).
     */
    case dateOfBirth
    /**
     * Country of residence (format: ISO3166-1 alpha-2).
     */
    case countryOfResidence
    /**
     * Country of nationality (format: ISO3166-1 alpha-2).
     */
    case nationality
    /**
     * Identity document type
     *
     * Format:
     * - 0 : na
     * - 1 : passport
     * - 2 : national ID card
     * - 3 : driving license
     * - 4 : immigration card
     * - eID string (see below)
     *
     * eID strings as of Apr 2024:
     * - DK:MITID        : Danish MitId
     * - SE:BANKID       : Swedish BankID
     * - NO:BANKID       : Norwegian BankID
     * - NO:VIPPS        : Norwegian Vipps
     * - FI:TRUSTNETWORK : Finnish Trust Network
     * - NL:DIGID        : Netherlands DigiD
     * - NL:IDIN         : Netherlands iDIN
     * - BE:EID          : Belgian eID
     * - ITSME           : (Cross-national) ItsME
     * - SOFORT          : (Cross-national) Sofort
     */
    case idDocType
    /**
     * Identity document number (format: string up to 31 bytes).
     */
    case idDocNo
    /**
     * Identity document issuer (format: ISO3166-1 alpha-2 or ISO3166-2 if applicable).
     */
    case idDocIssuer
    /**
     * Time from which the ID is valid (format: ISO8601 YYYYMMDD).
     */
    case idDocIssuedAt
    /**
     * Time to which the ID is valid (format: ISO8601 YYYYMMDD).
     */
    case idDocExpiresAt
    /**
     * National ID number (format: string up to 31 bytes).
     */
    case nationalIdNo
    /**
     * Tax ID number (format: string up to 31 bytes).
     */
    case taxIdNo
    /**
     * LEI-code - companies only (format: ISO17442).
     */
    case legalEntityId
    /**
     * Legal name - companies only
     */
    case legalName
    /**
     * Legal country - companies only
     */
    case legalCountry
    /**
     * Business number associated with the company - companies only
     */
    case businessNumber
    /**
     * Registration authority - companies only
     */
    case registrationAuth
}

public struct FfiConverterTypeAttributeTag: FfiConverterRustBuffer {
    typealias SwiftType = AttributeTag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeTag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .firstName
        
        case 2: return .lastName
        
        case 3: return .sex
        
        case 4: return .dateOfBirth
        
        case 5: return .countryOfResidence
        
        case 6: return .nationality
        
        case 7: return .idDocType
        
        case 8: return .idDocNo
        
        case 9: return .idDocIssuer
        
        case 10: return .idDocIssuedAt
        
        case 11: return .idDocExpiresAt
        
        case 12: return .nationalIdNo
        
        case 13: return .taxIdNo
        
        case 14: return .legalEntityId
        
        case 15: return .legalName
        
        case 16: return .legalCountry
        
        case 17: return .businessNumber
        
        case 18: return .registrationAuth
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AttributeTag, into buf: inout [UInt8]) {
        switch value {
        
        
        case .firstName:
            writeInt(&buf, Int32(1))
        
        
        case .lastName:
            writeInt(&buf, Int32(2))
        
        
        case .sex:
            writeInt(&buf, Int32(3))
        
        
        case .dateOfBirth:
            writeInt(&buf, Int32(4))
        
        
        case .countryOfResidence:
            writeInt(&buf, Int32(5))
        
        
        case .nationality:
            writeInt(&buf, Int32(6))
        
        
        case .idDocType:
            writeInt(&buf, Int32(7))
        
        
        case .idDocNo:
            writeInt(&buf, Int32(8))
        
        
        case .idDocIssuer:
            writeInt(&buf, Int32(9))
        
        
        case .idDocIssuedAt:
            writeInt(&buf, Int32(10))
        
        
        case .idDocExpiresAt:
            writeInt(&buf, Int32(11))
        
        
        case .nationalIdNo:
            writeInt(&buf, Int32(12))
        
        
        case .taxIdNo:
            writeInt(&buf, Int32(13))
        
        
        case .legalEntityId:
            writeInt(&buf, Int32(14))
        
        
        case .legalName:
            writeInt(&buf, Int32(15))
        
        
        case .legalCountry:
            writeInt(&buf, Int32(16))
        
        
        case .businessNumber:
            writeInt(&buf, Int32(17))
        
        
        case .registrationAuth:
            writeInt(&buf, Int32(18))
        
        }
    }
}


public func FfiConverterTypeAttributeTag_lift(_ buf: RustBuffer) throws -> AttributeTag {
    return try FfiConverterTypeAttributeTag.lift(buf)
}

public func FfiConverterTypeAttributeTag_lower(_ value: AttributeTag) -> RustBuffer {
    return FfiConverterTypeAttributeTag.lower(value)
}


extension AttributeTag: Equatable, Hashable {}




/**
 * Generic error while invoking FFI
 */
public enum ConcordiumWalletCryptoError {

    
    
    case CallFailed(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeConcordiumWalletCryptoError.lift(error)
    }
}


public struct FfiConverterTypeConcordiumWalletCryptoError: FfiConverterRustBuffer {
    typealias SwiftType = ConcordiumWalletCryptoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConcordiumWalletCryptoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CallFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConcordiumWalletCryptoError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .CallFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


extension ConcordiumWalletCryptoError: Equatable, Hashable {}

extension ConcordiumWalletCryptoError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum IdentifierType {
    
    /**
     * Reference to an account via an address.
     */
    case account(
        addressBase58: String
    )
    /**
     * Reference to a specific credential via its ID.
     */
    case credential(
        credId: Bytes
    )
    /**
     * Reference to a specific smart contract instance.
     */
    case contractData(
        address: ContractAddress, 
        entrypoint: String, 
        parameter: Bytes
    )
    /**
     * Reference to a specific Ed25519 public key.
     */
    case publicKey(
        key: Data
    )
    /**
     * Reference to a specific identity provider.
     */
    case idp(
        idpIdentity: UInt32
    )
}

public struct FfiConverterTypeIdentifierType: FfiConverterRustBuffer {
    typealias SwiftType = IdentifierType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentifierType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(
            addressBase58: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .credential(
            credId: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 3: return .contractData(
            address: try FfiConverterTypeContractAddress.read(from: &buf), 
            entrypoint: try FfiConverterString.read(from: &buf), 
            parameter: try FfiConverterTypeBytes.read(from: &buf)
        )
        
        case 4: return .publicKey(
            key: try FfiConverterData.read(from: &buf)
        )
        
        case 5: return .idp(
            idpIdentity: try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: IdentifierType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(addressBase58):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(addressBase58, into: &buf)
            
        
        case let .credential(credId):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBytes.write(credId, into: &buf)
            
        
        case let .contractData(address,entrypoint,parameter):
            writeInt(&buf, Int32(3))
            FfiConverterTypeContractAddress.write(address, into: &buf)
            FfiConverterString.write(entrypoint, into: &buf)
            FfiConverterTypeBytes.write(parameter, into: &buf)
            
        
        case let .publicKey(key):
            writeInt(&buf, Int32(4))
            FfiConverterData.write(key, into: &buf)
            
        
        case let .idp(idpIdentity):
            writeInt(&buf, Int32(5))
            FfiConverterUInt32.write(idpIdentity, into: &buf)
            
        }
    }
}


public func FfiConverterTypeIdentifierType_lift(_ buf: RustBuffer) throws -> IdentifierType {
    return try FfiConverterTypeIdentifierType.lift(buf)
}

public func FfiConverterTypeIdentifierType_lower(_ value: IdentifierType) -> RustBuffer {
    return FfiConverterTypeIdentifierType.lower(value)
}


extension IdentifierType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the different contract module schema versions
 */
public enum ModuleSchemaVersion {
    
    case v0
    case v1
    case v2
    case v3
}

public struct FfiConverterTypeModuleSchemaVersion: FfiConverterRustBuffer {
    typealias SwiftType = ModuleSchemaVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModuleSchemaVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v0
        
        case 2: return .v1
        
        case 3: return .v2
        
        case 4: return .v3
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ModuleSchemaVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v0:
            writeInt(&buf, Int32(1))
        
        
        case .v1:
            writeInt(&buf, Int32(2))
        
        
        case .v2:
            writeInt(&buf, Int32(3))
        
        
        case .v3:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeModuleSchemaVersion_lift(_ buf: RustBuffer) throws -> ModuleSchemaVersion {
    return try FfiConverterTypeModuleSchemaVersion.lift(buf)
}

public func FfiConverterTypeModuleSchemaVersion_lower(_ value: ModuleSchemaVersion) -> RustBuffer {
    return FfiConverterTypeModuleSchemaVersion.lower(value)
}


extension ModuleSchemaVersion: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Network {
    
    case testnet
    case mainnet
}

public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .testnet
        
        case 2: return .mainnet
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .testnet:
            writeInt(&buf, Int32(1))
        
        
        case .mainnet:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


extension Network: Equatable, Hashable {}




/**
 * Describes errors happening while interacting with contract schemas
 */
public enum SchemaError {

    
    
    /**
     * Failed to convert value with schema
     */
    case Convert(message: String)
    
    /**
     * Failed parse the module schema
     */
    case ParseSchema(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeSchemaError.lift(error)
    }
}


public struct FfiConverterTypeSchemaError: FfiConverterRustBuffer {
    typealias SwiftType = SchemaError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SchemaError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Convert(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .ParseSchema(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SchemaError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Convert(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .ParseSchema(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


extension SchemaError: Equatable, Hashable {}

extension SchemaError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The additional inputs, additional to the `VerifiablePresentationRequest` that are needed to
 * produce a `VerifablePresentation`.
 */
public enum VerifiableCredentialCommitmentInputs {
    
    /**
     * Inputs are for an identity credential issued by an identity provider.
     */
    case account(
        issuer: UInt32, 
        values: [AttributeTag: String], 
        randomness: [AttributeTag: Bytes]
    )
    /**
     * Inputs are for a credential issued by Web3ID issuer.
     */
    case web3Issuer(
        signature: Bytes, 
        signer: Data, 
        values: [String: Web3IdAttribute], 
        randomness: [String: Bytes]
    )
}

public struct FfiConverterTypeVerifiableCredentialCommitmentInputs: FfiConverterRustBuffer {
    typealias SwiftType = VerifiableCredentialCommitmentInputs

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiableCredentialCommitmentInputs {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(
            issuer: try FfiConverterUInt32.read(from: &buf), 
            values: try FfiConverterDictionaryTypeAttributeTagString.read(from: &buf), 
            randomness: try FfiConverterDictionaryTypeAttributeTagTypeBytes.read(from: &buf)
        )
        
        case 2: return .web3Issuer(
            signature: try FfiConverterTypeBytes.read(from: &buf), 
            signer: try FfiConverterData.read(from: &buf), 
            values: try FfiConverterDictionaryStringTypeWeb3IdAttribute.read(from: &buf), 
            randomness: try FfiConverterDictionaryStringTypeBytes.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerifiableCredentialCommitmentInputs, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(issuer,values,randomness):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(issuer, into: &buf)
            FfiConverterDictionaryTypeAttributeTagString.write(values, into: &buf)
            FfiConverterDictionaryTypeAttributeTagTypeBytes.write(randomness, into: &buf)
            
        
        case let .web3Issuer(signature,signer,values,randomness):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBytes.write(signature, into: &buf)
            FfiConverterData.write(signer, into: &buf)
            FfiConverterDictionaryStringTypeWeb3IdAttribute.write(values, into: &buf)
            FfiConverterDictionaryStringTypeBytes.write(randomness, into: &buf)
            
        }
    }
}


public func FfiConverterTypeVerifiableCredentialCommitmentInputs_lift(_ buf: RustBuffer) throws -> VerifiableCredentialCommitmentInputs {
    return try FfiConverterTypeVerifiableCredentialCommitmentInputs.lift(buf)
}

public func FfiConverterTypeVerifiableCredentialCommitmentInputs_lower(_ value: VerifiableCredentialCommitmentInputs) -> RustBuffer {
    return FfiConverterTypeVerifiableCredentialCommitmentInputs.lower(value)
}


extension VerifiableCredentialCommitmentInputs: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A proof corresponding to one `VerifiableCredentialStatement`. This contains almost
 * all the information needed to verify it, except the issuer's public key in
 * case of the `Web3Id` proof, and the public commitments in case of the
 * `Account` proof.
 */
public enum VerifiableCredentialProof {
    
    case account(
        created: Date, 
        network: Network, 
        credId: Bytes, 
        issuer: UInt32, 
        proofs: [AccountStatementWithProof]
    )
    case web3Id(
        created: Date, 
        holderId: Bytes, 
        network: Network, 
        contract: ContractAddress, 
        credType: [String], 
        commitments: SignedCommitments, 
        proofs: [Web3IdStatementWithProof]
    )
}

public struct FfiConverterTypeVerifiableCredentialProof: FfiConverterRustBuffer {
    typealias SwiftType = VerifiableCredentialProof

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiableCredentialProof {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(
            created: try FfiConverterTimestamp.read(from: &buf), 
            network: try FfiConverterTypeNetwork.read(from: &buf), 
            credId: try FfiConverterTypeBytes.read(from: &buf), 
            issuer: try FfiConverterUInt32.read(from: &buf), 
            proofs: try FfiConverterSequenceTypeAccountStatementWithProof.read(from: &buf)
        )
        
        case 2: return .web3Id(
            created: try FfiConverterTimestamp.read(from: &buf), 
            holderId: try FfiConverterTypeBytes.read(from: &buf), 
            network: try FfiConverterTypeNetwork.read(from: &buf), 
            contract: try FfiConverterTypeContractAddress.read(from: &buf), 
            credType: try FfiConverterSequenceString.read(from: &buf), 
            commitments: try FfiConverterTypeSignedCommitments.read(from: &buf), 
            proofs: try FfiConverterSequenceTypeWeb3IdStatementWithProof.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerifiableCredentialProof, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(created,network,credId,issuer,proofs):
            writeInt(&buf, Int32(1))
            FfiConverterTimestamp.write(created, into: &buf)
            FfiConverterTypeNetwork.write(network, into: &buf)
            FfiConverterTypeBytes.write(credId, into: &buf)
            FfiConverterUInt32.write(issuer, into: &buf)
            FfiConverterSequenceTypeAccountStatementWithProof.write(proofs, into: &buf)
            
        
        case let .web3Id(created,holderId,network,contract,credType,commitments,proofs):
            writeInt(&buf, Int32(2))
            FfiConverterTimestamp.write(created, into: &buf)
            FfiConverterTypeBytes.write(holderId, into: &buf)
            FfiConverterTypeNetwork.write(network, into: &buf)
            FfiConverterTypeContractAddress.write(contract, into: &buf)
            FfiConverterSequenceString.write(credType, into: &buf)
            FfiConverterTypeSignedCommitments.write(commitments, into: &buf)
            FfiConverterSequenceTypeWeb3IdStatementWithProof.write(proofs, into: &buf)
            
        }
    }
}


public func FfiConverterTypeVerifiableCredentialProof_lift(_ buf: RustBuffer) throws -> VerifiableCredentialProof {
    return try FfiConverterTypeVerifiableCredentialProof.lift(buf)
}

public func FfiConverterTypeVerifiableCredentialProof_lower(_ value: VerifiableCredentialProof) -> RustBuffer {
    return FfiConverterTypeVerifiableCredentialProof.lower(value)
}


extension VerifiableCredentialProof: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A statement about a single credential, either an identity credential or a
 * Web3 credential.
 */
public enum VerifiableCredentialStatement {
    
    /**
     * Statement about a credential derived from an identity issued by an
     * identity provider.
     */
    case account(
        network: Network, 
        credId: Bytes, 
        statement: [AtomicIdentityStatement]
    )
    /**
     * Statement about a credential issued by a Web3 identity provider, a smart
     * contract.
     */
    case web3Id(
        credType: [String], 
        network: Network, 
        contract: ContractAddress, 
        holderId: Bytes, 
        statement: [AtomicWeb3IdStatement]
    )
}

public struct FfiConverterTypeVerifiableCredentialStatement: FfiConverterRustBuffer {
    typealias SwiftType = VerifiableCredentialStatement

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiableCredentialStatement {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(
            network: try FfiConverterTypeNetwork.read(from: &buf), 
            credId: try FfiConverterTypeBytes.read(from: &buf), 
            statement: try FfiConverterSequenceTypeAtomicIdentityStatement.read(from: &buf)
        )
        
        case 2: return .web3Id(
            credType: try FfiConverterSequenceString.read(from: &buf), 
            network: try FfiConverterTypeNetwork.read(from: &buf), 
            contract: try FfiConverterTypeContractAddress.read(from: &buf), 
            holderId: try FfiConverterTypeBytes.read(from: &buf), 
            statement: try FfiConverterSequenceTypeAtomicWeb3IdStatement.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerifiableCredentialStatement, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(network,credId,statement):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNetwork.write(network, into: &buf)
            FfiConverterTypeBytes.write(credId, into: &buf)
            FfiConverterSequenceTypeAtomicIdentityStatement.write(statement, into: &buf)
            
        
        case let .web3Id(credType,network,contract,holderId,statement):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceString.write(credType, into: &buf)
            FfiConverterTypeNetwork.write(network, into: &buf)
            FfiConverterTypeContractAddress.write(contract, into: &buf)
            FfiConverterTypeBytes.write(holderId, into: &buf)
            FfiConverterSequenceTypeAtomicWeb3IdStatement.write(statement, into: &buf)
            
        }
    }
}


public func FfiConverterTypeVerifiableCredentialStatement_lift(_ buf: RustBuffer) throws -> VerifiableCredentialStatement {
    return try FfiConverterTypeVerifiableCredentialStatement.lift(buf)
}

public func FfiConverterTypeVerifiableCredentialStatement_lower(_ value: VerifiableCredentialStatement) -> RustBuffer {
    return FfiConverterTypeVerifiableCredentialStatement.lower(value)
}


extension VerifiableCredentialStatement: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A value of an attribute. This is the low-level representation. The
 * different variants are present to enable different representations in JSON,
 * and different embeddings as field elements when constructing and verifying
 * proofs.
 */
public enum Web3IdAttribute {
    
    case string(
        value: String
    )
    case numeric(
        value: UInt64
    )
    case timestamp(
        value: Date
    )
}

public struct FfiConverterTypeWeb3IdAttribute: FfiConverterRustBuffer {
    typealias SwiftType = Web3IdAttribute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Web3IdAttribute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .string(
            value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .numeric(
            value: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .timestamp(
            value: try FfiConverterTimestamp.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Web3IdAttribute, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .string(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .numeric(value):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(value, into: &buf)
            
        
        case let .timestamp(value):
            writeInt(&buf, Int32(3))
            FfiConverterTimestamp.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeWeb3IdAttribute_lift(_ buf: RustBuffer) throws -> Web3IdAttribute {
    return try FfiConverterTypeWeb3IdAttribute.lift(buf)
}

public func FfiConverterTypeWeb3IdAttribute_lower(_ value: Web3IdAttribute) -> RustBuffer {
    return FfiConverterTypeWeb3IdAttribute.lower(value)
}


extension Web3IdAttribute: Equatable, Hashable {}



fileprivate struct FfiConverterOptionTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeModuleSchemaVersion: FfiConverterRustBuffer {
    typealias SwiftType = ModuleSchemaVersion?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeModuleSchemaVersion.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeModuleSchemaVersion.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAccountStatementWithProof: FfiConverterRustBuffer {
    typealias SwiftType = [AccountStatementWithProof]

    public static func write(_ value: [AccountStatementWithProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountStatementWithProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountStatementWithProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountStatementWithProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAccountStatementWithProof.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeWeb3IdStatementWithProof: FfiConverterRustBuffer {
    typealias SwiftType = [Web3IdStatementWithProof]

    public static func write(_ value: [Web3IdStatementWithProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWeb3IdStatementWithProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Web3IdStatementWithProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [Web3IdStatementWithProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWeb3IdStatementWithProof.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAtomicIdentityProof: FfiConverterRustBuffer {
    typealias SwiftType = [AtomicIdentityProof]

    public static func write(_ value: [AtomicIdentityProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAtomicIdentityProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AtomicIdentityProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [AtomicIdentityProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAtomicIdentityProof.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAtomicIdentityStatement: FfiConverterRustBuffer {
    typealias SwiftType = [AtomicIdentityStatement]

    public static func write(_ value: [AtomicIdentityStatement], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAtomicIdentityStatement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AtomicIdentityStatement] {
        let len: Int32 = try readInt(&buf)
        var seq = [AtomicIdentityStatement]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAtomicIdentityStatement.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAtomicWeb3IdStatement: FfiConverterRustBuffer {
    typealias SwiftType = [AtomicWeb3IdStatement]

    public static func write(_ value: [AtomicWeb3IdStatement], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAtomicWeb3IdStatement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AtomicWeb3IdStatement] {
        let len: Int32 = try readInt(&buf)
        var seq = [AtomicWeb3IdStatement]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAtomicWeb3IdStatement.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAttributeTag: FfiConverterRustBuffer {
    typealias SwiftType = [AttributeTag]

    public static func write(_ value: [AttributeTag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttributeTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttributeTag] {
        let len: Int32 = try readInt(&buf)
        var seq = [AttributeTag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAttributeTag.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeVerifiableCredentialCommitmentInputs: FfiConverterRustBuffer {
    typealias SwiftType = [VerifiableCredentialCommitmentInputs]

    public static func write(_ value: [VerifiableCredentialCommitmentInputs], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVerifiableCredentialCommitmentInputs.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VerifiableCredentialCommitmentInputs] {
        let len: Int32 = try readInt(&buf)
        var seq = [VerifiableCredentialCommitmentInputs]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVerifiableCredentialCommitmentInputs.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeVerifiableCredentialProof: FfiConverterRustBuffer {
    typealias SwiftType = [VerifiableCredentialProof]

    public static func write(_ value: [VerifiableCredentialProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVerifiableCredentialProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VerifiableCredentialProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [VerifiableCredentialProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVerifiableCredentialProof.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeVerifiableCredentialStatement: FfiConverterRustBuffer {
    typealias SwiftType = [VerifiableCredentialStatement]

    public static func write(_ value: [VerifiableCredentialStatement], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVerifiableCredentialStatement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VerifiableCredentialStatement] {
        let len: Int32 = try readInt(&buf)
        var seq = [VerifiableCredentialStatement]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVerifiableCredentialStatement.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeWeb3IdAttribute: FfiConverterRustBuffer {
    typealias SwiftType = [Web3IdAttribute]

    public static func write(_ value: [Web3IdAttribute], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWeb3IdAttribute.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Web3IdAttribute] {
        let len: Int32 = try readInt(&buf)
        var seq = [Web3IdAttribute]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWeb3IdAttribute.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeBytes: FfiConverterRustBuffer {
    typealias SwiftType = [Bytes]

    public static func write(_ value: [Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBytes.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bytes] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bytes]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBytes.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryUInt8TypeCredentialDeploymentInfo: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: CredentialDeploymentInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterTypeCredentialDeploymentInfo.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: CredentialDeploymentInfo] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: CredentialDeploymentInfo]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterTypeCredentialDeploymentInfo.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryUInt8TypeVerifyKey: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: VerifyKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterTypeVerifyKey.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: VerifyKey] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: VerifyKey]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterTypeVerifyKey.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryUInt8TypeBytes: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterTypeBytes.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: Bytes] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: Bytes]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterTypeBytes.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryUInt32TypeAnonymityRevokerInfo: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: AnonymityRevokerInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeAnonymityRevokerInfo.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: AnonymityRevokerInfo] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: AnonymityRevokerInfo]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeAnonymityRevokerInfo.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryUInt32TypeArData: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: ArData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeArData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: ArData] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: ArData]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeArData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryUInt32TypeChainArData: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: ChainArData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterTypeChainArData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: ChainArData] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: ChainArData]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterTypeChainArData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeWeb3IdAttribute: FfiConverterRustBuffer {
    public static func write(_ value: [String: Web3IdAttribute], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeWeb3IdAttribute.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Web3IdAttribute] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Web3IdAttribute]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeWeb3IdAttribute.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeBytes: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeBytes.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bytes] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bytes]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeBytes.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeAttributeTagString: FfiConverterRustBuffer {
    public static func write(_ value: [AttributeTag: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAttributeTag.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttributeTag: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [AttributeTag: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAttributeTag.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeAttributeTagTypeBytes: FfiConverterRustBuffer {
    public static func write(_ value: [AttributeTag: Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAttributeTag.write(key, into: &buf)
            FfiConverterTypeBytes.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttributeTag: Bytes] {
        let len: Int32 = try readInt(&buf)
        var dict = [AttributeTag: Bytes]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAttributeTag.read(from: &buf)
            let value = try FfiConverterTypeBytes.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bytes = Data
public struct FfiConverterTypeBytes: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bytes {
        return try FfiConverterData.read(from: &buf)
    }

    public static func write(_ value: Bytes, into buf: inout [UInt8]) {
        return FfiConverterData.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bytes {
        return try FfiConverterData.lift(value)
    }

    public static func lower(_ value: Bytes) -> RustBuffer {
        return FfiConverterData.lower(value)
    }
}


public func FfiConverterTypeBytes_lift(_ value: RustBuffer) throws -> Bytes {
    return try FfiConverterTypeBytes.lift(value)
}

public func FfiConverterTypeBytes_lower(_ value: Bytes) -> RustBuffer {
    return FfiConverterTypeBytes.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias MicroCCDAmount = UInt64
public struct FfiConverterTypeMicroCCDAmount: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MicroCCDAmount {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: MicroCCDAmount, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> MicroCCDAmount {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: MicroCCDAmount) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}


public func FfiConverterTypeMicroCCDAmount_lift(_ value: UInt64) throws -> MicroCCDAmount {
    return try FfiConverterTypeMicroCCDAmount.lift(value)
}

public func FfiConverterTypeMicroCCDAmount_lower(_ value: MicroCCDAmount) -> UInt64 {
    return FfiConverterTypeMicroCCDAmount.lower(value)
}

/**
 * Construct an account credential from the information contained in the provided parameters.
 */
public func accountCredential(params: AccountCredentialParameters) throws  -> AccountCredentialWithRandomness {
    return try  FfiConverterTypeAccountCredentialWithRandomness.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential(
        FfiConverterTypeAccountCredentialParameters.lower(params),$0)
}
    )
}
/**
 * Compute the attribute commitment randomness for the provided seed, identity indexes, credential counter, and attribute number.
 */
public func accountCredentialAttributeCommitmentRandomness(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8, attribute: UInt8) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_attribute_commitment_randomness(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterTypeNetwork.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),
        FfiConverterUInt8.lower(attribute),$0)
}
    )
}
/**
 * Compute the hash of a new credential deployment to be signed by the account key derived for the credential.
 */
public func accountCredentialDeploymentHash(credential: AccountCredential, expiryUnixSecs: UInt64) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_deployment_hash(
        FfiConverterTypeAccountCredential.lower(credential),
        FfiConverterUInt64.lower(expiryUnixSecs),$0)
}
    )
}
/**
 * Serializes the credential deployment payload for submission as a "raw" payload to a node.
 */
public func accountCredentialDeploymentSignedPayload(credential: SignedAccountCredential) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_deployment_signed_payload(
        FfiConverterTypeSignedAccountCredential.lower(credential),$0)
}
    )
}
/**
 * Compute the credential ID for the provided seed, identity indexes, credential counter, and the chain's commitment key.
 */
public func accountCredentialId(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8, commitmentKey: Bytes) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_id(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterTypeNetwork.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),
        FfiConverterTypeBytes.lower(commitmentKey),$0)
}
    )
}
/**
 * Compute the account credential public key for the provided seed, identity indexes, and credential counter.
 */
public func accountCredentialPublicKey(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_public_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterTypeNetwork.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),$0)
}
    )
}
/**
 * Compute the account credential signing key for the provided seed, identity indexes, and credential counter.
 */
public func accountCredentialSigningKey(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32, credentialCounter: UInt8) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_account_credential_signing_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterTypeNetwork.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialCounter),$0)
}
    )
}
/**
 * Attempt to combine two encrypted amounts
 */
public func combineEncryptedAmounts(left: Bytes, right: Bytes) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_combine_encrypted_amounts(
        FfiConverterTypeBytes.lower(left),
        FfiConverterTypeBytes.lower(right),$0)
}
    )
}
/**
 * Create a verifiable presentation from a `VerifiablePresentationRequest`, the associated
 * commitment inputs and the cryptographic parameters of the chain.
 */
public func createVerifiablePresentation(request: VerifiablePresentationRequest, global: GlobalContext, commitmentInputs: [VerifiableCredentialCommitmentInputs]) throws  -> VerifiablePresentation {
    return try  FfiConverterTypeVerifiablePresentation.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_create_verifiable_presentation(
        FfiConverterTypeVerifiablePresentationRequest.lower(request),
        FfiConverterTypeGlobalContext.lower(global),
        FfiConverterSequenceTypeVerifiableCredentialCommitmentInputs.lower(commitmentInputs),$0)
}
    )
}
/**
 * Attempt to decryp the encrypted amount with the given encryption key
 */
public func decryptAmount(encryptedAmount: Bytes, encryptionSecretKey: Bytes) throws  -> MicroCCDAmount {
    return try  FfiConverterTypeMicroCCDAmount.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_decrypt_amount(
        FfiConverterTypeBytes.lower(encryptedAmount),
        FfiConverterTypeBytes.lower(encryptionSecretKey),$0)
}
    )
}
/**
 * Attempt to deserialize SecToPubTransferData from the supplied bytes. This will fail if the number of bytes does not exactly match the expected number.
 */
public func deserializeSecToPubTransferData(bytes: Data) throws  -> SecToPubTransferDataDeserializeResult {
    return try  FfiConverterTypeSecToPubTransferDataDeserializeResult.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_deserialize_sec_to_pub_transfer_data(
        FfiConverterData.lower(bytes),$0)
}
    )
}
/**
 * Deserialize the provided value into the JSON representation of a type corresponding to the provided `schema`
 */
public func deserializeTypeValue(value: Data, schema: TypeSchema) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_deserialize_type_value(
        FfiConverterData.lower(value),
        FfiConverterTypeTypeSchema.lower(schema),$0)
}
    )
}
/**
 * Attempt to deserialize UpdateCredentialsPayloadDeserializeResult from the supplied bytes. This will fail if the number of bytes does not exactly match the expected number.
 */
public func deserializeUpdateCredentialsPayload(bytes: Data) throws  -> UpdateCredentialsPayloadDeserializeResult {
    return try  FfiConverterTypeUpdateCredentialsPayloadDeserializeResult.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_deserialize_update_credentials_payload(
        FfiConverterData.lower(bytes),$0)
}
    )
}
/**
 * Format the given `Method` as a DID string
 */
public func didMethodAsString(did: Did) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_did_method_as_string(
        FfiConverterTypeDID.lower(did),$0)
}
    )
}
/**
 * Returns the schema template for the given `TypeSchema`
 */
public func displayTypeSchemaTemplate(schema: TypeSchema) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_display_type_schema_template(
        FfiConverterTypeTypeSchema.lower(schema),$0)
}
    )
}
/**
 * Create a set of baker keys
 */
public func generateBakerKeys()  -> BakerKeyPairs {
    return try!  FfiConverterTypeBakerKeyPairs.lift(
        try! rustCall() {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_generate_baker_keys($0)
}
    )
}
/**
 * Attempt to create the encryption keys associated with an account at the given credential index
 */
public func getEncryptionKeys(globalContext: GlobalContext, prfKey: Bytes, credentialIndex: UInt8) throws  -> EncryptionKeys {
    return try  FfiConverterTypeEncryptionKeys.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_encryption_keys(
        FfiConverterTypeGlobalContext.lower(globalContext),
        FfiConverterTypeBytes.lower(prfKey),
        FfiConverterUInt8.lower(credentialIndex),$0)
}
    )
}
/**
 * Get the `TypeSchema` for events emitted by a contract
 */
public func getEventSchema(schema: ModuleSchema, contractName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_event_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),$0)
}
    )
}
/**
 * Get the `TypeSchema` for an error of the init function of a contract
 */
public func getInitErrorSchema(schema: ModuleSchema, contractName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_init_error_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),$0)
}
    )
}
/**
 * Get the `TypeSchema` for a parameter of the init function of a contract
 */
public func getInitParameterSchema(schema: ModuleSchema, contractName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_init_parameter_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),$0)
}
    )
}
/**
 * Get the `TypeSchema` for an error of a given receive function
 */
public func getReceiveErrorSchema(schema: ModuleSchema, contractName: String, functionName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_receive_error_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),
        FfiConverterString.lower(functionName),$0)
}
    )
}
/**
 * Get the `TypeSchema` for a parameter of a given receive function
 */
public func getReceiveParameterSchema(schema: ModuleSchema, contractName: String, functionName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_receive_parameter_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),
        FfiConverterString.lower(functionName),$0)
}
    )
}
/**
 * Get the `TypeSchema` for a return value of a given receive function
 */
public func getReceiveReturnValueSchema(schema: ModuleSchema, contractName: String, functionName: String) throws  -> TypeSchema {
    return try  FfiConverterTypeTypeSchema.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_get_receive_return_value_schema(
        FfiConverterTypeModuleSchema.lower(schema),
        FfiConverterString.lower(contractName),
        FfiConverterString.lower(functionName),$0)
}
    )
}
/**
 * Compute the signature blinding randomness for the provided seed and identity indexes.
 */
public func identityAttributesSignatureBlindingRandomness(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_attributes_signature_blinding_randomness(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterTypeNetwork.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),$0)
}
    )
}
/**
 * Compute the IdCredSec for the provided seed and identity indexes.
 */
public func identityCredSec(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_cred_sec(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterTypeNetwork.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),$0)
}
    )
}
/**
 * Compute an identity issuance request for the identity contained in the provided parameters.
 * The result is a versioned `PreIdentityObject` encoded as JSON,
 * which is the format expected by the identity provider's issuance endpoint.
 */
public func identityIssuanceRequestJson(params: IdentityIssuanceRequestParameters) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_issuance_request_json(
        FfiConverterTypeIdentityIssuanceRequestParameters.lower(params),$0)
}
    )
}
/**
 * Compute the PRF-key for the provided seed and identity indexes.
 */
public func identityPrfKey(seed: Bytes, network: Network, identityProviderId: UInt32, identityIndex: UInt32) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_prf_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterTypeNetwork.lower(network),
        FfiConverterUInt32.lower(identityProviderId),
        FfiConverterUInt32.lower(identityIndex),$0)
}
    )
}
/**
 * Construct an identity recovery request for the identity contained in the provided parameters.
 * The result encoded as JSON in the format expected by the identity provider's recovery endpoint.
 */
public func identityRecoveryRequestJson(params: IdentityRecoveryRequestParameters) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_identity_recovery_request_json(
        FfiConverterTypeIdentityRecoveryRequestParameters.lower(params),$0)
}
    )
}
/**
 * Attempt to create a BakerKeysPayload for the account and associated baker keys
 */
public func makeConfigureBakerKeysPayload(accountBase58: String, bakerKeys: BakerKeyPairs) throws  -> BakerKeysPayload {
    return try  FfiConverterTypeBakerKeysPayload.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_make_configure_baker_keys_payload(
        FfiConverterString.lower(accountBase58),
        FfiConverterTypeBakerKeyPairs.lower(bakerKeys),$0)
}
    )
}
/**
 * Parse the `Method` from the given string
 */
public func parseDidMethod(value: String) throws  -> Did {
    return try  FfiConverterTypeDID.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_parse_did_method(
        FfiConverterString.lower(value),$0)
}
    )
}
/**
 * Prove the supplied statement in the context of a given identity and credential
 */
public func proveIdentityStatement(seed: Bytes, net: Network, globalContext: GlobalContext, ipIndex: UInt32, identityIndex: UInt32, credentialIndex: UInt8, identityObject: IdentityObject, statement: IdentityStatement, challenge: Bytes) throws  -> VersionedIdentityProof {
    return try  FfiConverterTypeVersionedIdentityProof.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_prove_identity_statement(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterTypeNetwork.lower(net),
        FfiConverterTypeGlobalContext.lower(globalContext),
        FfiConverterUInt32.lower(ipIndex),
        FfiConverterUInt32.lower(identityIndex),
        FfiConverterUInt8.lower(credentialIndex),
        FfiConverterTypeIdentityObject.lower(identityObject),
        FfiConverterTypeIdentityStatement.lower(statement),
        FfiConverterTypeBytes.lower(challenge),$0)
}
    )
}
/**
 * Construct the payload for a TransferToPublic transaction. The `to_transfer` amount is specififed in microCCD.
 */
public func secToPubTransferData(ctx: GlobalContext, senderSecretKey: Bytes, inputAmount: InputEncryptedAmount, toTransfer: MicroCCDAmount) throws  -> SecToPubTransferData {
    return try  FfiConverterTypeSecToPubTransferData.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_sec_to_pub_transfer_data(
        FfiConverterTypeGlobalContext.lower(ctx),
        FfiConverterTypeBytes.lower(senderSecretKey),
        FfiConverterTypeInputEncryptedAmount.lower(inputAmount),
        FfiConverterTypeMicroCCDAmount.lower(toTransfer),$0)
}
    )
}
/**
 * Attempt to serialize CredentialDeploymentInfo into bytes. This will fail if any of the raw hex representations do not match the corresponding types in concordium-base
 */
public func serializeCredentialDeploymentInfo(credInfo: CredentialDeploymentInfo) throws  -> Data {
    return try  FfiConverterData.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_serialize_credential_deployment_info(
        FfiConverterTypeCredentialDeploymentInfo.lower(credInfo),$0)
}
    )
}
/**
 * Serialize the provided value from the JSON representation of a type corresponding to the provided `schema`
 */
public func serializeTypeValue(json: String, schema: TypeSchema) throws  -> Data {
    return try  FfiConverterData.lift(
        try rustCallWithError(FfiConverterTypeSchemaError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_serialize_type_value(
        FfiConverterString.lower(json),
        FfiConverterTypeTypeSchema.lower(schema),$0)
}
    )
}
/**
 * Compute the encoded verifiable credential backup encryption key for the provided seed.
 */
public func verifiableCredentialBackupEncryptionKey(seed: Bytes, network: Network) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_backup_encryption_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterTypeNetwork.lower(network),$0)
}
    )
}
/**
 * Compute the public key for the provided seed, issuer indexes, and verifiable credential index.
 */
public func verifiableCredentialPublicKey(seed: Bytes, network: Network, issuerIndex: UInt64, issuerSubindex: UInt64, verifiableCredentialIndex: UInt32) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_public_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterTypeNetwork.lower(network),
        FfiConverterUInt64.lower(issuerIndex),
        FfiConverterUInt64.lower(issuerSubindex),
        FfiConverterUInt32.lower(verifiableCredentialIndex),$0)
}
    )
}
/**
 * Compute the signing key for the provided seed, issuer indexes, and verifiable credential index.
 */
public func verifiableCredentialSigningKey(seed: Bytes, network: Network, issuerIndex: UInt64, issuerSubindex: UInt64, verifiableCredentialIndex: UInt32) throws  -> Bytes {
    return try  FfiConverterTypeBytes.lift(
        try rustCallWithError(FfiConverterTypeConcordiumWalletCryptoError.lift) {
    uniffi_concordium_wallet_crypto_uniffi_fn_func_verifiable_credential_signing_key(
        FfiConverterTypeBytes.lower(seed),
        FfiConverterTypeNetwork.lower(network),
        FfiConverterUInt64.lower(issuerIndex),
        FfiConverterUInt64.lower(issuerSubindex),
        FfiConverterUInt32.lower(verifiableCredentialIndex),$0)
}
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_concordium_wallet_crypto_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential() != 60596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_attribute_commitment_randomness() != 65162) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_deployment_hash() != 17693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_deployment_signed_payload() != 42141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_id() != 45072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_public_key() != 63456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_account_credential_signing_key() != 17934) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_combine_encrypted_amounts() != 56311) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_create_verifiable_presentation() != 16440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_decrypt_amount() != 53254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_deserialize_sec_to_pub_transfer_data() != 15687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_deserialize_type_value() != 39476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_deserialize_update_credentials_payload() != 65247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_did_method_as_string() != 44533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_display_type_schema_template() != 53699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_generate_baker_keys() != 22656) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_encryption_keys() != 21403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_event_schema() != 34116) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_init_error_schema() != 41457) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_init_parameter_schema() != 54176) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_receive_error_schema() != 54098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_receive_parameter_schema() != 54281) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_get_receive_return_value_schema() != 56848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_attributes_signature_blinding_randomness() != 9155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_cred_sec() != 35003) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_issuance_request_json() != 28061) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_prf_key() != 7623) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_identity_recovery_request_json() != 33579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_make_configure_baker_keys_payload() != 25683) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_parse_did_method() != 35114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_prove_identity_statement() != 64093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_sec_to_pub_transfer_data() != 40421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_serialize_credential_deployment_info() != 61448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_serialize_type_value() != 39554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_backup_encryption_key() != 5491) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_public_key() != 47622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_concordium_wallet_crypto_uniffi_checksum_func_verifiable_credential_signing_key() != 63938) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}